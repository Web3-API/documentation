[{"title":"ABI","type":0,"sectionRef":"#","url":"/concepts/abi","content":"ABI In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user. In the context of Polywrap, an ABI refers to the interface a Wrap provides. It defines invokable methods and types found within the Wrap. The Wrap Manifest file (wrap.info) contains, among other things, the Wrap's ABI, which comes as a msgpack-encoded schema of the Wrap.","keywords":""},{"title":"Client","type":0,"sectionRef":"#","url":"/concepts/client","content":"Client A Client is any library that supports to the WRAP Standard. Essentially, any library that can resolve and invoke Wraps is a Client. The Polywrap Foundation maintains a number of WRAP-compatible clients, most notably: Polywrap JS ClientPolywrap Python ClientPolywrap Rust Client Other WRAP-compatible clients: Polywrap Go Client More clients are in development, such as a Polywrap Swift Client (more soon).","keywords":""},{"title":"Envs","type":0,"sectionRef":"#","url":"/concepts/envs","content":"Envs Envs or &quot;Environment Variables&quot; are WRAP URI-mapped objects containing settings that are passed into a Wrap with the corresponding URI. For example, if we have the following Env: { &quot;wrap://ens/hello.world.eth&quot;: { foo: &quot;bar&quot; } } If we were to invoke the Wrap under wrap://ens/hello.world.eth, it would have a globally-available Env object, whose value would be { foo: &quot;bar&quot; }. It is up to the Wrap developer to decide on how to use the available Env object. The Wrap developer can also declare an Env type as part of their Schema, thus communicating to outside developers the structure of the object used for configuring of their Wraps.","keywords":""},{"title":"Invoke","type":0,"sectionRef":"#","url":"/concepts/invoke","content":"Invoke The term &quot;invoke&quot; (or &quot;invocation&quot;) refers to the act of executing a method exposed by a Wrap. This can be done by using a client library that supports the WRAP Standard. Essentially, &quot;Invoke&quot; refers to any call to a method exposed by a Wrap, be it a WASM Wrap, a Plugin Wrap or an Interface Wrap, by a WRAP-compliant client such as the Polywrap Client. Any WRAP-compatible client can perform an Invocation with the following information: the WRAP URI of the Wrap being invokedthe name of the method being invokedthe method arguments For more information, refer to the Invocation standard.","keywords":""},{"title":"Interface Wraps","type":0,"sectionRef":"#","url":"/concepts/interface-wraps","content":"Interface Wraps An Interface Wrap (or Wrap Interface), unlike a WASM Wrap, consists only of an ABI. Wrap Interfaces are still Wraps in the sense that they have are identified by a URI. Consisting only of an ABI, an Interface Wrap cannot be invoked. Instead, it is used as an interface that can be implemented by multiple different Wraps. These Wraps can then be registered within the Client as Interface Implementations. During Invocation, you can invoke the method of an Interface, and if there is an Interface Implementation for the URI, the Wrap implementing the interface will be resolved during URI resolution and the implementing Wrap's method will be invoked. This is mostly used to ensure that, accross different Clients, their Plugin Wraps adhere to the same Interface Wraps. For example, all http Plugins need to have get and post methods with specific signatures and clearly defined Request and Response type structures.","keywords":""},{"title":"Plugin Wraps","type":0,"sectionRef":"#","url":"/concepts/plugin-wraps","content":"Plugin Wraps Polywrap Plugins, or &quot;Plugin Wraps&quot;, enable existing SDKs implemented in the client's language (e.g. JavaScript) to be queried as if they were WASM Wraps. Plugins can be used to enable any native client functionality that cannot be implemented in WebAssembly, such as sending HTTP requests, or signing blockchain transactions with a private key. If you want to build your own Plugins, you can follow the Plugin an existing SDK guide.","keywords":""},{"title":"WASM","type":0,"sectionRef":"#","url":"/concepts/wasm","content":"WASM WASM (WebAssembly) is a binary instruction format designed to provide a portable and efficient target for the compilation of high-level programming languages such as C, C++, Rust, and others. It is a low-level, virtual machine-based format that is designed to be executed in web browsers, but can also be used in other contexts. WASM allows web developers to write web applications in languages other than JavaScript, while still being able to execute them in the browser. This provides a number of benefits, including better performance, improved security, and the ability to reuse existing code. In the context of Polywrap, WASM is used as the underlying technology to provide a secure, portable and efficient way to run Wraps. Polywrap loads and executs Wraps written in WASM, providing a sandboxed environment that ensures that the Wraps cannot interfere with the host application or other Wraps.","keywords":""},{"title":"WASM Wraps","type":0,"sectionRef":"#","url":"/concepts/wasm-wraps","content":"WASM Wraps WASM Wraps are at the core of Polywrap - they are the portable, executable modules that can be called by any client that implements the WRAP Standard. They are WASM modules accompanied by a manifest file which describes said module. A Polywrap Wasm &quot;Wrap&quot; consists of at least the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions) - wrap.wasmA Wrap Manifest file that orchestrates the wrapper, and provides types and parameters for the module functions (it's ABI) - wrap.info Additional files can be present in a Wrap (e.g. metadata files), but these are not required for a Wrap to be valid.","keywords":""},{"title":"URIs","type":0,"sectionRef":"#","url":"/concepts/uris","content":"URIs Deployed wrappers are identified using custom URIs (Uniform Resource Identifier) called WRAP URIs. For example: wrap://ens/api.helloworld.polywrap.eth WRAP URIs follow the WRAP URI Standard. WRAP URIs have 3 parts: a protocol, an authority, and a path. Scheme​ WRAP URIs use the wrap scheme. Including wrap:// in your URI is optional in practice. Authority​ The Authority is used to denote which underlying protocol/standard the URI is part of. Usually, during URI resolution, the Polywrap Client will have at least one URI Resolver for each Authority used. For example: ens/ for resolving ENS domainsipfs/ for resolving IPFS contentfs/ for resolving content on the local filesystemhttp/ for resolving content via HTTP Path​ This is simply everything that comes after the Authority, and defines the unique resource we are trying to resolve. For example: api.domain.eth for an ENS domainQmaLbZnnnHbcRRo3wNBQ2MhugmBGL9R2YYeBvj6Nk2QumP for an IPFS file/directory./build for a local directoryexample.com/my-wrapper.wasm for a Wrap downloadable over HTTP tip ens/ and ipfs/ URI resolution is supported in all Polywrap clients by default. Adding custom URI resolvers is possible. More documentation on how to do this will be released soon.","keywords":""},{"title":"WRAP Standard","type":0,"sectionRef":"#","url":"/concepts/wrap-standard","content":"WRAP Standard The Polywrap Foundation has created and actively maintains a series of standards that all WRAP-compatible clients must adhere to. With Polywrap being an early-stage project, these standards are subject to change, but any change should be non-breaking and purely additive in nature. Read more about the WRAP Standard on its Github repository.","keywords":""},{"title":"Uniswap v3 Polywrap Documentation","type":0,"sectionRef":"#","url":"/demos/uniswapv3/intro","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#overview","content":"Welcome to the Uniswap v3 Polywrap documentation! The Uniswap Wasm wrapper is written in AssemblyScript, and like the official Uniswap SDK, it has a robust test suite and performs arbitrary precision arithmetic. The Uniswap Polywrap wrapper business logic will be deployed on a decentralized endpoint, like IPFS. Our first Polywrap client is for JavaScript(@polywrap/client-js) and it can run in any environment that can execute JavaScript. We also have a working Rust implementation. In the future, we'll have Polywrap clients for other environments (Python, Go, and more). Developers integrating the Uniswap Wasm wrapper into their app would use client invocations to execute functions provided by the Uniswap wrapper. This documentation shows you which functions are made available by the Uniswap wrapper and how to use them. "},{"title":"Uniswap wrapper vs. Existing SDK​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#uniswap-wrapper-vs-existing-sdk","content":"The Uniswap wrapper aims to be a substantial improvement over Uniswap v3’s existing SDK. While the official SDK bundles all classes (e.g. Trade), necessary data fields, and helper functions into the application, the Uniswap wrapper does not. Instead, all business logic is deployed on a decentralized endpoint, like IPFS, and is downloaded at runtime when the client application launches. You can learn more about the benefits of using Polywrap here. "},{"title":"Usage​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#usage","content":"We've created an interactive tutorial that can help you get started using the Uniswap wrapper here. In general, to use any Polywrap in your application, all you need is the Polywrap Client. npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js and browser applications. Then, initialize the client. import { Web3ApiClient } from '@polywrap/client-js'; const client = new Web3ApiClient();  Now, you're able to send queries to the Uniswap v3 wrapper! // You can use the familiar GraphQL Query syntax const tokenEqualsQuery: QueryApiResult = client.query(&lt;{ tokenEquals: boolean }&gt;{ uri: 'ens/v3.uniswap.web3api.eth', query: `{ tokenEquals( tokenA: ${tokenA} tokenB: ${tokenB} ) }`, }); const tokenEquals: boolean | undefined = tokenEqualsQuery.data?.tokenEquals; // Or the alternative Invoke syntax const routerQuery: InvokeApiResult&lt;MethodParameters&gt; = await client.invoke&lt;MethodParameters&gt;({ uri: ensUri, module: &quot;query&quot;, method: &quot;swapCallParameters&quot;, input: { trades: bestTrades, options: { slippageTolerance: &quot;0.01&quot;, recipient: recipient, deadline: &quot;123&quot;, } } }); const swapCallParameters: MethodParameters | undefined = routerQuery.data;  Take a look at more sophisticated tooling, such as our useWeb3ApiQuery hook, in our Create a JS App guide. "},{"title":"Code​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#code","content":"The Pre-alpha source code is available on GitHub. "},{"title":"Wraps","type":0,"sectionRef":"#","url":"/concepts/wraps","content":"Wraps Wraps, in a broad sense, are modules uniquely identifiable by a WRAP URI. Using a WRAP-compatible Client, a user can invoke any method a Wrap exposes. Wraps come in three forms: WASM WrapsInterface WrapsPlugin Wraps","keywords":""},{"title":"Deploy Pool","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/deploy","content":"","keywords":""},{"title":"deployPool​","type":1,"pageTitle":"Deploy Pool","url":"/demos/uniswapv3/mutations/deploy#deploypool","content":"Deploy a pool contract on-chain deployPool( pool: Pool! # A representation of the pool to deploy gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"deployPoolFromTokens​","type":1,"pageTitle":"Deploy Pool","url":"/demos/uniswapv3/mutations/deploy#deploypoolfromtokens","content":"Deploy a pool contract on chain for the given tokens and fee amount deployPoolFromTokens( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Swap","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/swap","content":"","keywords":""},{"title":"execSwap​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#execswap","content":"Perform an on-chain swap with one or more trades in a single transaction execSwap( trades: Trade[]! # Trades to encode into calldata swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"swap​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#swap","content":"Perform an on-chain swap within a single pool by using token and fee amount information to find the correct pool swap( inToken: Token! # Input token of the pool outToken: Token! # Output token of the pool fee: FeeAmount! # Fee amount of the pool being used for the swap amount: BigInt! # Amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"swapWithPool​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#swapwithpool","content":"Perform an on-chain swap using a single pool at provided address; requires ERC20-compliant input and output (i.e. no Ether) swapWithPool( address: String! # Ethereum address of the pool used for the swap amount: TokenAmount! # Token amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Call","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/call","content":"","keywords":""},{"title":"approve​","type":1,"pageTitle":"Call","url":"/demos/uniswapv3/mutations/call#approve","content":"Call the approve(...) function of an ERC20 token contract on-chain, allowing the Uniswap router contract to transfer tokens approve( token: Token! # Token for which to approve the Uniswap router contract to transfer amount: BigInt # The amount to approve for transfer; defaults to maximum amount if null gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"execCall​","type":1,"pageTitle":"Call","url":"/demos/uniswapv3/mutations/call#execcall","content":"Send an Ethereum transaction to the given address execCall( parameters: MethodParameters! # Transaction calldata and Ether value address: String! # Address of the target Ethereum contract chainId: ChainId! # Id of the chain on which to execute the transaction gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Constants","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/constants","content":"","keywords":""},{"title":"FACTORY_ADDRESS​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#factory_address","content":"The address of Uniswap's pool factory contract FACTORY_ADDRESS: String!  "},{"title":"POOL_INIT_CODE_HASH​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash","content":"POOL_INIT_CODE_HASH: String!  "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash_optimism","content":"POOL_INIT_CODE_HASH_OPTIMISM: String!  "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM_KOVAN​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash_optimism_kovan","content":"A historical artifact due to small compiler mismatch POOL_INIT_CODE_HASH_OPTIMISM_KOVAN: String!  "},{"title":"MIN_TICK​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#min_tick","content":"Smallest valid tick index in a pool MIN_TICK: Int32!  "},{"title":"MAX_TICK​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#max_tick","content":"Largest valid tick index in a pool MAX_TICK: Int32!  "},{"title":"MIN_SQRT_RATIO​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#min_sqrt_ratio","content":"Smallest valid sqrtRatioX96 in a pool MIN_SQRT_RATIO: BigInt!  "},{"title":"MAX_SQRT_RATIO​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#max_sqrt_ratio","content":"Largest valid sqrtRatioX96 in a pool MAX_SQRT_RATIO: BigInt!  "},{"title":"Enum Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/enumUtils","content":"","keywords":""},{"title":"feeAmountToTickSpacing​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#feeamounttotickspacing","content":"Returns the tick spacing associated with a FeeAmount enum value feeAmountToTickSpacing( feeAmount: FeeAmount! ): Int32!  "},{"title":"getFeeAmount​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#getfeeamount","content":"Returns the fee (in one-hundred-thousandths of a percent) associated with a FeeAmount enum value getFeeAmount( feeAmount: FeeAmount! ): UInt32!  "},{"title":"getPermitV​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#getpermitv","content":"Returns v value associated with a PermitV enum value getPermitV( permitV: PermitV! ): Int32!  "},{"title":"Encode Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/encodeUtils","content":"","keywords":""},{"title":"toHex​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#tohex","content":"Converts a big int to a hex string toHex( value: BigInt! ): String!  "},{"title":"encodeRouteToPath​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encoderoutetopath","content":"Converts a route to a hex encoded path encodeRouteToPath( route: Route! # The v3 path to convert to an encoded path exactOutput: Boolean! # Whether the route should be encoded in reverse, for making exact output swaps ): String!  "},{"title":"encodePermit​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodepermit","content":"Encodes arguments and returns transaction calldata to call selfPermit or selfPermitAllowed on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodePermit( token: Token! options: PermitOptions! ): String!  "},{"title":"encodeUnwrapWETH9​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodeunwrapweth9","content":"Encodes arguments and returns transaction calldata to call unwrapWETH9 or unwrapWETH9WithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeUnwrapWETH9( amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String!  "},{"title":"encodeSweepToken​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodesweeptoken","content":"Encodes arguments and returns transaction calldata to call sweepToken or sweepTokenWithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeSweepToken( token: Token! amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String!  "},{"title":"encodeRefundETH​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encoderefundeth","content":"Encodes arguments and returns transaction calldata to call refundEth on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeRefundETH: String!  "},{"title":"encodeMulticall​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodemulticall","content":"Encodes multiple calldatas into a single calldata for making multiple calls in one transaction using a contract implementing the necessary interface, such as an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeMulticall( calldatas: String[]! ): String!  "},{"title":"Fetch","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/fetch","content":"","keywords":""},{"title":"fetchToken​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchtoken","content":"Returns token object constructed from the on-chain token contract at the given address fetchToken( address: String! # The Ethereum address of token's ERC20 contract chainId: ChainId! # The id of the chain to be queried ): Token!  "},{"title":"fetchPoolFromTokens​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchpoolfromtokens","content":"Returns pool object constructed from the on-chain pool contract associated with the tokens and fee amount fetchPoolFromTokens( tokenA: Token! # A token in the pool tokenB: Token! # The other token in the pool fee: FeeAmount! # The pool's fee amount fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool!  "},{"title":"fetchPoolFromAddress​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchpoolfromaddress","content":"Returns pool object constructed from the on-chain pool contract at the given address fetchPoolFromAddress( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool!  "},{"title":"fetchTickList​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchticklist","content":"Returns array of ticks from the on-chain pool contract at the given address fetchTickList( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried ): Tick[]!  "},{"title":"Math Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/mathUtils","content":"","keywords":""},{"title":"mostSignificantBit​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#mostsignificantbit","content":"Returns the most significant bit of a positive integer, starting with first bit = 0 mostSignificantBit( x: BigInt! ): UInt32!  "},{"title":"encodeSqrtRatioX96​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#encodesqrtratiox96","content":"Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0 encodeSqrtRatioX96( amount1: BigInt! # The numerator amount i.e., the amount of token1 amount0: BigInt! # The denominator amount i.e., the amount of token0 ): BigInt!  "},{"title":"mulDivRoundingUp​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#muldivroundingup","content":"Returns (a * b) / denominator mulDivRoundingUp( a: BigInt! b: BigInt! denominator: BigInt! ): BigInt!  "},{"title":"addDelta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#adddelta","content":"Returns x + y addDelta( x: BigInt! y: BigInt! ): BigInt!  "},{"title":"getAmount0Delta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getamount0delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount0Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt!  "},{"title":"getAmount1Delta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getamount1delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount1Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt!  "},{"title":"getNextSqrtPriceFromInput​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getnextsqrtpricefrominput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromInput( sqrtPX96: BigInt! liquidity: BigInt! amountIn: BigInt! zeroForOne: Boolean! ): BigInt!  "},{"title":"getNextSqrtPriceFromOutput​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getnextsqrtpricefromoutput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromOutput( sqrtPX96: BigInt! liquidity: BigInt! amountOut: BigInt! zeroForOne: Boolean! ): BigInt!  "},{"title":"Nonfungible Position Manager","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/nfpm","content":"","keywords":""},{"title":"createCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#createcallparameters","content":"Returns calldata for creating a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol createCallParameters( pool: Pool! # An off-chain representation of the pool to create on-chain ): MethodParameters!  "},{"title":"addCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#addcallparameters","content":"Returns calldata for minting or adding liquidity to a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol. Optionally creates the pool if it doesn't exist. addCallParameters( position: Position! # Liquidity position to add to pool options: AddLiquidityOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"collectCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#collectcallparameters","content":"Returns calldata for collecting liquidity provider rewards using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol collectCallParameters( options: CollectOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"removeCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#removecallparameters","content":"Returns calldata for completely or partially exiting a liquidity position using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol removeCallParameters( position: Position! # The position to exit options: RemoveLiquidityOptions! # Additional information necessary for generating the calldata ): MethodParameters!  "},{"title":"safeTransferFromParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#safetransferfromparameters","content":"Returns calldata for safely transferring an NFT using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol safeTransferFromParameters( options: SafeTransferOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"Pool Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/poolUtils","content":"","keywords":""},{"title":"computePoolAddress​","type":1,"pageTitle":"Pool Utilities","url":"/demos/uniswapv3/queries/poolUtils#computepooladdress","content":"Computes a pool address computePoolAddress( factoryAddress: String! # The Uniswap V3 factory address tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String!  "},{"title":"Pool","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/pool","content":"","keywords":""},{"title":"createPool​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#createpool","content":"Constructs and validates a Pool createPool( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # Fee amount for swaps through the pool sqrtRatioX96: BigInt! # Encoded representation of current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # Current pool tick ticks: Tick[] # A validated list of all ticks in the pool ): Pool!  "},{"title":"getPoolAddress​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooladdress","content":"Returns the Ethereum address of the Pool contract getPoolAddress( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String!  "},{"title":"poolInvolvesToken​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolinvolvestoken","content":"Returns true if the token is in the Pool (i.e. pool.token0 or pool.token1) poolInvolvesToken( pool: Pool! token: Token! ): Boolean!  "},{"title":"poolToken0Price​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#pooltoken0price","content":"Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 poolToken0Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price!  "},{"title":"poolToken1Price​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#pooltoken1price","content":"Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 poolToken1Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price!  "},{"title":"poolPriceOf​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolpriceof","content":"Returns the price of the given token in terms of the other token in the pool poolPriceOf( pool: Pool! # Pool that involves the token token: Token! # The token to return the price of ): Price!  "},{"title":"poolChainId​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolchainid","content":"Returns the chain ID of the tokens in the pool poolChainId( pool: Pool! ): ChainId!  "},{"title":"getPoolOutputAmount​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooloutputamount","content":"Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade getPoolOutputAmount( pool: Pool! # Pool that involves input and output tokens inputAmount: TokenAmount! # The input amount for which to quote the output amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit ): PoolChangeResult!  "},{"title":"getPoolInputAmount​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpoolinputamount","content":"Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade getPoolInputAmount( pool: Pool! # Pool that involves input and output tokens outputAmount: TokenAmount! # The output amount for which to quote the input amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap. ): PoolChangeResult!  "},{"title":"getPoolTickSpacing​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooltickspacing","content":"Returns the tick spacing of ticks in the pool getPoolTickSpacing( pool: Pool! ): Int32!  "},{"title":"Position Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/positionUtils","content":"","keywords":""},{"title":"maxLiquidityForAmounts​","type":1,"pageTitle":"Position Utilities","url":"/demos/uniswapv3/queries/positionUtils#maxliquidityforamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries. maxLiquidityForAmounts( sqrtRatioCurrentX96: BigInt! # Encoded representation of the current price sqrtRatioAX96: BigInt! # Encoded representation of the price at lower tick boundary sqrtRatioBX96: BigInt! # Encoded representation of the price at upper tick boundary amount0: BigInt! # Amount for the first token of the pool amount1: BigInt! # Amount for the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): BigInt!  "},{"title":"Quoter","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/quoter","content":"","keywords":""},{"title":"quoteCallParameters​","type":1,"pageTitle":"Quoter","url":"/demos/uniswapv3/queries/quoter#quotecallparameters","content":"Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters. quoteCallParameters( route: Route! # The swap route, a list of pools through which a swap can occur amount: TokenAmount! # The amount of the quote, either an amount in, or an amount out tradeType: TradeType! # The trade type, either exact input or exact output options: QuoteOptions # Optional configuration ): MethodParameters!  "},{"title":"Route","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/route","content":"","keywords":""},{"title":"createRoute​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#createroute","content":"Constructs and validates a Route createRoute( pools: Pool[]! # The ordered list of pools from which to construct the route inToken: Token! # The input token outToken: Token! # The output token ): Route!  "},{"title":"routeChainId​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#routechainid","content":"Returns the chain id of the tokens in the route routeChainId( route: Route! ): ChainId!  "},{"title":"routeMidPrice​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#routemidprice","content":"Returns the mid price of the route routeMidPrice( pools: Pool[]! # The ordered list of pools from which to calculate the mid price inToken: Token! # The input token outToken: Token! # The output token ): Price!  "},{"title":"Position","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/position","content":"","keywords":""},{"title":"createPosition​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createposition","content":"Constructs and validates a liquidity Position for a given Pool with the given liquidity createPosition( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): Position!  "},{"title":"createPositionFromAmounts​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries createPositionFromAmounts( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The amount of the first token of the pool amount1: BigInt! # The amount of the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position!  "},{"title":"createPositionFromAmount0​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamount0","content":"Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1 createPositionFromAmount0( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The desired amount of token0 useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position!  "},{"title":"createPositionFromAmount1​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamount1","content":"Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0. Always uses full precision. createPositionFromAmount1( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount1: BigInt! # The desired amount of token1 ): Position!  "},{"title":"positionToken0PriceLower​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positiontoken0pricelower","content":"Returns the price of token0 at the lower tick positionToken0PriceLower( pool: Pool! # The pool for which the liquidity is assigned tickLower: Int32! # The lower tick of the position ): Price!  "},{"title":"positionToken0PriceUpper​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positiontoken0priceupper","content":"Returns the price of token0 at the upper tick positionToken0PriceUpper( pool: Pool! # The pool for which the liquidity is assigned tickUpper: Int32! # The upper tick of the position ): Price!  "},{"title":"positionAmount0​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positionamount0","content":"Returns the amount of token0 that this position's liquidity could be burned for at the current pool price positionAmount0( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount!  "},{"title":"positionAmount1​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positionamount1","content":"Returns the amount of token1 that this position's liquidity could be burned for at the current pool price positionAmount1( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount!  "},{"title":"mintAmounts​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#mintamounts","content":"Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool mintAmounts( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): MintAmounts!  "},{"title":"mintAmountsWithSlippage​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#mintamountswithslippage","content":"Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance mintAmountsWithSlippage( position: Position! # Position for which to calculate mint amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts!  "},{"title":"burnAmountsWithSlippage​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#burnamountswithslippage","content":"Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance burnAmountsWithSlippage( position: Position! # Position for which to calculate burn amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts!  "},{"title":"Router","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/router","content":"","keywords":""},{"title":"swapCallParameters​","type":1,"pageTitle":"Router","url":"/demos/uniswapv3/queries/router#swapcallparameters","content":"Encodes arguments and returns transaction calldata to make a swap on an Uniswap's V3 Router contract swapCallParameters( trades: Trade[]! # Trades for which to produce call parameters options: SwapOptions! # Configuration options for the swap call ): MethodParameters!  "},{"title":"Staker","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/staker","content":"","keywords":""},{"title":"collectRewards​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#collectrewards","content":"Returns transaction calldata for calling 'unstakeToken', 'claimReward', and 'stakeToken' in a single transaction on Uniswap's Staker contract. Note: A tokenId can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake. collectRewards( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys that `tokenId` is staked in; claims rewards for each program. options: ClaimOptions! # ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once. ): MethodParameters!  "},{"title":"withdrawToken​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#withdrawtoken","content":"Returns transaction calldata for unstaking, claiming, and withdrawing in a single transaction on Uniswap's Staker contract. withdrawToken( incentiveKeys: IncentiveKey[]! # A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in. options: FullWithdrawOptions! # Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`. ): MethodParameters!  "},{"title":"encodeDeposit​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#encodedeposit","content":"Returns an encoded IncentiveKey as a string encodeDeposit( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom` ): String!  "},{"title":"TickList Data Provider","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/tickProvider","content":"","keywords":""},{"title":"validateTickList​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#validateticklist","content":"Validates a tick list, returning true of the tick list is valid. Throws an exception if the tick list is not valid. validateTickList( ticks: Tick[]! # A list of ticks to validate tickSpacing: Int32! # The tick spacing of the list ): Boolean!  "},{"title":"getTick​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#gettick","content":"Returns the tick at the requested index getTick( tickDataProvider: Tick[]! # A list of ticks to search tickIndex: Int32! # The tick index of the requested tick ): Tick!  "},{"title":"nextInitializedTickWithinOneWord​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#nextinitializedtickwithinoneword","content":"Returns next initialized tick, or max or min tick. Returns true if a tick is found at index. nextInitializedTickWithinOneWord( tickDataProvider: Tick[]! # Tick list to search tick: Int32! # Current tick index lte: Boolean! # True of returned tick index should be less than or equal to current tick index tickSpacing: Int32! # Tick spacing of tick list ): NextTickResult!  "},{"title":"Tick Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/tickUtils","content":"","keywords":""},{"title":"nearestUsableTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#nearestusabletick","content":"Returns the closest tick that is nearest a given tick and usable for the given tick spacing nearestUsableTick( tick: Int32! # The target tick tickSpacing: Int32! # The spacing of the pool ): Int32!  "},{"title":"tickToPrice​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#ticktoprice","content":"Returns a price object corresponding to the input tick and the base/quote token. Inputs must be tokens because the address order is used to interpret the price represented by the tick. tickToPrice( baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price tick: Int32! # The tick for which to return the price ): Price!  "},{"title":"priceToClosestTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#pricetoclosesttick","content":"Returns the first tick for which the given price is greater than or equal to the tick price. priceToClosestTick( price: Price! # Price for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price. Note that a string price is not used as input here, so the 'price' property of the Price type can have any value without affecting the results. ): Int32!  "},{"title":"tickIsBelowSmallest​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#tickisbelowsmallest","content":"Returns true if the tick index is smaller than all tick indices in the list tickIsBelowSmallest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean!  "},{"title":"tickIsAtOrAboveLargest​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#tickisatorabovelargest","content":"Returns true if the tick index is greater than or equal to all tick indices in the list tickIsAtOrAboveLargest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean!  "},{"title":"nextInitializedTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#nextinitializedtick","content":"Returns next initialized tick following the input tick nextInitializedTick( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index lte: Boolean! # If true, searches list for next initialized tick that has index less than or equal to the input tick index ): Tick!  "},{"title":"tickListIsSorted​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#ticklistissorted","content":"Returns true if a tick list is sorted by tick index tickListIsSorted( ticks: Tick[]! # The tick list ): Boolean!  "},{"title":"getSqrtRatioAtTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#getsqrtratioattick","content":"Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick getSqrtRatioAtTick( tick: Int32! # The tick for which to compute the sqrt ratio ): BigInt!  "},{"title":"getTickAtSqrtRatio​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#gettickatsqrtratio","content":"Returns the tick corresponding to a given sqrt ratio, such that getSqrtRatioAtTick(tick) &lt;= sqrtRatioX96 and getSqrtRatioAtTick(tick + 1) &gt; sqrtRatioX96 getTickAtSqrtRatio( sqrtRatioX96: BigInt! # The sqrt ratio as a Q64.96 for which to compute the tick ): Int32!  "},{"title":"Token","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/token","content":"","keywords":""},{"title":"currencyEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#currencyequals","content":"Returns true if the currencies are equivalent, false otherwise currencyEquals( currencyA: Currency! currencyB: Currency! ): Boolean!  "},{"title":"tokenEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokenequals","content":"Returns true if the tokens are equivalent, false otherwise tokenEquals( tokenA: Token! tokenB: Token! ): Boolean!  "},{"title":"tokenAmountEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokenamountequals","content":"Returns true if the token amounts are equivalent, false otherwise tokenAmountEquals( tokenAmountA: TokenAmount! tokenAmountB: TokenAmount! ): Boolean!  "},{"title":"tokenSortsBefore​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokensortsbefore","content":"Returns true if the address of tokenA would precede the address of token B when sorted alphabetically tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean!  "},{"title":"getEther​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#getether","content":"Returns a native token (e.g. Ether) on the specified chain getNative( chainId: ChainId! ): Token!  "},{"title":"getWETH​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#getweth","content":"Returns a Wrapped Ether token on the specified chain getWETH( chainId: ChainId! ): Token!  "},{"title":"isNative​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#isnative","content":"Returns true if the token is native (e.g. Ether), false otherwise. A token representing Ether must have an empty string in its address field. isNative( token: Token! ): Boolean!  "},{"title":"wrapToken​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#wraptoken","content":"If the input token is Ether, the return value is Wrapped Ether; otherwise, the return value is the same as the input value. wrapToken( token: Token! ): Token!  "},{"title":"wrapAmount​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#wrapamount","content":"If the input token amount represents an amount of Ether, the return value represents the same amount in Wrapped Ether; otherwise, the return value is the same as the input value. wrapAmount( amount: TokenAmount! ): TokenAmount!  "},{"title":"Trade","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/trade","content":"","keywords":""},{"title":"createTradeExactIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradeexactin","content":"Constructs an exact in trade with the given amount in and route createTradeExactIn( tradeRoute: TradeRoute! # The route of the exact in trade and the amount being passed in ): Trade!  "},{"title":"createTradeExactOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradeexactout","content":"Constructs an exact out trade with the given amount out and route createTradeExactOut( tradeRoute: TradeRoute! # The route of the exact out trade and the amount returned ): Trade!  "},{"title":"createTradeFromRoute​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradefromroute","content":"Constructs a trade by simulating swaps through the given route createTradeFromRoute( tradeRoute: TradeRoute! # The route to swap through and the amount specified, either input or output, depending on the trade type tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade!  "},{"title":"createTradeFromRoutes​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradefromroutes","content":"Constructs a trade by simulating swaps through the given routes createTradeFromRoutes( tradeRoutes: TradeRoute[]! # The routes to swap through and how much of the amount should be routed through each tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade!  "},{"title":"createUncheckedTrade​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createuncheckedtrade","content":"Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTrade( swap: TradeSwap! # The route to swap through, the amount being passed in, and the amount returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade!  "},{"title":"createUncheckedTradeWithMultipleRoutes​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createuncheckedtradewithmultipleroutes","content":"Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTradeWithMultipleRoutes( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade!  "},{"title":"tradeInputAmount​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeinputamount","content":"The input amount for the trade assuming no slippage tradeInputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount!  "},{"title":"tradeOutputAmount​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeoutputamount","content":"The output amount for the trade assuming no slippage tradeOutputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount!  "},{"title":"tradeExecutionPrice​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeexecutionprice","content":"The price expressed in terms of output amount/input amount tradeExecutionPrice( inputAmount: TokenAmount! # The trade input amount, e.g. from Trade object or tradeInputAmount(...) outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Price!  "},{"title":"tradePriceImpact​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradepriceimpact","content":"Returns the percent difference between the route's mid price and the price impact tradePriceImpact( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Fraction!  "},{"title":"tradeMinimumAmountOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#trademinimumamountout","content":"Get the minimum amount that must be received from the trade for the given slippage tolerance tradeMinimumAmountOut( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountOut: TokenAmount! # The output amount of the trade, before slippage, e.g. from Trade object or tradeOutputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount!  "},{"title":"tradeMaximumAmountIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#trademaximumamountin","content":"Get the maximum amount in that can be spent via the trade for the given slippage tolerance tradeMaximumAmountIn( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountIn: TokenAmount! # The input amount of the trade, before slippage, e.g. from Trade object or tradeInputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount!  "},{"title":"tradeWorstExecutionPrice​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeworstexecutionprice","content":"Return the execution price after accounting for slippage tolerance tradeWorstExecutionPrice( trade: Trade! # Trade for which to calculate execution price slippageTolerance: String! # The allowed tolerated slippage ): Price!  "},{"title":"bestTradeExactIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#besttradeexactin","content":"Given a list of pools, and a fixed amount in, returns the top maxNumResults trades that go from an input token amount to an output token, making at most maxHops hops. Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactIn( pools: Pool[]! # The pools to consider in finding the best trade amountIn: TokenAmount! # Exact amount of input currency to spend tokenOut: Token! # The desired currency out options: BestTradeOptions # Options used when determining the best trade ): Trade[]!  "},{"title":"bestTradeExactOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#besttradeexactout","content":"similar to bestTradeExactIn(...) but instead targets a fixed output amount given a list of pools, and a fixed amount out, returns the top maxNumResults trades that go from an input token to an output token amount, making at most maxHops hops note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactOut( pools: Pool[]! # The pools to consider in finding the best trade tokenIn: Token! # The currency to spend amountOut: TokenAmount! # The desired currency amount out options: BestTradeOptions # Options used when determining the best trade ): Trade[]!  "},{"title":"Common Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/common-types","content":"","keywords":""},{"title":"BestTradeOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#besttradeoptions","content":"Options used when determining the best trade in bestTradeExactIn(...) and bestTradeExactOut(...) type BestTradeOptions { maxNumResults: UInt32 # Maximum number of results to return maxHops: UInt32 # Maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool }  "},{"title":"Currency​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#currency","content":"Describes a token type Currency { decimals: UInt8! # Token decimals symbol: String # Token symbol name: String # Token name }  "},{"title":"FeeOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#feeoptions","content":"Fee configuration for encodeUnwrapWETH9(...) and encodeSweepToken(...) type FeeOptions { fee: String! # The percent of the output that will be taken as a fee. recipient: String! # The recipient of the fee. }  "},{"title":"Fraction​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#fraction","content":"Represents fraction, typically a percent. type Fraction { numerator: BigInt! # Numerator of fraction denominator: BigInt! # Denominator of fraction quotient: String! # A decimal string representation of the fraction }  "},{"title":"MethodParameters​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#methodparameters","content":"Transaction calldata and an ether value to be sent with the transaction type MethodParameters { calldata: String! # The hex encoded calldata to perform the given operation value: String! # The amount of ether (wei) to send in hex. }  "},{"title":"MintAmounts​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#mintamounts","content":"The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool type MintAmounts { amount0: BigInt! # Amount of the first token in the pool amount1: BigInt! # Amount of the second token in the pool }  "},{"title":"PermitOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#permitoptions","content":"Parameters for a permit allowing the transfer of tokens. Either amount and deadline OR nonce and expiry are required. type PermitOptions { v: PermitV! r: String! s: String! amount: BigInt deadline: BigInt nonce: BigInt expiry: BigInt }  "},{"title":"Pool​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#pool","content":"A liquidity pool involving two tokens which can be exchanged for a price determined by a price curve and market dynamics type Pool { token0: Token! # The first token of the pool token1: Token! # The second token of the pool fee: FeeAmount! # The fee amount liquidity providers receive as a share of swaps made in the pool sqrtRatioX96: BigInt! # An encoded representation of the current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # The current tick tickDataProvider: Tick[]! # A list of all ticks in the pool token0Price: Price! # The current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 token1Price: Price! # The current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 }  "},{"title":"Position​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#position","content":"A liquidity position between two ticks in a pool type Position { pool: Pool! # The pool on which the position is held tickLower: Int32! # The lower tick, marking the lower boundary of the position tickUpper: Int32! # The upper tick, marking the upper boundary of the position liquidity: BigInt! # The maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries token0Amount: TokenAmount! # The amount in this position of the first token of the pool token1Amount: TokenAmount! # The amount in this position of the second token of the pool mintAmounts: MintAmounts! # The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool token0PriceLower: Price! # The price of token0 at the lower tick token0PriceUpper: Price! # The price of token0 at the upper tick }  "},{"title":"Price​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#price","content":"Represents price of a token in terms of another token. When used as a function argument, the 'price' property is ignored. type Price { baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price denominator: BigInt! # Amount of base token used to calculate price numerator: BigInt! # Amount of quote token used to calculate price price: String! # A decimal string representation of the price }  "},{"title":"Route​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#route","content":"An ordered path of pools through which a swap can occur type Route { pools: Pool[]! # A list of pools, wherein each pool in the list has a token in common with its adjacent pool(s) path: Token[]! # The path of tokens that are swapped through the pools input: Token! # The input token, where the route begins output: Token! # The output token, where the route ends midPrice: Price! # The mid price of the output token, in terms of the input token, for this route }  "},{"title":"SwapOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#swapoptions","content":"Configuration for creating swap transaction calldata using swapCallParameters(...) type SwapOptions { slippageTolerance: String! # How much the execution price is allowed to move unfavorably from the trade execution price. recipient: String! # The account that should receive the output. deadline: BigInt! # When the transaction expires, in epoch seconds. inputTokenPermit: PermitOptions # The optional permit parameters for spending the input. sqrtPriceLimitX96: BigInt # The optional price limit for the trade. fee: FeeOptions # Optional information for taking a fee on output. }  "},{"title":"Tick​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tick","content":"A pool tick marks a section of the price curve. A liquidity provider may hold a position on a tick, rather than the full curve. type Tick { index: Int32! # Tick index liquidityGross: BigInt! # Gross liquidity in Pool at tick position liquidityNet: BigInt! # Net liquidity in Pool at tick position }  "},{"title":"Token​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#token","content":"ERC20-compliant token or Ether type Token { chainId: ChainId! # Id of chain where token exists address: String! # Address of token's ERC20 contract currency: Currency! # Token description }  "},{"title":"TokenAmount​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tokenamount","content":"An amount of a token type TokenAmount { token: Token! # Token amount: BigInt! # Raw amount of the token, not adjusted for the token's decimals }  "},{"title":"Trade​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#trade","content":"A trade contains the information necessary to create an on-chain exchange of tokens type Trade { swaps: TradeSwap[]! # A list of swaps to be executed atomically, all of which must have the same input and output tokens tradeType: TradeType! # Type of trade, either exact input or exact output inputAmount: TokenAmount! # The total input amount (sum of input amounts in swaps) outputAmount: TokenAmount! # The total output amount (sum of output amounts in swaps) executionPrice: Price! # The price of the trade, in terms of the input token priceImpact: Fraction! # The percent difference between the route's mid price and the price impact }  "},{"title":"TradeSwap​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tradeswap","content":"A route, input, and output amount that compose the core elements of a trade type TradeSwap { route: Route! # The route of the trade inputAmount: TokenAmount! # The amount being passed in outputAmount: TokenAmount! # The amount returned by the trade when executed }  "},{"title":"Enum Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/enum-types","content":"","keywords":""},{"title":"ChainId​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#chainid","content":"Ethereum chain supported by the wrapper enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN OPTIMISM OPTIMISTIC_KOVAN ARBITRUM_ONE ARBITRUM_RINKEBY POLYGON POLYGON_MUMBAI }  "},{"title":"FeeAmount​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#feeamount","content":"Pool swap fee amount enum FeeAmount { LOWEST LOW MEDIUM HIGH }  "},{"title":"PermitV​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#permitv","content":"Valid v value of Permit enum PermitV { v_0 v_1 v_27 v_28 }  "},{"title":"TradeType​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#tradetype","content":"Type of trade, either exact input or exact output enum TradeType { EXACT_INPUT EXACT_OUTPUT }  "},{"title":"Mutation Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/mutation-types","content":"","keywords":""},{"title":"GasOptions​","type":1,"pageTitle":"Mutation Types","url":"/demos/uniswapv3/types/mutation-types#gasoptions","content":"Transaction gas configuration type GasOptions { gasPrice: BigInt # The gas price to set for the transaction gasLimit: BigInt # The gas limit to set for the transaction }  "},{"title":"Query Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/query-types","content":"","keywords":""},{"title":"AddLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#addliquidityoptions","content":"Union of MintOptions and IncreaseOptions; one of either recipient or tokenId is required. type AddLiquidityOptions { recipient: String # The account that should receive the minted NFT. createPool: Boolean # Creates pool if not initialized before mint. Ignored if recipient is not null. tokenId: BigInt # Indicates the ID of the position to increase liquidity for. Ignored if recipient is not null. slippageTolerance: String! deadline: BigInt! useNative: Token token0Permit: PermitOptions token1Permit: PermitOptions }  "},{"title":"ClaimOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#claimoptions","content":"Options to specify when claiming rewards. type ClaimOptions { tokenId: BigInt! # The id of the NFT recipient: String! # Address to send rewards to. amount: BigInt # The amount of `rewardToken` to claim. 0 claims all. }  "},{"title":"CollectOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#collectoptions","content":"Options to specify when calling collectCallParameters(...) to collect liquidity provider rewards or removeCallParameters(...) to exit a liquidity position. type CollectOptions { tokenId: BigInt! # Indicates the ID of the position to collect for. Ignored when CollectOptions is as property of RemoveLiquidityOptions for use in removeCallParameters(...). expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned recipient: String! # The account that should receive the tokens. }  "},{"title":"CommonAddLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#commonaddliquidityoptions","content":"Options for producing the calldata to add liquidity. type CommonAddLiquidityOptions { slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false token0Permit: PermitOptions # The optional permit parameters for spending token0 token1Permit: PermitOptions # The optional permit parameters for spending token1 }  "},{"title":"FullWithdrawOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#fullwithdrawoptions","content":"Options to specify when withdrawing tokens type FullWithdrawOptions { owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw. data: String # Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner. tokenId: BigInt! recipient: String! amount: BigInt }  "},{"title":"IncentiveKey​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#incentivekey","content":"Represents a unique staking program. type IncentiveKey { rewardToken: Token! # The token rewarded for participating in the staking program. pool: Pool! # The pool that the staked positions must provide in. startTime: BigInt! # The time when the incentive program begins. endTime: BigInt! # The time that the incentive program ends. refundee: String! # The address which receives any remaining reward tokens at `endTime`. }  "},{"title":"NextTickResult​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#nexttickresult","content":"Return value of nextInitializedTickWithinOneWord(...) type NextTickResult { index: Int32! # Tick index of returned next tick found: Boolean! # True if the returned tick index represents an initialized tick, or false if max or min tick are returned instead }  "},{"title":"NFTPermitOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#nftpermitoptions","content":"Permission parameters for NFT transfers, in case the transaction is being sent by an account that does not own the NFT type NFTPermitOptions { v: PermitV! r: String! s: String! deadline: BigInt! spender: String! }  "},{"title":"PoolChangeResult​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#poolchangeresult","content":"Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...) type PoolChangeResult { amount: TokenAmount! # input or output amount resulting from simulated swap nextPool: Pool! # Pool state after simulated swap }  "},{"title":"QuoteOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#quoteoptions","content":"Optional arguments to send to the quoter. type QuoteOptions { sqrtPriceLimitX96: BigInt # The optional price limit for the trade. }  "},{"title":"RemoveLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#removeliquidityoptions","content":"Options for producing the calldata to exit a position. type RemoveLiquidityOptions { tokenId: BigInt! # The ID of the token to exit liquidityPercentage: String! # The percentage of position liquidity to exit. slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false. permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT collectOptions: CollectOptions! # Parameters to be passed on to collect; tokenId is ignored. }  "},{"title":"SafeTransferOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#safetransferoptions","content":"Options to specify when calling safeTransferFrom(...) to transfer an NFT type SafeTransferOptions { sender: String! # The account sending the NFT. recipient: String! # The account that should receive the NFT. tokenId: BigInt! # The id of the token being sent. data: String # The optional parameter that passes data to the `onERC721Received` call for the staker }  "},{"title":"TradeRoute​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#traderoute","content":"Input used to create a trade type TradeRoute { route: Route! # The route of the trade amount: TokenAmount! # The amount being passed in or out, depending on the trade type }  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/introduction","content":"","keywords":""},{"title":"The problem with current Web3 SDKs​","type":1,"pageTitle":"Introduction","url":"/introduction#the-problem-with-current-web3-sdks","content":"We see traditional SDKs as the primary bottleneck to web3's potential for composable, cross-platform dApps. Web3 promises a new depth of composability in software development. Any application can interact with smart contract protocols like Uniswap or Aave. For web3 developers, software development kits (SDKs) simplify this integration process. However, traditional SDKs come with a number of issues for web3 developers, namely they are: difficult to compose. Due to the lack of SDK standards, the SDK for one web3 protocol may be difficult to mix-and-match with that of another.  not portable. SDKs are language-specific. Today's deployment platforms are more varied than ever (web, mobile, server, etc.). Thus, SDK codebases need to be duplicated and translated for each of these environments, leading to more chances for bugs to appear and higher maintenance costs.  not upgradable. When traditional SDKs undergo a patch update, the entire application needs to be rebuilt and redeployed. "},{"title":"Polywrap: Composable web3 Wrappers​","type":1,"pageTitle":"Introduction","url":"/introduction#polywrap-composable-web3-wrappers","content":"Presenting Polywrap - a framework for building “wrappers”: composable, portable, and dynamically upgradeable SDKs.✨ Polywrap's wrappers offer a much better strategy for code reuse and composability than traditional SDKs. Wrappers are: easily composable. Wrappers are developed in a standardized way, and all dApps powered by the Polywrap client library can communicate with wrappers with a familiar graphQL-esque querying. Standardization means wrappers can be easily composed, resulting in even more sophisticated wrappers.  portable. Wrappers can execute in any host environment that has the Polywrap client installed (web, mobile, IoT, servers, and more). Instead of maintaining multiple language-specific SDKs, web3 dev teams can write their wrappers in one language that works seamlessly across all deployment platforms.  updatable on the fly. Wrappers aren't bundled into applications. Instead, they're fetched at runtime and any patch updates are done on the fly, without the need to rebuild the entire app. "},{"title":"What's inside a Polywrap Wasm Wrap?​","type":1,"pageTitle":"Introduction","url":"/introduction#whats-inside-a-polywrap-wasm-wrap","content":"A Polywrap Wasm &quot;Wrap&quot; consists of the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions)Wrap Manifest file that orchestrates the Wrap, and provides types and parameters for the module functions "},{"title":"Where is it deployed?​","type":1,"pageTitle":"Introduction","url":"/introduction#where-is-it-deployed","content":"We currently support deploying Wraps to decentralized endpoints, Ethereum Name Service (ENS), a decentralized Ethereum-based naming system and InterPlanetary File System (IPFS), a distributed P2P file system. You can see a list of all deployed Wraps here: https://wrappers.io/all "},{"title":"How can apps integrate this deployed Wrap?​","type":1,"pageTitle":"Introduction","url":"/introduction#how-can-apps-integrate-this-deployed-wrap","content":"In a JavaScript application, a developer would first install the Polywrap JavaScript client. At that point, a Polywrap-enabled app will be able to download and use the protocol's functions. These functions are exported from WebAssembly (Wasm) modules, and can be used in any environment that can execute Wasm functions (like your web browser!). tip The Polywrap JavaScript client allows the app to use any deployed Wrap. After instantiating the client, the app can call queries to the Wrap using familiar GraphQL or our streamlined invocation syntax. All that is needed is: The URI specifying the ENS or IPFS resolving to content containing the WrapSpecifying the function and arguments provided by that Wrap For detailed information on how to integrate in apps, take a look at our Quick Start guide. For a guide on how to build your own Polywrap and deploy it for other developers to integrate into their own app, see our Creating a Wasm Wrap guide. "},{"title":"Polywrap CLI","type":0,"sectionRef":"#","url":"/quick-start/polywrap-cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#installation","content":"To install the Polywrap CLI, add the polywrap package as a dev dependency to your project: NPM: npm i --save-dev polywrap  Yarn: yarn add --dev polywrap  You can also install the Polywrap CLI globally: NPM: npm i -g polywrap  Yarn: yarn global add polywrap  "},{"title":"Overview​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#overview","content":"The Polywrap CLI allows us not only to build, test, and deploy Wraps, but also generate types for our applications which use the Polywrap Client. This tutorial assumes that you installed polywrap globally, but you can always prefix the commands with npx or yarn run to run the locally installed version of your Polywrap CLI. You can see all available commands by running: polywrap help  "},{"title":"Create a Polywrap-powered application​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#create-a-polywrap-powered-application","content":"tip If you already have an application you want to add Polywrap to, it is advised that you still follow this guide and transfer/modify the polywrap.yaml and src/schema.graphql files once you're done with this tutorial. The Polywrap CLI can be used to quickly set up a template application. For this tutorial, we will create a sample Node application written in Typescript and use the Polywrap Client to invoke multiple Wraps. To set up a Polywrap-powered application, run: polywrap create app typescript my-application  This uses the create command to set up a template Node application written in Typescript called my-application inside the my-application/ directory. Now we want to navigate into the application folder and install its dependencies. cd my-application yarn  If you take a look at package.json, you'll find the app depends on @polywrap/client-js and has a dev dependency on polywrap, with the addition of minimal dev dependencies that allow us to develop the app using Typescript. Now let's take a look at some of the files Polywrap works with. "},{"title":"The Polywrap Manifest (polywrap.yaml)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#the-polywrap-manifest-polywrapyaml","content":"In order for the Polywrap CLI to know what it's working with, it needs a Polywrap Manifest file to obtain some basic information about your project. This is the polywrap.yaml file. It has a structure similar to this: polywrap.yaml format: 0.3.0 project: name: Sample type: app/typescript source: schema: ./schema.graphql  The format property denotes the version of the Polywrap Manifest format. Under project, you can set the name field to the name of your application, while the type field describes the project type, thus letting the CLI know how to interact with the application code. Under the source section, we have a schema field with a path that leads to a Schema file. In the context of a Polywrap-powered application project, this file defines which Wraps our application imports/uses. This will come in handy later when we'll use the CLI to generate types and code which your app will use. "},{"title":"The Schema File (schema.graphql)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#the-schema-file-schemagraphql","content":"Every Polywrap project has a Schema file - it defines the types found within the project, what Wraps the project imports, and, in the case of a WASM Wrap, the methods that Wrap exposes. In the context of an application project, the Schema file defines which Wraps our application imports and is used by the CLI to generate code with which we can invoke our Wraps in a type-safe manner. Taking a look at the file, we can see two import statements: schema.graphql #import * into Logging from &quot;ens/wraps.eth:logging@1.0.0&quot; #import * into Ethereum from &quot;ens/wraps.eth:ethereum@1.0.0&quot;  An import statement defines which Wraps we are importing, therefore using within our application. Imports are namespaced - the Wrap found under the WRAP URI ens/wraps.eth:logging@1.0.0 is going to be found within the Logging_ namespace. "},{"title":"Generating types (codegen)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#generating-types-codegen","content":"caution While we used Javascript in previous samples, Polywrap is native to Typescript, and all future examples will be written in Typescript. Now that we know how we can &quot;import&quot; Wraps into our application, we can use the codegen command inside the Polywrap CLI to generate types that represent our Wraps which we can use within our application. To generate types, all we need to do is run the codegen command: polywrap codegen  This will generate types inside the src/wrap directory which you will use within your application. "},{"title":"IntelliSense your way to Victory!​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#intellisense-your-way-to-victory","content":"Now that we have our types generated, we can take a look at our sample application's src/index.ts file. Let's first take a look at some of the imports: import { Logging_Module, Ethereum_Module, } from &quot;./wrap&quot;;  Here we can see that we've imported Module types that represent our Wraps, according to their specified namespace. Using these types, we can invoke our Wraps in a type-safe manner, without having to repeatedly specify the Wrap URI: const client = new PolywrapClient(); await Logging_Module.info({ message: &quot;Hello there&quot;, }, client);  This allows us to write all of our code in a type-safe manner, and allows for IDEs like VS Code to give us autocompletion suggestions via IntelliSense. Now we can explore our Wraps by simply importing them and trying them out! "},{"title":"A real-world exmaple, revisited​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#a-real-world-exmaple-revisited","content":"Let's revisit our Uniswap V3 Wrap example from the Quick Start tutorial. If we wanted to invoke the Uniswap V3 Wrap without codegen, we had to write the following code: const usdcResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, });  Instead, we can now add an import statement for the Uniswap V3 Wrap to our schema.graphql file: schema.graphql #import * into UniswapV3 from &quot;ens/uniswap.wraps.eth:v3&quot;  Running codegen now will add all types defined inside the Uniswap V3 Wrap to our wrap folder: polywrap codegen  We can now import the UniswapV3_Module and supporting types into our index.ts file: import { UniswapV3_Module, UniswapV3_ChainIdEnum, } from &quot;./wrap&quot;;  We can now invoke the Uniswap V3 Wrap by writing: const usdcResult = await UniswapV3_Module.fetchToken( { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: UniswapV3_ChainIdEnum.MAINNET, }, client );  Already inside the invocation, we can see that the chainId is an enum type, with all supported networks already listed. Polywrap also takes care of required and optional arguments, and if you play around, you will find that we omitted the name and symbol optional invocation arguments. If usdcResult.ok is true, its value will now have a type of UniswapV3_Token: if(!usdcResult.ok) { console.error(usdcResult.error); return; } // token is now of type UniswapV3_Token found in &quot;./wrap&quot; const token = usdcResult.value; console.log(token);  As you can see, Polywrap allows us to invoke any SDK or other piece of executable logic packaged as a Wrap in a type-safe manner, accross a multitude of platforms and languages! Of course, by using the Polywrap CLI you can build your own Wraps which you will be able to run anywhere where there's a Polywrap Client. Make sure to check out our list of supported (and coming) clients, and proceed to the next section to see what Wraps are readily available! "},{"title":"What Wraps are available?","type":0,"sectionRef":"#","url":"/quick-start/what-wraps-are-available","content":"","keywords":""},{"title":"Awesome-Polywrap (WIP)​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#awesome-polywrap-wip","content":"A curated collection of interesting Polywrap-related projects (including WASM and Plugin Wraps) can be found on our awesome-polywrap github repo. This list is a work-in-progress, and as such will be updated regularly with new Projects. If you have a Polywrap-related project, feel free to submit a pull request or get in touch so that we can add your project to the repo! "},{"title":"Wrappers.io​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#wrappersio","content":"Most wraps reside on our service, wrappers.io. On wrappers.io, you can see all available Wraps, whether they have an associated ENS record or not. You can also You can also see Wraps registered on wrappers.io that have an associated ENS record, or you can even filter them by the Controller of the ENS doman. caution Make sure that you connect your wallet in order to be able to browse Wraps! "},{"title":"Polywrap Integrations repo​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#polywrap-integrations-repo","content":"The Polywrap Integrations repo is a repository of integrations built by various developers on top of Polywrap. It also contains live demos for some of the developed Wraps "},{"title":"Do it yourself​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#do-it-yourself","content":"If you can't find a Wrap that suits you, maybe it's time to build your own WASM Wrap or maybe even build a Plugin Wrap! "},{"title":"Build","type":0,"sectionRef":"#","url":"/reference/cli/commands/build","content":"Build Usage: polywrap build|b [options] Build Polywrap Projects (type: interface, wasm) Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Build manifest file (default: polywrap.yaml | polywrap.yml) -o, --output-dir &lt;path&gt; Output directory for build results (default: ./build) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient -n, --no-codegen Skip code generation before build --codegen-dir Codegen output directory (default: ./src/wrap) --wrapper-envs &lt;envs-path&gt; Path to a JSON file containing wrapper envs -s, --strategy &lt;vm | image | local&gt; Strategy to use for building the wrapper (default: vm) -w, --watch Automatically execute command when changes are made (default: false) -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"Codegen","type":0,"sectionRef":"#","url":"/reference/cli/commands/codegen","content":"Codegen Usage: polywrap codegen|g [options] Generate Code For Polywrap Projects Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap manifest file (default: polywrap.yaml | polywrap.yml) -g, --codegen-dir &lt;path&gt; Output directory for the generated code (default: ./src/wrap) -s, --script &lt;path&gt; Path to a custom generation script (JavaScript | TypeScript) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient --wrapper-envs &lt;envs-path&gt; Path to a JSON file containing wrapper envs -w, --watch Automatically execute command when changes are made (default: false) -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"Polywrap Client","type":0,"sectionRef":"#","url":"/quick-start/polywrap-client","content":"","keywords":""},{"title":"NodeJS application boilerplate​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#nodejs-application-boilerplate","content":"We'll be using a simple NodeJS application boilerplate for this guide. Using npm init or yarn init within a directory initialize an empty NodeJS project. Within package.json, change the type of the project to &quot;module&quot;. This is not required as you can also use require, but we prefer using import statements. package.json { &quot;name&quot;: &quot;my-app-name&quot;, //... &quot;type&quot;: &quot;module&quot;, //... }  Add an index.js file with the following code: index.js async function main() { // your code goes here... } main() .then(() =&gt; { process.exit(0); }) .catch((error) =&gt; { console.error(error); process.exit(1); });  And that's it! Use this boilerplate to try out code within this guide. "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#install-the-polywrap-client","content":"Using NPM: npm install --save @polywrap/client-js  Using yarn: yarn add @polywrap/client-js  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#invoking-your-first-wrap","content":"tip The term &quot;Wrap&quot; and &quot;Wrapper&quot; are interchangeable. &quot;Wrapper&quot; is the old way in which we used to call Wraps, so don't get confused if you happen to come accross this term! In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your index.js file, import the PolywrapClient and instantiate it: index.js import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  At this point, you can already invoke Wraps! In the simple example below, we will invoke the Logger Wrap within our main function: const result = await client.invoke({ uri: &quot;ens/wraps.eth:logger@1.0.0&quot;, method: &quot;log&quot;, args: { message: &quot;Hello Polywrap!&quot;, }, }); console.log(result);  Running the application using node index.js, you should now see two lines appear in your console: Hello Polywrap! { ok: true, value: true }  The first line is printed by the Logger Wrap, while the second line shows the structure of the InvokeResult object. "},{"title":"What's going on here?​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#whats-going-on-here","content":"Using the Polywrap Client, we are invoking the log method of a Wrap found under the WRAP URI ens/wraps.eth:logger@1.0.0 called the Logger Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. "},{"title":"The InvokeResult object​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#the-invokeresult-object","content":"The InvokeResult object can have one of two structures: A successful Wrap invocation returns { ok: true, value: ... } with value being the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation returns { ok: false, error: ... } with error describing the reason for invocation failure. Although not particularly useful in our last example, our next example leverages the fact that Wrap invocations return a value. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true use-case: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors. const wethResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if(!wethResult.ok) { console.log(wethResult.error) return; } console.log(&quot;WETH:&quot;, wethResult.value); const usdcResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if(!usdcResult.ok) { console.log(usdcResult.error) return; } console.log(&quot;USDC:&quot;, usdcResult.value); const poolAddressResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;getPoolAddress&quot;, args: { tokenA: wethResult.value, tokenB: usdcResult.value, fee: &quot;MEDIUM&quot; }, }); // Log the invocation error and stop execution if the invocation fails if(!poolAddressResult.ok) { console.log(poolAddressResult.error); return; } console.log(&quot;Pool address:&quot;, poolAddressResult.value);  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. In this chapter's last example, we will use two separate SDKs to figure out the IPFS hash behind the Logger Wrap's ENS domain record, then fetch that Wrap's schema (more about that in the next chapter). First, we will use the Ens Text Record Resolver Wrap to resolve the ENS domain to an IPFS Wrap URI. // We first want to resolve the ENS address (uniswap.wraps.eth) // and text record (v3) into an IPFS WRAP URI const resolutionResult = await client.invoke({ uri: &quot;ens/wraps.eth:ens-text-record-uri-resolver-ext@1.0.0&quot;, method: &quot;tryResolveUri&quot;, args: { authority: &quot;ens&quot;, path: &quot;uniswap.wraps.eth:v3&quot;, }, }); if (!resolutionResult.ok) { console.log(resolutionResult.error); return; } console.log(resolutionResult.value);  Now, if we look at the uri property of resolutionResult.value, we will see a WRAP URI Once we have the IPFS hash, we will use the IPFS Wrap to fetch the contents of the Wrap's manifest file (wrap.info), and print them out. // Extract the IPFS CID from the resolution result's URI const cid = resolutionResult.value.uri.replace(&quot;wrap://ipfs/&quot;, &quot;&quot;); // Since the CID is a directory, we need to add a path to the Wrap's manifest file const catResult = await client.invoke({ uri: &quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot;, method: &quot;cat&quot;, args: { cid: cid + &quot;/wrap.info&quot;, ipfsProvider: &quot;https://ipfs.wrappers.io&quot; }, }); console.log(catResult); if (!catResult.ok) { console.log(catResult.error); return; } // Turn the returned buffer into a string and log it const schema = new TextDecoder().decode(catResult.value); console.log(schema);  In this example, we printed out a Wrap's Manifest file. This is a file that contains the definiton of the Wrap. Amongst other things it contains what types and methods are present within a Wrap, called the Wrap's Schema, and we'll talk more about it in the next section. "},{"title":"Create","type":0,"sectionRef":"#","url":"/reference/cli/commands/create","content":"Create Usage: polywrap create|c [options] [command] Create New Projects Options: -h, --help display help for command Commands: wasm [options] &lt;language&gt; &lt;name&gt; Create a Polywrap wasm wrapper. langs: assemblyscript, rust, interface app [options] &lt;language&gt; &lt;name&gt; Create a Polywrap application. langs: typescript plugin [options] &lt;language&gt; &lt;name&gt; Create a Polywrap plugin. langs: typescript template [options] &lt;url&gt; &lt;name&gt; Download template from a URL. formats: .git help [command] display help for command ","keywords":""},{"title":"Docgen","type":0,"sectionRef":"#","url":"/reference/cli/commands/docgen","content":"Docgen Usage: polywrap docgen|o &lt;action&gt; [options] Generate wrapper documentation Arguments: action schema Generate GraphQL schema docusaurus Generate Docusaurus markdown jsdoc Generate JSDoc markdown (choices: &quot;schema&quot;, &quot;docusaurus&quot;, &quot;jsdoc&quot;) Options: -m, --manifest-file &lt;path&gt; Path to the project manifest file (default: polywrap.yaml | polywrap.yml) -g, --docgen-dir &lt;path&gt; Output directory for generated docs (default: ./docs) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient --wrapper-envs &lt;envs-path&gt; Path to a JSON file containing wrapper envs -i, --imports Also generate docs for dependencies -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"Deploy","type":0,"sectionRef":"#","url":"/reference/cli/commands/deploy","content":"Deploy Usage: polywrap deploy|d [options] Deploys Polywrap Projects Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Deploy manifest file (default: polywrap.deploy.yaml | polywrap.deploy.yml) -o, --output-file &lt;path&gt; Output file path for the deploy result -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"Infra","type":0,"sectionRef":"#","url":"/reference/cli/commands/infra","content":"Infra Usage: polywrap infra|i &lt;action&gt; [options] Modular Infrastructure-As-Code Orchestrator Arguments: action Infra allows you to execute the following commands: up Start Polywrap infrastructure down Stop Polywrap infrastructure config Validate and display Polywrap infrastructure's bundled docker-compose manifest vars Show Polywrap infrastructure's required .env variables (choices: &quot;up&quot;, &quot;down&quot;, &quot;vars&quot;, &quot;config&quot;) Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Infra manifest file (default: polywrap.infra.yaml | polywrap.infra.yml) -o, --modules &lt;module...&gt; Use only specified modules -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"Manifest","type":0,"sectionRef":"#","url":"/reference/cli/commands/manifest","content":"Manifest Usage: polywrap manifest|m [options] [command] Inspect &amp; Migrade Polywrap Manifests Options: -h, --help display help for command Commands: schema|s [options] [type] Prints out the schema for the current manifest format. migrate|m [options] [type] Migrates the polywrap project manifest to the latest version. help [command] display help for command ","keywords":""},{"title":"Test","type":0,"sectionRef":"#","url":"/reference/cli/commands/test","content":"Test Usage: polywrap test|t [options] Execute Tests Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Test manifest file (default: polywrap.test.yaml | polywrap.test.yml) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient --wrapper-envs &lt;envs-path&gt; Path to a JSON file containing wrapper envs -o, --output-file &lt;output-file-path&gt; Output file path for the test result -j, --jobs &lt;jobs...&gt; Specify ids of jobs that you want to run -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -l, --log-file [path] Log file to save console output to -h, --help display help for command ","keywords":""},{"title":"The Polywrap CLI (polywrap)","type":0,"sectionRef":"#","url":"/reference/cli/polywrap-cli","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#prerequisites","content":""},{"title":"Docker​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#docker","content":"Docker is required to perform some tasks, including to build Wasm wrappers. Linux users will also need to install Docker Compose. Docker is free for personal use. Once Docker is installed and enabled, you're ready to go! "},{"title":"Cue​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#cue","content":"The polywrap run command can validate runs by examining stdout output using Cue. If you need to run workflow validations, you will have to install Cue. You can install Cue by following the instructions found here. "},{"title":"Installation​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#installation","content":"Within a single project: npm install --save-dev polywrap  Globally: npm install -g polywrap  Alternatively, polywrap can be run without installation: npx polywrap  "},{"title":"Commands​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#commands","content":""},{"title":"help command and --help option​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#help-command-and---help-option","content":"To list available commands, use the help command or the -h, --help option: polywrap help polywrap --help  Alternatively, you can use the -h, --help option within any command to get a full list of available subcommands, arguments and options. polywrap create --help polywrap codegen --help  "},{"title":"build | b​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#build--b","content":"Build Wasm and Interface Polywrap projects. This outputs the project's ABI schema (Wasm and Interface) and binary package (Wasm) into the ./build directory. Currently, build can be run for Wasm, Plugin and Interface projects. Options​ -m, --manifest-file &lt;path&gt;Specify your project's manifest file. By default, build searches for polywrap.yaml. -o, --output-dir &lt;path&gt;Specify an alternative directory for build output. The default codegen output directory is ./build. -c, --client-config &lt;config-path&gt;Use a custom Polywrap Client configuration. --wrapper-envs &lt;envs-path&gt;Configure wrapper environment values using the provided file. -n, --no-codegenSkip codegen before building. By default, build performs a codegen step before building your Project. This option skips this step. -s, --strategy &lt;strategy&gt;Specify which build strategy to use. By default, the vm build strategy is used. Available strategies: vm: Uses Docker only for the source building part of the build process. At build time, it pulls a pre-built image with all necessary system dependencies, env vars and runtime; and it instantiates a Docker container with it. The Docker container instantiates bind-mounts (volumes) to copy the sources and dependencies from the host, build the sources inside the container, and copy the build artifacts back to the host machine. This approach ensures that the sources will be built in a reproducible environment but it doesn't use Docker for anything else and no image is built at runtime.image: Implies building a Docker image at runtime, where dependencies are installed and sources are copied and built as Dockerfile instructions. On subsequent builds, Docker tries to reuse cached image layers and rebuild accordingly. This approach is notably slow but the complete process happens in Docker, and can be reproduced, examined and audited layer by layer (from dependency installation to build artifacts output).local - Does not use Docker at all. It simply executes a .sh file that contains the necessary instructions to install dependencies and build sources. While this is the fastest way of building, it requires you, the user, to have all prerequisite system dependencies installed. In addition, given that sources are built on the host machine and not a reproducible docker environment, reproducibility isn't guaranteed. -w, --watchWatch the Project's files and automatically rebuild when a file is changed. "},{"title":"codegen | g​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#codegen--g","content":"Generate code bindings for Polywrap projects. This command generates types and bindings for your project based on your project's schema (found in schema.graphql). Currently, codegen can be run for App, Plugin and Wasm projects. Options​ -m, --manifest-file &lt;path&gt;Specify your project's manifest file. By default, docgen searches for polywrap.yaml. -g, --codegen-dir &lt;path&gt;Specify an alternative directory for codegen output. The default codegen output directory is ./wrap. -p, --publish-dir &lt;path&gt;Output path for the built schema and manifest (default: ./build) This only applies when running codegen for Plugin Projects. -s, --script &lt;path&gt;Path to a custom generation script (JavaScript | TypeScript). This script is run in place of the standard codegen script if provided. -c, --client-config &lt;config-path&gt;Use a custom Polywrap Client configuration. --wrapper-envs &lt;envs-path&gt;Configure wrapper environment values using the provided file. "},{"title":"create | c​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#create--c","content":"Create a Polywrap project. This command sets up a basic Polywrap-enabled project based on a pre-defined template. Subcommands​ polywrap create wasm &lt;language&gt; &lt;name&gt; Set up a Polywrap WASM Wrapper or Interface project. polywrap create app &lt;language&gt; &lt;name&gt; Set up a NodeJS or React application which uses the Polywrap Client to invoke wrappers. polywrap create plugin &lt;language&gt; &lt;name&gt; Set up a Polywrap Plugin project used to provide the Polywrap Cient with additional functionality. Arguments​ All subcommands share the following arguments: language (required) The type/language of the created project name (required) The project name. Options​ All subcommands share the following options: -o, --output-dir &lt;path&gt;Specifies a custom output directory for the created project. Sample usage​ # Create a wrapper project using assemblyscript called &quot;my-wrapper&quot; polywrap create wasm assemblyscript my-wrapper # Create an interface project using assemblyscript called &quot;my-project&quot; polywrap create wasm interface my-interface # Create a project using Typescript called &quot;my-react-app&quot; polywrap create app typescript my-app # Create a Plugin wrapper project using Typescript called &quot;my-plugin&quot; polywrap create plugin typescript my-plugin  "},{"title":"deploy | d​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#deploy--d","content":"Deploy Polywrap projects. polywrap deploy  deploy reads the Deploy manifest (polywrap.deploy.yaml by default) and executes the jobs and steps listed inside. For more information on the Deploy command and the Deploy manifest, see Configure Polywrap deployment pipeline. Options​ -m, --manifest-file &lt;path&gt;Specify your project's manifest file. By default, deploy searches for polywrap.yaml. -o, --output-file &lt;path&gt;Output file path for the deploy result "},{"title":"infra | i​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#infra--i","content":"Modular Infrastructure-As-Code Orchestrator polywrap infra &lt;action&gt; [options]  The infra command is used to set up infrastructure to test and deploy your wrappers locally. For more information on the infra command and how to create your own Infra modules, see Configure Polywrap infrastructure pipeline Arguments​ action (required) Infra allows you to execute the following actions: upStart Polywrap infrastructuredownStop Polywrap infrastructureconfigValidate and display Polywrap infrastructure's bundled docker-compose manifestvarsShow Polywrap infrastructure's required .env variables Options​ -m, --manifest-file &lt;path&gt;Specify the infra extension manifest file. By default, infra searches for polywrap.infra.yaml. -o, --modules &lt;module, module&gt;Use only specified modules Defaults​ Polywrap comes with a default eth-ens-ipfs module which can be used to test your wrappers locally: polywrap infra up --modules=eth-ens-ipfs  The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wrappers and deploy them to an ENS registry on your locally hosted testnet. Addresses for the components of ENS: Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbResolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbReverse Registrar: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C "},{"title":"test | t​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#test--t","content":"Run Test manifests. The test command executes a series of Wrapper invocations called steps organized into jobs. All steps within a job are run in series, while jobs are run in parallel. polywrap test [options]  Options​ -m, --manifest-file &lt;path&gt;Specify the Workflow extension manifest file. By default, run searches for polywrap.test.yaml. -c, --client-config &lt;config-path&gt;Use a custom Polywrap Client configuration. --wrapper-envs &lt;envs-path&gt;Configure wrapper environment values using the provided file. -o, --output-file &lt;output-file-path&gt;Specify the output file path for the workflow result -j, --jobs &lt;jobs...&gt;Specify ids of jobs that you want to run The Test manifest (polywrap.test.yaml)​ Basic structure: # The basic structure of a test file name: my-test-name #the name of the test format: 0.1.0 validation: &quot;path/to/validator.cue&quot; #(optional) path to a validator file (cuelang) jobs: first: steps: #each step is a wrapper invocation that consists of a URI, the invoked method and its arguments - uri: ens/example.eth method: helloWorld args: arg1: &quot;test&quot; ... - ... jobs: #after all job steps are executed, additional jobs can be run in parallel ... second: ...  jobs is a map of &lt;string, Job&gt;, the key being each Job's name. jobs: helloWorld: ... helloPolywrap: ...  Each Job consists of two properties: a steps collection This is a wrapper invocation, consisting of: uri - the WRAP URI of the wrappermethod - the name of the invoked wrapper methodargs (optional) - a map of the invoked method's argumentsconfig (optional) - a map of client config properties to be added/overridden an inner jobs map, making the structure of Job recursive. jobs: helloWorld: steps: - uri: ens/helloworld.polywrap.eth #ENS URI method: helloWorld args: name: test - uri: fs/./hello-polywrap/build #Filesystem URI method: helloPolywrap jobs: innerJob1: ... innerJob2: ... helloPolywrap: steps: ... jobs: ...  When running a Test manifest, all top-level Jobs are run in parallel. Within those Jobs, each step is run in series. After all steps for a Job have been run, the inner jobs are run in parallel, with their steps run in series, and so on. You can reference the result (data/error) of any step by using the $ symbol: jobs: helloWorld: steps: - uri: ens/helloworld.polywrap.eth #ENS URI method: helloWorld args: name: test - uri: fs/./hello-polywrap/build #Filesystem URI method: helloPolywrap jobs: innerJob1: steps: - uri: ens/helloworld.polywrap.eth method: helloWorld args: name: &quot;$helloWorld.1.data&quot; #Reference to `helloWorld`'s 2nd step return value jobs: innerJob11: steps: - uri: ens/helloworld.polywrap.eth method: helloWorld args: name: &quot;$helloWorld.innerJob1.0.error&quot; #Reference to helloWorld's innerJob1 1st step error  Test validation​ By specifying a validation file within your Test manifest, the result of the run will be validated using cue. Example of a validation file: helloWorld: { $0: { data: &quot;Hello test!&quot;, error?: _|_, // Never fails } $1: { data: &quot;Hello Polywrap!&quot;, error?: _|_, // Never fails } innerJob1: { $0: { data: &quot;Hello Hello test!!&quot;, error?: _|_, } } }  "},{"title":"docgen | o​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#docgen--o","content":"Generate wrapper documentation for your project. polywrap docgen &lt;action&gt;  Arguments​ action (required) Specifies the kind of documentation generated. Values: schemaGenerates GraphQL-like schema for your project.docusaurusGenerates Docusaurus markdown for your project.jsdocGenerates JSDoc markdown for your project. Options​ -m, --manifest-file &lt;path&gt;Specify your project's manifest file. By default, docgen searches for polywrap.yaml. -g, --docgen-dir &lt;path&gt;Specify the output directory for generated docs. By default, ./docs is used. -c, --client-config &lt;config-path&gt;Use a custom Polywrap Client configuration. --wrapper-envs &lt;envs-path&gt;Configure wrapper environment values using the provided file. -i, --importsGenerate docs for your project's dependencies as well. "},{"title":"manifest | m​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#manifest--m","content":"Inspect and migrate Polywrap manifests. Subcommands​ schema | s​ Output the schema for any of your Project or Extension manifests. Usage: # Output schema for the current project manifest (polywrap.yaml) polywrap manifest schema  Arguments​ typeThe type of the manifest file. The default value for type is project. Options​ -r, --rawOutput the full JSON Schema for the given manifest.-m, --manifest-file &lt;path&gt;The manifest file for which the schema will be rendered. The type argument determines the default manifest file used. For example, polywrap manifest schema build will use polywrap.build.yaml as its default manifest file. migrate | m​ Migrate a Project or Extension manifest file to the the latest version, or a version specified. Usage: # Migrate the current project manifest (polywrap.yaml) polywrap manifest migrate  Arguments​ typeThe type of the manifest file. The default value for type is project. Options​ -f, --format &lt;format&gt;Migrate to a specific format instead of the latest. Example: # Migrate the current project manfiest to format 0.2.0 polywrap manifest migrate -f 0.2.0 # or polywrap m m -f 0.2.0 -m, --manifest-file &lt;path&gt;The manifest file for which the schema will be rendered. The type argument determines the default manifest file used. For example, polywrap manifest migrate build will use polywrap.build.yaml as its default manifest file. Example: # Migrate &quot;custom-manifest.yaml&quot; to the latest format polywrap manifest migrate -m custom-manifest.yaml # or polywrap m m -m custom-manifest.yaml  "},{"title":"The -c, --client-config option​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#the--c---client-config-option","content":"The build, codegen, docgen and test commands allow the user to configure the Polywrap Client via the -c, --client-config &lt;config-path&gt; option. You can supply a path to a Javascript or Typescript module which exports a function named getClientConfig: // asynchronous option export async function getClientConfig( defaultConfigs: Partial&lt;PolywrapClientConfig&gt; ): Promise&lt;Partial&lt;PolywrapClientConfig&gt;&gt; // synchronous option export function getClientConfig( defaultConfigs: Partial&lt;PolywrapClientConfig&gt; ): Partial&lt;PolywrapClientConfig&gt;  "},{"title":"The --wrapper-envs option​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#the---wrapper-envs-option","content":"All commands which support the -c, --client-config option also support the --wrapper-envs &lt;envs-path&gt; option. This option allows the user to set environment values for Wrappers using a simple YAML or JSON file. For example, if you would like to change the API key used within the Ethereum plugin wrapper, you can create a envs.yaml file: ens/ethereum.polywrap.eth: connection: node: https://mainnet.infura.io/v3/YOUR_API_KEY # Use Infura with your API key networkNameOrChainId: mainnet  You can then run the build, codegen, docgen and test and specify your custom --wrapper-envs: polywrap codegen --wrapper-envs envs.yaml  You can also pass environment variables into the wrappper-envs file by using $: ens/ethereum.polywrap.eth: connection: node: $MY_INFURA_NODE # Use environment variable called MY_INFURA_NODE networkNameOrChainId: mainnet  If you need to use the $ sign within your wrapper-envs file, you can escape it using $$. "},{"title":"Logging​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#logging","content":"By default, the Polywrap CLI outputs all of its messages to the console. "},{"title":"Logging levels​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#logging-levels","content":"Different levels of output verbosity are supported by using the following options: -v, --verboseEnables logging of informational messages in addition to standard output. -q, --quietDisables ALL logging. Overrides the --verbose option. "},{"title":"Logging to a file​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#logging-to-a-file","content":"You can also tell the Polywrap CLI to save its output to a logfile using the -l, --log-file [path] option. Specifying the -l option without a path parameter will create a log file within the ./.polywrap/logs directory. # Output will be saved to the &quot;./.polywrap/logs&quot; directory polywrap codegen -l  Alternatively, you can specify your own log file path. # Output will be saved to &quot;my-log-file.log&quot; polywrap codegen -l my-log-file.log  "},{"title":"@polywrap/client-js","type":0,"sectionRef":"#","url":"/reference/clients/js/client-js","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#installation","content":"npm install --save @polywrap/client-js  "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#usage","content":""},{"title":"Instantiate​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#instantiate","content":"Use the PolywrapClient constructor to instantiate the client with the default configuration bundle.  import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  "},{"title":"Configure​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#configure","content":"Use the @polywrap/client-config-builder-js package to build a custom configuration for your project.  const config = new ClientConfigBuilder().addDefaults().build(); const client = new PolywrapClient(config);  "},{"title":"Invoke​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#invoke","content":"Invoke a wrapper.  const result = await client.invoke({ uri: &quot;ens/helloworld.dev.polywrap.eth&quot;, method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot; } }); if (!result.ok) throw result.error; const value = result.value;  Reference "},{"title":"Configuration​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#configuration","content":"Below you will find a reference of object definitions which can be used to configure the Polywrap client. Please note that the intended way of configuring the client is to use the ClientConfigBuilder, as explained above. "},{"title":"PolywrapClient​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#polywrapclient","content":""},{"title":"Constructor​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#constructor","content":" /** * Instantiate a PolywrapClient * * @param config - a client configuration */ constructor(config?: CoreClientConfig)  "},{"title":"PolywrapClient Config Builder","type":0,"sectionRef":"#","url":"/reference/clients/js/client-config-builder-js","content":"","keywords":""},{"title":"Quickstart​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#quickstart","content":""},{"title":"Initialize​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#initialize","content":"Initialize a ClientConfigBuilder using the constructor  // start with a blank slate (typical usage) const builder = new ClientConfigBuilder();  "},{"title":"Configure​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#configure","content":"Add client configuration with add, or flexibly mix and match builder configuration methods to add and remove configuration items.  // add multiple items to the configuration using the catch-all `add` method builder.add({ envs: {}, interfaces: {}, redirects: {}, wrappers: {}, packages: {}, resolvers: [], }); // add or remove items by chaining method calls builder .addPackage(&quot;wrap://plugin/package&quot;, httpPlugin({})) .removePackage(&quot;wrap://plugin/package&quot;) .addPackages({ &quot;wrap://plugin/http&quot;: httpPlugin({}), &quot;wrap://plugin/filesystem&quot;: fileSystemPlugin({}), });  You can add the entire default client configuration bundle at once with addDefaults  builder.addDefaults();  "},{"title":"Build​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#build","content":"Finally, build a ClientConfig or CoreClientConfig to pass to the PolywrapClient constructor.  // accepted by either the PolywrapClient or the PolywrapCoreClient let coreClientConfig = builder.build(); // build with a custom cache coreClientConfig = builder.build({ resolutionResultCache: new ResolutionResultCache(), }); // or build with a custom resolver coreClientConfig = builder.build({ resolver: RecursiveResolver.from([]), });  "},{"title":"Example​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#example","content":"A complete example using all or most of the available methods.  // init const builder = new ClientConfigBuilder(); // add the default bundle first to override its entries later builder.addDefaults(); // add many config items at once builder.add({ envs: {}, interfaces: {}, redirects: {}, wrappers: {}, packages: {}, resolvers: [], }); // add and remove wrappers builder .addWrapper( &quot;wrap://ens/wrapper.eth&quot;, await WasmWrapper.from( new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3]) ) ) .removeWrapper(&quot;wrap://ens/wrapper.eth&quot;) .addWrappers({ &quot;wrap://ens/wrapper.eth&quot;: await WasmWrapper.from( new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3]) ), }); // add and remove wrap packages builder .addPackage(&quot;wrap://plugin/package&quot;, httpPlugin({})) .removePackage(&quot;wrap://plugin/package&quot;) .addPackages({ &quot;wrap://plugin/package&quot;: httpPlugin({}), }); // add and remove Envs builder .addEnv(&quot;wrap://ens/wrapper.eth&quot;, { key: &quot;value&quot; }) .removeEnv(&quot;wrap://ens/wrapper.eth&quot;) .addEnvs({ &quot;wrap://ens/wrapper.eth&quot;: { key: &quot;value&quot; }, }); // override existing Env, or add new Env if one is not registered at URI builder.setEnv(&quot;wrap://ens/wrapper.eth&quot;, { key: &quot;value&quot; }); // add or remove registration for an implementation of an interface builder .addInterfaceImplementation( &quot;wrap://ens/interface.eth&quot;, &quot;wrap://ens/wrapper.eth&quot; ) .removeInterfaceImplementation( &quot;wrap://ens/interface.eth&quot;, &quot;wrap://ens/wrapper.eth&quot; ) .addInterfaceImplementations(&quot;wrap://ens/interface.eth&quot;, [ &quot;wrap://ens/wrapper.eth&quot;, ]); // add or remove URI redirects builder .addRedirect(&quot;wrap://ens/from.eth&quot;, &quot;wrap://ens/to.eth&quot;) .removeRedirect(&quot;wrap://ens/from.eth&quot;) .addRedirects({ &quot;wrap://ens/from.eth&quot;: &quot;wrap://ens/to.eth&quot;, }); // add resolvers builder.addResolver(RecursiveResolver.from([])); builder.addResolvers([]); // build const clientConfig = builder.build();  Reference "},{"title":"ClientConfigBuilder​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#clientconfigbuilder","content":""},{"title":"Constructor​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#constructor","content":" /** * Instantiate a ClientConfigBuilder */ constructor()  "},{"title":"add​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#add","content":" /** * Add a partial BuilderConfig * This is equivalent to calling each of the plural add functions: `addEnvs`, `addWrappers`, etc. * * @param config: a partial BuilderConfig * @returns IClientConfigBuilder (mutated self) */ add(config: Partial&lt;BuilderConfig&gt;): IClientConfigBuilder;  "},{"title":"addWrapper​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addwrapper","content":" /** * Add an embedded wrapper * * @param uri: uri of wrapper * @param wrapper: wrapper to be added * @returns IClientConfigBuilder (mutated self) */ addWrapper(uri: string, wrapper: Wrapper): IClientConfigBuilder;  "},{"title":"addWrappers​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addwrappers","content":" /** * Add one or more embedded wrappers. * This is equivalent to calling addWrapper for each wrapper. * * @param uriWrappers: an object where keys are uris and wrappers are value * @returns IClientConfigBuilder (mutated self) */ addWrappers(uriWrappers: Record&lt;string, Wrapper&gt;): IClientConfigBuilder;  "},{"title":"removeWrapper​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#removewrapper","content":" /** * Remove an embedded wrapper * * @param uri: the wrapper's URI * @returns IClientConfigBuilder (mutated self) */ removeWrapper(uri: string): IClientConfigBuilder;  "},{"title":"addPackage​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addpackage","content":" /** * Add an embedded wrap package * * @param uri: uri of wrapper * @param wrapPackage: package to be added * @returns IClientConfigBuilder (mutated self) */ addPackage(uri: string, wrapPackage: IWrapPackage): IClientConfigBuilder;  "},{"title":"addPackages​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addpackages","content":" /** * Add one or more embedded wrap packages * This is equivalent to calling addPackage for each package * * @param uriPackages: an object where keys are uris and packages are value * @returns IClientConfigBuilder (mutated self) */ addPackages(uriPackages: Record&lt;string, IWrapPackage&gt;): IClientConfigBuilder;  "},{"title":"removePackage​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#removepackage","content":" /** * Remove an embedded wrap package * * @param uri: the package's URI * @returns IClientConfigBuilder (mutated self) */ removePackage(uri: string): IClientConfigBuilder;  "},{"title":"addEnv​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addenv","content":" /** * Add an Env. * If an Env is already associated with the uri, it is modified. * * @param uri: the wrapper's URI to associate with the Env * @param env: an object with the env variables for the uri * @returns IClientConfigBuilder (mutated self) */ addEnv(uri: string, env: Record&lt;string, unknown&gt;): IClientConfigBuilder;  "},{"title":"addEnvs​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addenvs","content":" /** * Add one or more Envs * This is equivalent to calling addEnv for each Env * * @param uriEnvs: and object where key is the uri and value is the another object with the env variables for the uri * @returns IClientConfigBuilder (mutated self) */ addEnvs( uriEnvs: Record&lt;string, Record&lt;string, unknown&gt;&gt; ): IClientConfigBuilder;  "},{"title":"removeEnv​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#removeenv","content":" /** * Remove an Env * * @param uri: the URI associated with the Env * @returns IClientConfigBuilder (mutated self) */ removeEnv(uri: string): IClientConfigBuilder;  "},{"title":"setEnv​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#setenv","content":" /** * Add an Env. * If an Env is already associated with the uri, it is replaced. * * @param uri: the wrapper's URI to associate with the Env * @param env: an object with the environment variables for the uri * @returns IClientConfigBuilder (mutated self) */ setEnv(uri: string, env: Record&lt;string, unknown&gt;): IClientConfigBuilder;  "},{"title":"addInterfaceImplementation​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addinterfaceimplementation","content":" /** * Register an implementation of a single interface * * @param interfaceUri: the URI of the interface * @param implementationUri: the URI of the implementation * @returns IClientConfigBuilder (mutated self) */ addInterfaceImplementation( interfaceUri: string, implementationUri: string ): IClientConfigBuilder;  "},{"title":"addInterfaceImplementations​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addinterfaceimplementations","content":" /** * Register one or more implementation of a single interface * * @param interfaceUri: the URI of the interface * @param implementationUris: a list of URIs for the implementations * @returns IClientConfigBuilder (mutated self) */ addInterfaceImplementations( interfaceUri: string, implementationUris: Array&lt;string&gt; ): IClientConfigBuilder;  "},{"title":"removeInterfaceImplementation​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#removeinterfaceimplementation","content":" /** * Remove an implementation of a single interface * * @param interfaceUri: the URI of the interface * @param implementationUri: the URI of the implementation * @returns IClientConfigBuilder (mutated self) */ removeInterfaceImplementation( interfaceUri: string, implementationUri: string ): IClientConfigBuilder;  "},{"title":"addRedirect​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addredirect","content":" /** * Add a redirect from one URI to another * * @param from: the URI to redirect from * @param to: the URI to redirect to * @returns IClientConfigBuilder (mutated self) */ addRedirect(from: string, to: string): IClientConfigBuilder;  "},{"title":"addRedirects​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addredirects","content":" /** * Add an array of URI redirects * * @param redirects: an object where key is from and value is to * @returns IClientConfigBuilder (mutated self) */ addRedirects(redirects: Record&lt;string, string&gt;): IClientConfigBuilder;  "},{"title":"removeRedirect​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#removeredirect","content":" /** * Remove a URI redirect * * @param from: the URI that is being redirected * @returns IClientConfigBuilder (mutated self) */ removeRedirect(from: string): IClientConfigBuilder;  "},{"title":"addResolver​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addresolver","content":" /** * Add a URI Resolver, capable of resolving a URI to a wrapper * * @remarks * A UriResolverLike can be any one of: * IUriResolver&lt;unknown&gt; * | IUriRedirect&lt;string&gt; * | IUriPackage&lt;string&gt; * | IUriWrapper&lt;string&gt; * | UriResolverLike[]; * * @param resolver: A UriResolverLike * @returns IClientConfigBuilder (mutated self) */ addResolver(resolver: UriResolverLike): IClientConfigBuilder;  "},{"title":"addResolvers​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#addresolvers","content":" /** * Add one or more URI Resolvers, capable of resolving URIs to wrappers * * @remarks * A UriResolverLike can be any one of: * IUriResolver&lt;unknown&gt; * | IUriRedirect&lt;string&gt; * | IUriPackage&lt;string&gt; * | IUriWrapper&lt;string&gt; * | UriResolverLike[]; * * @param resolvers: A list of UriResolverLike * @returns IClientConfigBuilder (mutated self) */ addResolvers(resolvers: UriResolverLike[]): IClientConfigBuilder;  "},{"title":"addDefaults​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#adddefaults","content":" /** * Add the default configuration bundle * * @returns IClientConfigBuilder (mutated self) */ addDefaults(): IClientConfigBuilder;  "},{"title":"build​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#build-1","content":" /** * Build a sanitized core client configuration that can be passed to the PolywrapClient or PolywrapCoreClient constructors * * @param options - Use a custom wrapper cache or resolver * @returns CoreClientConfig that results from applying all the steps in the builder pipeline */ build(options?: BuildOptions): CoreClientConfig;  "},{"title":"Bundles​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#bundles","content":""},{"title":"Bundle: DefaultConfig​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#bundle-defaultconfig","content":"export const ipfsProviders: string[] = [ &quot;https://ipfs.wrappers.io&quot;, &quot;https://ipfs.io&quot;, ]; interface IDefaultEmbed { uri: Uri; package: IWrapPackage; source: Uri; } interface IDefaultEmbeds { ipfsHttpClient: IDefaultEmbed; ipfsResolver: IDefaultEmbed; } export const embeds: IDefaultEmbeds = { ipfsHttpClient: { uri: Uri.from(&quot;embed/ipfs-http-client@1.0.0&quot;), package: ipfsHttpClient.wasmPackage, source: Uri.from(&quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot;), }, ipfsResolver: { uri: Uri.from(&quot;embed/async-ipfs-uri-resolver-ext@1.0.1&quot;), package: ipfsResolver.wasmPackage, source: Uri.from(&quot;ens/wraps.eth:async-ipfs-uri-resolver-ext@1.0.1&quot;), }, }; type UriResolverExtBootloader = [IDefaultEmbed, IUriRedirect, ...Uri[]]; export const uriResolverExts: UriResolverExtBootloader = [ embeds.ipfsResolver, { from: Uri.from(&quot;ens/wraps.eth:ens-text-record-uri-resolver-ext@1.0.1&quot;), to: Uri.from(&quot;ipfs/QmXcHWtKkfrFmcczdMSXH7udsSyV3UJeoWzkaUqGBm1oYs&quot;), }, Uri.from(&quot;ens/wraps.eth:http-uri-resolver-ext@1.0.1&quot;), Uri.from(&quot;ens/wraps.eth:file-system-uri-resolver-ext@1.0.1&quot;), Uri.from(&quot;ens/wraps.eth:ens-uri-resolver-ext@1.0.1&quot;), Uri.from(&quot;ens/wraps.eth:ens-ipfs-contenthash-uri-resolver-ext@1.0.1&quot;), ]; interface IDefaultPlugin { uri: Uri; plugin: IWrapPackage; implements: Uri[]; } interface IDefaultPlugins { logger: IDefaultPlugin; http: IDefaultPlugin; fileSystem: IDefaultPlugin; concurrent: IDefaultPlugin; ethereumProviderV1: IDefaultPlugin; ethereumProviderV2: IDefaultPlugin; } export const plugins: IDefaultPlugins = { logger: { uri: Uri.from(&quot;plugin/logger@1.0.0&quot;), plugin: loggerPlugin({}), implements: [Uri.from(&quot;ens/wraps.eth:logger@1.0.0&quot;)], }, http: { uri: Uri.from(&quot;plugin/http@1.1.0&quot;), plugin: httpPlugin({}), implements: [ Uri.from(&quot;ens/wraps.eth:http@1.1.0&quot;), Uri.from(&quot;ens/wraps.eth:http@1.0.0&quot;), ], }, fileSystem: { uri: Uri.from(&quot;plugin/file-system@1.0.0&quot;), plugin: fileSystemPlugin({}), implements: [Uri.from(&quot;ens/wraps.eth:file-system@1.0.0&quot;)], }, concurrent: { uri: Uri.from(&quot;plugin/concurrent@1.0.0&quot;), plugin: concurrentPromisePlugin({}), implements: [Uri.from(&quot;ens/wraps.eth:concurrent@1.0.0&quot;)], }, ethereumProviderV1: { uri: Uri.from(&quot;plugin/ethereum-provider@1.1.0&quot;), plugin: EthProviderV1.plugin({ connections: new EthProviderV1.Connections({ networks: { mainnet: new EthProviderV1.Connection({ provider: &quot;https://mainnet.infura.io/v3/b00b2c2cc09c487685e9fb061256d6a6&quot;, }), goerli: new EthProviderV1.Connection({ provider: &quot;https://goerli.infura.io/v3/b00b2c2cc09c487685e9fb061256d6a6&quot;, }), }, }), }), implements: [ Uri.from(&quot;ens/wraps.eth:ethereum-provider@1.1.0&quot;), Uri.from(&quot;ens/wraps.eth:ethereum-provider@1.0.0&quot;), ], }, ethereumProviderV2: { uri: Uri.from(&quot;plugin/ethereum-provider@2.0.0&quot;), plugin: EthProvider.plugin({ connections: new EthProvider.Connections({ networks: { mainnet: new EthProvider.Connection({ provider: &quot;https://mainnet.infura.io/v3/b00b2c2cc09c487685e9fb061256d6a6&quot;, }), goerli: new EthProvider.Connection({ provider: &quot;https://goerli.infura.io/v3/b00b2c2cc09c487685e9fb061256d6a6&quot;, }), }, }), }), implements: [Uri.from(&quot;ens/wraps.eth:ethereum-provider@2.0.0&quot;)], }, }; export function getConfig(): BuilderConfig { const builder = new ClientConfigBuilder(); // Add all embedded packages for (const embed of Object.values(embeds)) { builder.addPackage(embed.uri.uri, embed.package); // Add source redirect builder.addRedirect(embed.source.uri, embed.uri.uri); // Add source implementation builder.addInterfaceImplementation(embed.source.uri, embed.uri.uri); } // Add all plugin packages for (const plugin of Object.values(plugins)) { builder.addPackage(plugin.uri.uri, plugin.plugin); // Add all interface implementations &amp; redirects for (const interfaceUri of plugin.implements) { builder.addInterfaceImplementation(interfaceUri.uri, plugin.uri.uri); builder.addRedirect(interfaceUri.uri, plugin.uri.uri); } } // Add all uri-resolver-ext interface implementations builder.addInterfaceImplementations( ExtendableUriResolver.defaultExtInterfaceUris[0].uri, [ uriResolverExts[0].source.uri, uriResolverExts[1].from.uri, ...uriResolverExts.slice(2).map((x: Uri) =&gt; x.uri), ] ); builder.addRedirect(uriResolverExts[1].from.uri, uriResolverExts[1].to.uri); // Configure the ipfs-uri-resolver provider endpoints &amp; retry counts builder.addEnv(embeds.ipfsResolver.source.uri, { provider: ipfsProviders[0], fallbackProviders: ipfsProviders.slice(1), retries: { tryResolveUri: 2, getFile: 2 }, }); return builder.config; }  "},{"title":"@polywrap/asyncify-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/asyncify-js","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/asyncify-js","url":"/reference/clients/js/libraries/asyncify-js#usage","content":"import { AsyncWasmInstance } from &quot;@polywrap/asyncify-js&quot;; // module.wasm must be asyncify enabled const module: ArrayBuffer = getModule(&quot;./module.wasm&quot;); const memory = new WebAssembly.Memory({ initial: 1 }); const instance = await AsyncWasmInstance.createInstance({ module, imports: { my: { custom_import: async (arg: number): Promise&lt;number&gt; =&gt; { return await someAsyncCall(arg); } }, env: { memory } } }); await instance.exports.main();  "},{"title":"@polywrap/msgpack-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/msgpack-js","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/msgpack-js","url":"/reference/clients/js/libraries/msgpack-js#usage","content":"import { msgpackEncode, msgpackDecode } from &quot;@polywrap/msgpack-js&quot;; const test = { foo: 5, bar: [true, false], baz: { prop: &quot;value&quot; } }; const encoded: Uint8Array = msgpackEncode(test); const decoded = msgpackDecode(encoded); expect(decoded).toEqual(test);  "},{"title":"@polywrap/result","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/result","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/result","url":"/reference/clients/js/libraries/result#description","content":"Result helpers to enable the &quot;Result&quot; pattern. Enables compile-time error checking. "},{"title":"@polywrap/tracing-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/tracing-js","content":"","keywords":""},{"title":"Steps to use tracing​","type":1,"pageTitle":"@polywrap/tracing-js","url":"/reference/clients/js/libraries/tracing-js#steps-to-use-tracing","content":"Run the zipkin client using docker docker run -d -p 9411:9411 openzipkin/zipkin Enable tracing when creating the PolywrapClient const client = new PolywrapClient({ ..., tracingEnabled: true }) Or you can turn on tracing while running the PolywrapClient by calling the tracingEnabled method of PolywrapClient. // Turn tracing off client.tracingEnabled(false); Once you run the app and started producing logs, go to zipkin client which is running on http://localhost:9411. There you can click RUN QUERY button without any filters to show all the logs. "},{"title":"@polywrap/uri-resolver-extensions-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/uri-resolver-extensions-js","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#installation","content":"npm install --save @polywrap/uri-resolver-extensions-js  "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#usage","content":"If you build a configuration for the Polywrap client using the ClientConfigBuilder in the @polywrap/client-config-builder-js package, the ExtendableUriResovler is included by default. In that case you only need to register implementations of the URI Resolver Extension interface. Otherwise, you must also add the ExtendableUriResolver to your resolver.  const clientConfig: CoreClientConfig = { interfaces: new UriMap&lt;Uri[]&gt;([ [ Uri.from(&quot;wrap://ens/uri-resolver.core.polywrap.eth&quot;), [ Uri.from(&quot;wrap://ens/fs-resolver.polywrap.eth&quot;), Uri.from(&quot;wrap://ens/ipfs-resolver.polywrap.eth&quot;), Uri.from(&quot;wrap://ens/ens-resolver.polywrap.eth&quot;), ], ], ]), resolver: RecursiveResolver.from( [ StaticResolver.from([ ...redirects, ...wrappers, ...packages, ]), new ExtendableUriResolver(), ] ) };  Reference "},{"title":"ExtendableUriResolver​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#extendableuriresolver","content":"/** * A Uri Resolver that delegates resolution to wrappers implementing the * URI Resolver Extension Interface. * */ export class ExtendableUriResolver extends UriResolverAggregatorBase&lt; Error, Error &gt;  "},{"title":"Properties​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#properties","content":"extInterfaceUri (static)​  /** The supported interface URIs to which resolver-ext implementations should be registered */ public static defaultExtInterfaceUris: Uri[] = [ Uri.from(&quot;wrap://ens/wraps.eth:uri-resolver-ext@1.1.0&quot;), Uri.from(&quot;wrap://ens/wraps.eth:uri-resolver-ext@1.0.0&quot;), ];  extInterfaceUri​  /** The active interface URIs to which implementations should be registered */ public readonly extInterfaceUris: Uri[];  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#constructor","content":" /** * Create an ExtendableUriResolver * * @param extInterfaceUris - URI Resolver Interface URIs * @param resolverName - Name to use in resolution history output * */ constructor( extInterfaceUris: Uri[] = ExtendableUriResolver.defaultExtInterfaceUris, resolverName = &quot;ExtendableUriResolver&quot; )  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#methods","content":"getUriResolvers​  /** * Get a list of URI Resolvers * * @param uri - the URI to query for resolvers * @param client - a CoreClient instance that can be used to make an invocation * @param resolutionContext - the current URI resolution context * * @returns a list of IUriResolver or an error * */ async getUriResolvers( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;IUriResolver&lt;unknown&gt;[], Error&gt;&gt;  tryResolverUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Attempts resolution with each the URI Resolver Extension wrappers sequentially. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, Error&gt;&gt;  getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @returns text describing the URI resolution step * */ protected getStepDescription = (): string  "},{"title":"UriResolverExtensionFileReader​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#uriresolverextensionfilereader","content":"/** An IFileReader that reads files by invoking URI Resolver Extension wrappers */ export class UriResolverExtensionFileReader implements IFileReader  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#constructor-1","content":" /** * Construct a UriResolverExtensionFileReader * * @param _resolverExtensionUri - URI of the URI Resolver Extension wrapper * @param _wrapperUri - URI of the wrap package to read from * @param _client - A CoreClient instance * */ constructor( private readonly _resolverExtensionUri: Uri, private readonly _wrapperUri: Uri, private readonly _client: CoreClient )  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#methods-1","content":"readFile​  /** * Read a file * * @param filePath - the file's path from the wrap package root * * @returns a Result containing a buffer if successful, or an error * */ async readFile(filePath: string): Promise&lt;Result&lt;Uint8Array, Error&gt;&gt;  "},{"title":"UriResolverWrapper​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#uriresolverwrapper","content":"/** * An IUriResolver that delegates resolution to a wrapper that implements * the URI Resolver Extension Interface * */ export class UriResolverWrapper implements IUriResolver&lt;unknown&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#constructor-2","content":" /** * construct a UriResolverWrapper * * @param implementationUri - URI that resolves to a URI Resolver Extension implementation * */ constructor(public readonly implementationUri: Uri)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#methods-2","content":"tryResolverUri​  /** * Attempt to resolve a URI by invoking a URI Resolver Extension wrapper, then * parse the result to a wrap package, a wrapper, or a URI * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, unknown&gt;&gt;  "},{"title":"Development​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#development","content":"This package is open-source. It lives within the Polywrap JavaScript Client repository. Contributions from the community are welcomed! "},{"title":"Build​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#build","content":"nvm use &amp;&amp; yarn install &amp;&amp; yarn build  "},{"title":"Test​","type":1,"pageTitle":"@polywrap/uri-resolver-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#test","content":"yarn test  "},{"title":"@polywrap/core-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/core-js","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#types","content":""},{"title":"CoreClient​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#coreclient","content":" /** Core Client configuration that can be passed to the PolywrapClient or PolywrapCoreClient constructors */ export interface CoreClientConfig { /** register interface implementations */ readonly interfaces?: ReadonlyUriMap&lt;readonly Uri[]&gt;; /** set environmental variables for a wrapper */ readonly envs?: ReadonlyUriMap&lt;WrapperEnv&gt;; /** configure URI resolution for redirects, packages, and wrappers */ readonly resolver: Readonly&lt;IUriResolver&lt;unknown&gt;&gt;; } /** Options for CoreClient's getFile method */ export interface GetFileOptions { /** file path from wrapper root */ path: string; /** file encoding */ encoding?: &quot;utf-8&quot; | string; } /** Options for CoreClient's getImplementations method */ export interface GetImplementationsOptions { /** If true, follow redirects to resolve URIs */ applyResolution?: boolean; /** Use and update an existing resolution context */ resolutionContext?: IUriResolutionContext; } /** Options for CoreClient's validate method */ export interface ValidateOptions { /** Validate full ABI */ abi?: boolean; /** Recursively validate import URIs */ recursive?: boolean; } /** CoreClient invokes wrappers and interacts with wrap packages. */ export interface CoreClient extends Invoker, UriResolverHandler&lt;unknown&gt; { /** * Returns the configuration used to instantiate the client * * @returns an immutable core client config */ getConfig(): CoreClientConfig; /** * returns all interfaces from the configuration used to instantiate the client * * @returns a Set of interfaces and their registered implementations */ getInterfaces(): ReadonlyUriMap&lt;readonly Uri[]&gt; | undefined; /** * returns all env registrations from the configuration used to instantiate the client * * @returns an array of env objects containing wrapper environmental variables */ getEnvs(): ReadonlyUriMap&lt;WrapperEnv&gt; | undefined; /** * returns an env (a set of environmental variables) from the configuration used to instantiate the client * * @param uri - the URI used to register the env * @returns an env, or undefined if an env is not found at the given URI */ getEnvByUri(uri: Uri): WrapperEnv | undefined; /** * returns the URI resolver from the configuration used to instantiate the client * * @returns an object that implements the IUriResolver interface */ getResolver(): IUriResolver&lt;unknown&gt;; /** * returns a package's wrap manifest * * @param uri - a wrap URI * @returns a Result containing the WrapManifest if the request was successful */ getManifest(uri: Uri): Promise&lt;Result&lt;WrapManifest, WrapError&gt;&gt;; /** * returns a file contained in a wrap package * * @param uri - a wrap URI * @param options - { path: string; encoding?: &quot;utf-8&quot; | string } * @returns a Promise of a Result containing a file if the request was successful */ getFile( uri: Uri, options: GetFileOptions ): Promise&lt;Result&lt;string | Uint8Array, WrapError&gt;&gt;; /** * returns the interface implementations associated with an interface URI * from the configuration used to instantiate the client * * @param uri - a wrap URI * @param options - { applyResolution?: boolean; resolutionContext?: IUriResolutionContext } * @returns a Result containing URI array if the request was successful */ getImplementations( uri: Uri, options: GetImplementationsOptions ): Promise&lt;Result&lt;Uri[], WrapError&gt;&gt;; }  "},{"title":"Env​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#env","content":" /** A map of string-indexed, Msgpack-serializable environmental variables associated with a wrapper */ export interface WrapperEnv { readonly [k: string]: unknown; }  "},{"title":"Invoke​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#invoke","content":" /** Options required for an Wrapper invocation. */ export interface InvokeOptions { /** The Wrapper's URI */ uri: Uri; /** Method to be executed. */ method: string; /** Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments. */ args?: Record&lt;string, unknown&gt; | Uint8Array; /** Env variables for the wrapper invocation. */ env?: Record&lt;string, unknown&gt;; /** A Uri resolution context */ resolutionContext?: IUriResolutionContext; } /** * Result of an Wrapper invocation. * * @template TData Type of the invoke result data. */ export type InvokeResult&lt;TData = unknown&gt; = Result&lt;TData, WrapError&gt;; /** * Provides options for the invoker to set based on the state of the invocation. * Extends InvokeOptions. */ export interface InvokerOptions extends InvokeOptions { /** If true, the InvokeResult will (if successful) contain a Msgpack-encoded byte array */ encodeResult?: boolean; } /** * An entity capable of invoking wrappers. * * @template TData Type of the invoke result data. */ export interface Invoker { /** * Invoke a wrapper using an instance of the wrapper. * * @param options - invoker options and a wrapper instance to invoke * @returns A Promise with a Result containing the return value or an error */ invokeWrapper&lt;TData = unknown&gt;( options: InvokerOptions &amp; { wrapper: Wrapper } ): Promise&lt;InvokeResult&lt;TData&gt;&gt;; /** * Invoke a wrapper. * * @remarks * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper. * * @param options - invoker options * @returns A Promise with a Result containing the return value or an error */ invoke&lt;TData = unknown&gt;( options: InvokerOptions ): Promise&lt;InvokeResult&lt;TData&gt;&gt;; } /** * Result of a Wrapper invocation, possibly Msgpack-encoded. * * @template TData Type of the invoke result data. */ export type InvocableResult&lt;TData = unknown&gt; = InvokeResult&lt;TData&gt; &amp; { /** If true, result (if successful) contains a Msgpack-encoded byte array */ encoded?: boolean; }; /** An invocable entity, such as a wrapper. */ export interface Invocable { /** * Invoke this object. * * @param options - invoke options * @param invoker - an Invoker, capable of invoking this object * @returns A Promise with a Result containing the return value or an error */ invoke( options: InvokeOptions, invoker: Invoker ): Promise&lt;InvocableResult&lt;unknown&gt;&gt;; }  "},{"title":"IUriPackage​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuripackage","content":" /** Associates a URI with an embedded wrap package */ export interface IUriPackage { /** The package's URI */ uri: Uri; /** The wrap package */ package: IWrapPackage; }  "},{"title":"IUriRedirect​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuriredirect","content":" /** Redirect invocations from one URI to another */ export interface IUriRedirect { /** URI to redirect from */ from: Uri; /** URI to redirect to */ to: Uri; }  "},{"title":"IUriWrapper​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuriwrapper","content":" /** Associates a URI with an embedded wrapper */ export interface IUriWrapper { /** The URI to resolve to the wrapper */ uri: Uri; /** A wrapper instance */ wrapper: Wrapper; }  "},{"title":"IWrapPackage​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iwrappackage","content":" /** Options for IWrapPackage's getManifest method */ export interface GetManifestOptions { /** If true, manifest validation step will be skipped */ noValidate?: boolean; } /** A wrap package, capable of producing instances of a wrapper and its manifest */ export interface IWrapPackage { /** * Produce an instance of the wrap manifest * * @param options - GetManifestOptions; customize manifest retrieval * @returns A Promise with a Result containing the wrap manifest or an error */ getManifest( options?: GetManifestOptions ): Promise&lt;Result&lt;WrapManifest, Error&gt;&gt;; /** * Produce an instance of the wrapper * * @param options - DeserializeManifestOptions; customize manifest deserialization * @returns A Promise with a Result containing the wrapper or an error */ createWrapper( options?: DeserializeManifestOptions ): Promise&lt;Result&lt;Wrapper, Error&gt;&gt;; }  "},{"title":"MaybeAsync​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#maybeasync","content":" /** Alias for a type that is either a value or a promise that resolves to the value */ export type MaybeAsync&lt;T&gt; = Promise&lt;T&gt; | T;  "},{"title":"Uri​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uri","content":"UriConfig​ /** URI configuration */ export interface UriConfig { /** URI Authority: allows the Polywrap URI resolution algorithm to determine an authoritative URI resolver. */ authority: string; /** URI Path: tells the Authority where the Wrapper resides. */ path: string; /** Full string representation of URI */ uri: string; }  Uri​ /** * A Polywrap URI. Some examples of valid URIs are: * wrap://ipfs/QmHASH * wrap://ens/sub.dimain.eth * wrap://fs/directory/file.txt * wrap://uns/domain.crypto * * Breaking down the various parts of the URI, as it applies * to [the URI standard](https://tools.ietf.org/html/rfc3986#section-3): * **wrap://** - URI Scheme: differentiates Polywrap URIs. * **ipfs/** - URI Authority: allows the Polywrap URI resolution algorithm to determine an authoritative URI resolver. * **sub.domain.eth** - URI Path: tells the Authority where the Wrapper resides. */ export class Uri {  constructor​  /** * Construct a Uri instance from a wrap URI string * * @remarks * Throws if URI string is invalid * * @param uri - a string representation of a wrap URI */ constructor(uri: string)  authority​  /** @returns Uri authority */ public get authority(): string  path​  /** @returns Uri path */ public get path(): string  uri​  /** @returns Uri string representation */ public get uri(): string  equals​  /** Test two Uri instances for equality */ public static equals(a: Uri, b: Uri): boolean  isUri​  /** * Check if a value is an instance of Uri * * @param value - value to check * @returns true if value is a Uri instance */ public static isUri(value: unknown): value is Uri  isValidUri​  /** * Test if a URI string is a valid wrap URI * * @param uri - URI string * @param parsed? - UriConfig to update (mutate) with content of URI string * @returns true if input string is a valid wrap URI */ public static isValidUri(uri: string, parsed?: UriConfig): boolean  toString​  /** @returns Uri string representation */ public toString(): string  toJSON​  /** @returns Uri string representation */ public toJSON(): string  parseUri​  /** * Parse a wrap URI string into its authority and path * * @param uri - a string representation of a wrap URI * @returns A Result containing a UriConfig, if successful, or an error */ public static parseUri(uri: string): Result&lt;UriConfig, Error&gt;  from​  /** * Construct a Uri instance from a Uri or a wrap URI string * * @remarks * Throws if URI string is invalid * * @param uri - a Uri instance or a string representation of a wrap URI */ public static from(uri: Uri | string): Uri  "},{"title":"UriResolver​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uriresolver","content":" /** Options required for URI resolution. */ export interface TryResolveUriOptions { /** The Wrapper's URI */ uri: Uri; /** A URI resolution context */ resolutionContext?: IUriResolutionContext; } /** An entity capable of resolving a wrap URI, typically by using an IUriResolver implementation */ export interface UriResolverHandler&lt;TError = undefined&gt; { /** * Resolve a URI to a wrap package, a wrapper, or a uri * * @param options - TryResolveUriOptions * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ tryResolveUri( options?: TryResolveUriOptions ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;; }  "},{"title":"Wrapper​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#wrapper","content":" /** * The Wrapper definition, which can be used to spawn * many invocations of this particular Wrapper. Internally * this class may do things like caching WASM bytecode, spawning * worker threads, or indexing into resolvers to find the requested method. */ export interface Wrapper extends Invocable { /** * Invoke the Wrapper based on the provided [[InvokeOptions]] * * @param options Options for this invocation. * @param invoker The client instance requesting this invocation. * This client will be used for any sub-invokes that occur. */ invoke( options: InvokeOptions, invoker: Invoker ): Promise&lt;InvocableResult&lt;unknown&gt;&gt;; /** * Get a file from the Wrapper package. * * @param options Configuration options for file retrieval */ getFile(options: GetFileOptions): Promise&lt;Result&lt;Uint8Array | string, Error&gt;&gt;; /** * Get a manifest from the Wrapper package. */ getManifest(): WrapManifest; }  "},{"title":"UriResolverInterface​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uriresolverinterface","content":""},{"title":"MaybeUriOrManifest​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#maybeuriormanifest","content":"/** Contains either a Uri, a manifest, or neither */ export interface MaybeUriOrManifest { /** wrap URI */ uri?: string | null; /** Serialized wrap manifest */ manifest?: Uint8Array | null; }  "},{"title":"Module​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#module","content":"tryResolveUri​  /** * Use an invoker to try to resolve a URI using a wrapper that implements the UriResolver interface * * @param invoker - invokes the wrapper with the resolution URI as an argument * @param wrapper - URI for wrapper that implements the UriResolver interface * @param uri - the URI to resolve */ tryResolveUri: async ( invoker: Invoker, wrapper: Uri, uri: Uri ): Promise&lt;Result&lt;MaybeUriOrManifest, WrapError&gt;&gt;  getFile​  /** * Use an invoker to fetch a file using a wrapper that implements the UriResolver interface * * @param invoker - invokes the wrapper with the filepath as an argument * @param wrapper - URI for wrapper that implements the UriResolver interface * @param path - a filepath, the format of which depends on the UriResolver */ getFile: async ( invoker: Invoker, wrapper: Uri, path: string ): Promise&lt;Result&lt;Uint8Array | null, WrapError&gt;&gt;  "},{"title":"Uri Resolution​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uri-resolution","content":""},{"title":"IUriResolutionContext​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuriresolutioncontext","content":"/** Track and output URI resolution state, path, and history */ export interface IUriResolutionContext { /** * Check if a URI is in the process of being resolved * * @param uri - URI to check * @return true if URI resolution is in process, false otherwise */ isResolving(uri: Uri): boolean; /** * Start resolving a URI * * @param uri - Uri to resolve */ startResolving(uri: Uri): void; /** * Stop resolving a URI * * @param uri - Uri being resolved */ stopResolving(uri: Uri): void; /** * Push a step onto the resolution history stack * * @param step - A completed resolution step */ trackStep&lt;TError&gt;(step: IUriResolutionStep&lt;TError&gt;): void; /** @return history of all URI resolution steps completed */ getHistory(): IUriResolutionStep&lt;unknown&gt;[]; /** @return current URI resolution path */ getResolutionPath(): Uri[]; /** * Create a new resolution context using the current URI resolution path * * @return a UriResolutionContext */ createSubHistoryContext(): IUriResolutionContext; /** * Create a new resolution context using the current URI resolution history * * @return a UriResolutionContext */ createSubContext(): IUriResolutionContext; }  "},{"title":"IUriResolutionStep​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuriresolutionstep","content":"/** A step in the URI resolution algorithm */ export interface IUriResolutionStep&lt;TError = undefined&gt; { /** The current URI being resolved */ sourceUri: Uri; /** The resolution result for the current URI */ result: Result&lt;UriPackageOrWrapper, TError&gt;; /** A text/visual description of this URI step */ description?: string; /** History of sub-steps that exist within the context of this URI resolution step */ subHistory?: IUriResolutionStep&lt;TError&gt;[]; }  "},{"title":"IUriResolver​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#iuriresolver","content":"/** Defines entity capable of resolving a wrap URI */ export interface IUriResolver&lt;TError = undefined&gt; { /** * Resolve a URI to a wrap package, a wrapper, or a uri * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;; }  "},{"title":"UriPackageOrWrapper​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uripackageorwrapper","content":" /** Indicates that a URI resolved to a Uri */ export type UriValue = { type: &quot;uri&quot;; uri: Uri; }; /** Indicates that a URI resolved to a wrap package */ export type UriPackageValue = IUriPackage &amp; { type: &quot;package&quot;; }; /** Indicates that a URI resolved to a wrapper */ export type UriWrapperValue = IUriWrapper &amp; { type: &quot;wrapper&quot;; }; /** indicates that a URI resolved to either a wrap package, a wrapper, or a URI */ export type UriPackageOrWrapper = UriValue | UriPackageValue | UriWrapperValue;  "},{"title":"UriResolutionContext​","type":1,"pageTitle":"@polywrap/core-js","url":"/reference/clients/js/libraries/core-js#uriresolutioncontext","content":"/** An implementation of the IUriResolutionContext interface */ export class UriResolutionContext implements IUriResolutionContext {  constructor​  /** Construct a UriResolutionContext */ constructor(); constructor( resolvingUriMap: Map&lt;string, boolean&gt;, resolutionPath: Set&lt;string&gt; ); constructor( resolvingUriMap: Map&lt;string, boolean&gt;, history: IUriResolutionStep&lt;unknown&gt;[] ); constructor( resolvingUriMap?: Map&lt;string, boolean&gt;, resolutionPathOrHistory?: Set&lt;string&gt; | IUriResolutionStep&lt;unknown&gt;[] )  "},{"title":"@polywrap/wasm-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/wasm-js","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/wasm-js","url":"/reference/clients/js/libraries/wasm-js#description","content":"Wasm wrappers "},{"title":"@polywrap/wrap-manifest-types-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/wrap-manifest-types-js","content":"@polywrap/wrap-manifest-types-js TypeScript typings for the @polywrap/wrap-manifest-schemas package.","keywords":""},{"title":"Glossary","type":0,"sectionRef":"#","url":"/reference/glossary","content":"","keywords":""},{"title":"Command-line Interface (CLI)​","type":1,"pageTitle":"Glossary","url":"/reference/glossary#command-line-interface-cli","content":"CLI\tDescriptionPolywrap CLI\tThe main CLI for Polywrap "},{"title":"Clients​","type":1,"pageTitle":"Glossary","url":"/reference/glossary#clients","content":"Client\tDescriptionTypeScript / JavaScript\tUsable in node.js and the browser. Rust\tComing soon... "},{"title":"Manifests​","type":1,"pageTitle":"Glossary","url":"/reference/glossary#manifests","content":"Coming soon... "},{"title":"Specifications​","type":1,"pageTitle":"Glossary","url":"/reference/glossary#specifications","content":"Coming soon... "},{"title":"@polywrap/schema-bind","type":0,"sectionRef":"#","url":"/reference/schema/schema-bind","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#usage","content":"import { BindOptions, BindOutput, bindSchema } from &quot;@polywrap/schema-bind&quot;; import { parseSchema } from &quot;@polywrap/schema-parse&quot;; const schema = fetch(&quot;schema.graphql&quot;); const abi = parseSchema(schema); const input: BindOptions = { projectName: &quot;Test&quot;, bindLanguage: &quot;wasm-as&quot;, abi, schema, outputDirAbs: &quot;/path/to/output/dir&quot; }; const output: BindOutput = bindSchema(input);  "},{"title":"Details​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#details","content":"Polywrap uses MessagePack as a common data interchange format between languages. This allows Polywrap WASM modules, authored in different languages, to be run within a single host language (JS, Rust, Python, Go, C#, C++). MessagePack encoded data is sent between module boundaries. Decoding of the message will happen in the destination environment, using generated binding code, created by this package. "},{"title":"Supported Schema Types​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#supported-schema-types","content":"GraphQL Schema Type\tMessagePack Type\tDescriptionUInt\tuint 32\t32-bit unsigned integer. UInt8\tuint 8\t8-bit unsigned integer. UInt16\tuint 16\t16-bit unsigned integer. UInt32\tuint 32\t32-bit unsigned integer. Int\tint 32\t32-bit signed integer. Int8\tint 8\t8-bit signed integer. Int16\tint 16\t16-bit signed integer. Int32\tint 32\t32-bit signed integer. String\tfixstr or str 8/16/32\tUTF-8 string. Boolean\tbool\ttrue or false stored as 1 byte. Bytes\tbin 8/16/32\tarray of 8-bit unsigned integer. BigInt\tfixstr or str 8/16/32\tUTF-8 string. BigNumber\tfixstr or str 8/16/32\tUTF-8 string. JSON\tfixstr or str 8/16/32\tUTF-8 string. [Type]\tfixarray or array 16/32\tArray of elements. Map\tMsgpack extention type\tMap of key-value pairs. type CustomObject { prop: Type }\tfixmap or map 16/32\tStructured object. "},{"title":"Polywrap Schema Compose (@polywrap/schema-compose)","type":0,"sectionRef":"#","url":"/reference/schema/schema-compose","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Polywrap Schema Compose (@polywrap/schema-compose)","url":"/reference/schema/schema-compose#usage","content":"import path from &quot;path&quot;; import { readFileSync } from &quot;fs&quot;; import { ComposerOptions, ComposeFilter, composeSchema } from &quot;@polywrap/schema-compose&quot;; import { TypeInfo } from &quot;@polywrap/schema-parse&quot;; const schemaPath = &quot;input/module.graphql&quot; const schema = readFileSync(schemaPath); const resolveExternal = (uri: string): Promise&lt;string&gt; =&gt; { return Promise.resolve(readFileSync(`imports-ext/${uri}/schema.graphql`) || &quot;&quot;); }; const resolveLocal = (path: string): Promise&lt;string&gt; =&gt; { return Promise.resolve(readFileSync(path) || &quot;&quot;); }; const input: ComposerOptions = { schemas: [{ schema, absolutePath, }], abiResolver: ( importFrom: string, schemaFile: SchemaFile ) =&gt; Promise&lt;Abi | SchemaFile&gt; =&gt; { ... }, output: ComposerFilter.All }; const output: ComposerOutput = composeSchema(input); const { schema: string, typeInfo: TypeInfo } = output;  "},{"title":"@polywrap/schema-parse","type":0,"sectionRef":"#","url":"/reference/schema/schema-parse","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#usage","content":"import { Abi, parseSchema, ParserOptions } from &quot;@polywrap/schema-parse&quot;; const schema = readFileSync(&quot;module.graphql&quot;, &quot;utf-8&quot;); const options: ParserOptions = { }; const abi: Abi = parseSchema(schema, options);  "},{"title":"Options​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#options","content":"interface ParserOptions { // Disable schema validation noValidate?: boolean; // Use custom validators validators?: SchemaValidatorBuilder[]; // Use custom extractors extractors?: SchemaExtractorBuilder[]; // Use custom transformations transforms?: AbiTransforms[]; }  "},{"title":"ABI Transforms​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#abi-transforms","content":"ABI transformations can be used to modify the ABI structure. A variety of pre-defined transformations can be found in the ./src/transform/ directory. Example: import { Abi, AbiTransforms, GenericDefinition, parseSchema } from &quot;@polywrap/schema-parse&quot;; function extendType(extension: any): AbiTransforms { return { enter: { Abi: (abi: Abi) =&gt; ({ ...abi, extension, }), GenericDefinition: (def: GenericDefinition) =&gt; ({ ...def, ...extension, }), }, }; }  Usage: parseSchema(schema, { transforms: [ extendType({ newProp: &quot;foo&quot; }) ] });  "},{"title":"Developer Tools","type":0,"sectionRef":"#","url":"/resources/developer-tooling","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Developer Tools","url":"/resources/developer-tooling#introduction","content":"We offer an extensive set of developer tools to build wrappers. If the platform or language you need to use isn't listed here, send us a note on Discord! "},{"title":"Developer Tools​","type":1,"pageTitle":"Developer Tools","url":"/resources/developer-tooling#developer-tools","content":"Developer Tool\tDescriptionpolywrap\tCommand line interface @polywrap/client-js\tJavaScript client @polywrap/core-js\tStandard JavaScript implementation @polywrap/react\tReact wrapper @polywrap/schema-parse\tSchema parser @polywrap/schema-compose\tSchema Composer @polywrap/schema-bind\tSchema binding @polywrap/wasm-as\tAssemblyScript runtime "},{"title":"Ecosystem Tooling","type":0,"sectionRef":"#","url":"/resources/ecosystem-tooling","content":"Ecosystem Tooling Check out the amazing projects Polywrap DAO contributors have made: Ethereum ABI -&gt; Wrapper Generator: is a node.js console app that can read an Ethereum smart contract abi file and generate Polywrap wrapper code for schema and AssemblyScript modules..Defiwrapper is a collection of different DeFi related wrappers like defi-sdk, coingecko, etc. With Defiwrapper, the ambition is to create a cross-chain multi-platform suite of DeFi related wrappers.","keywords":""},{"title":"Talks, Podcasts, and Videos","type":0,"sectionRef":"#","url":"/resources/talks-podcasts-and-videos","content":"","keywords":""},{"title":"Introduction to Polywrap​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#introduction-to-polywrap","content":" "},{"title":"EthCC Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethcc-presentation","content":" "},{"title":"ETHDenver Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethdenver-presentation","content":" "},{"title":"ETHGlobal Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethglobal-presentation","content":" "},{"title":"Dev Podcasts​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#dev-podcasts","content":""},{"title":"Episode 1 The Polywrap WASM Runtime​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#episode-1-the-polywrap-wasm-runtime","content":" "},{"title":"The Polywrap Technical Standard","type":0,"sectionRef":"#","url":"/resources/the-polywrap-technical-standard","content":"","keywords":""},{"title":"Polywrap Architecture​","type":1,"pageTitle":"The Polywrap Technical Standard","url":"/resources/the-polywrap-technical-standard#polywrap-architecture","content":" "},{"title":"Configure Polywrap build pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline","content":"","keywords":""},{"title":"Build pipeline​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#build-pipeline","content":"The build process begins by running the build command from the polywrap CLI. The command will first search for the Polywrap Manifest, find the wrapper schema and implementation, and move these files into a Docker image. Within the docker image, the wrapper schema is parsed and its contents are extracted into an ABI. The ABI is used to generate binding code for the wrapper. The wrapper is then compiled into a Wasm module. The ABI and the Polywrap Manifest are merged into a Wrap Manifest file called wrap.info. While the default build settings work well for many projects, the toolchain offers a highly configurable build pipeline for those who need more customization. "},{"title":"Build Manifest​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#build-manifest","content":"The Build Manifest polywrap.build.yaml file is the entry point to build pipeline configuration. "},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#declaration","content":"The location of the Build Manifest must be declared in your Polywrap Manifest with a field labeled build. If a custom build manifest is not declared, the default build configuration will be used. build: ./polywrap.build.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#content","content":"SchemaExampleDefault Configuration format: # Polywrap build manifest format version. Values: 0.3.0 strategies: # Custom build image configurations. image: # Docker image strategy configuration name: # Docker image name. dockerfile: # Docker image file name. buildx: # Configuration options for Docker Buildx, set to true for default value. removeImage: # Remove the image. local: # Local build strategy configuration scriptPath: # Custom script path for local build vm: # Docker VM strategy configuration baseImage: # Base image for the Docker VM defaultIncludes: # Files to include in build VM container, by default linked_packages: # Locally linked packages into docker build image. config: # General configurations.  "},{"title":"Customizing the Dockerfile​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#customizing-the-dockerfile","content":"Those who need to fully customize the Docker image build steps can customize the Dockerfile. The Dockerfile is a text file containing instructions for Docker to build images. You can learn more about it at Docker's Dockerfile documentation. To begin, either copy the default Dockerfile from the .polywrap/wasm/build/image folder or create your own. Then, in the polywrap.build.yaml file, add a key called dockerfile with the path of the newly created Dockerfile as the value. That's it! Now, you can customize the Dockerfile to your heart's content. format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile  "},{"title":"Mustache support​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#mustache-support","content":"Mustache is a logic-less template system that can be used for HTML, config files, and more. You can learn more about writing Mustache templates here. To enable Mustache capabilities for your Dockerfile, name your custom Dockerfile with a .mustache file extension: dockerfile: ./Dockerfile.mustache  With Mustache, your Dockerfile will be able to recognize variable tags set within the config field of the Build Manifest. For example, in your Build Manifest file, you could have a key such as foo with the value hey like so: format: 0.3.0 docker: name: build-env dockerfile: ./Dockerfile.mustache config: foo: hey strategies: image: name: build-env dockerfile: ./Dockerfile.mustache node_version: 16.13.0 include: - ./package.json buildx: keepBuilder: false  To use this variable in your Mustache-enabled Dockerfile, simply reference the variable with curly braces like so: {{ foo }}  "},{"title":"Configure Polywrap deployment pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#declaration","content":"The location of the deployment manifest should be declared in your Polywrap Manifest polywrap.yaml with a field labeled deploy. deploy: ./polywrap.deploy.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#content","content":"The concents of a Deploy Manifest consists of one or more jobs with their steps, each of which has some common fields and a set of configuration options particular to the step's module. All jobs run in parallel, while steps of each job run in series. The result of a step can be passed as input to a later step using $$step_name. SchemaExample format: # The manifest format version primaryJobName: # Name of the job that runs the primary deployment sequence. jobs: # Each job describes series of events in the pipeline [name]: # Name of the job config: # configuration for all deployment modules, can be overridden within each step steps: # Each step describes an event in the pipeline - name: # The name of the step package: # Deployment module uri: # The wrap URI of source content depends_on: # (Optional) Use prior step's output config: # Configuration for the deployment module  "},{"title":"Deployment Modules​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#deployment-modules","content":"Polywrap currently supports three types of deployment modules: ipfs: pins a folder's contents to IPFS and returns the content hash (CID)ens: points an ENS domain to an IPFS content hashlocal-dev-ens: registers a domain on a local test environment and points the domain to an IPFS content hash "},{"title":"IPFS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#ipfs","content":"The IPFS module pins a folder's contents to IPFS and returns the content hash (CID). It can be used to deploy a wrapper by pinning the contents of your project's build folder to the IPFS network. The IPFS module's custom configuration requires an IPFS gateway URI so the CLI knows where to send the files. Example: ipfs configuration config: gatewayUri: 'ipfs.wrappers.io' # IPFS gateway URI  "},{"title":"ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#ens","content":"The ENS module accepts an IPFS content hash (CID) as input and points an ENS domain name to it. The ENS module's custom configuration requires three arguments and accepts an optional fourth: domainName: the ENS domain name owned by your Ethereum accountprovider: an Ethereum JSON RPC providerensRegistryAddress: the Ethereum address of the ENS Registry smart contractprivateKey: (optional) your Ethereum account's private key, used when the Ethereum provider cannot produce an account signer Example: ens configuration config: domainName: 'wrapper.eth' # ENS domain name provider: 'http://localhost:4545' # an Ethereum JSON RPC provider URI ensRegistryAddress: '0x...' # The ENS Registry contract address privateKey: '' # a private key may be required to sign ethereum transactions  "},{"title":"Local Dev ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#local-dev-ens","content":"The Local Dev ENS module accepts an IPFS content hash (CID) as input, registers an ENS domain name, and points the domain name to the IPFS CID. The Local Dev ENS module was created with Polywrap's default test environment infrastructure in mind. tip Polywrap's default test environment can be started with the polywrap infra up eth-ens-ipfs CLI command and stopped with the polywrap infra down eth-ens-ipfs CLI command. The module assumes ENS infrastructure is set up on a local Ethereum network with the ENS smart contracts deployed at the following addresses: ENS Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbENS Resolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24ENS Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbENS Reverse Lookup: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C The Local Dev ENS module's custom configuration requires two arguments: domainName: the desired ENS domain name to be registeredports: contains the port of the local Ethereum test network Example: local-dev-ens configuration config: domainName: 'wrapper.eth' # ENS domain name ports: ethereum: 4545  "},{"title":"Deploy to IPFS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"Fleek​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#fleek","content":"Fleek makes it easy to build websites and apps on the new open web. &gt; Step-By-Step Guide "},{"title":"Pinata​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#pinata","content":"Pinata provides tools and infrastructure for all creators to easily create and manage content on IPFS. &gt; Step-By-Step Guide "},{"title":"Crust Network​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#crust-network","content":"Crust Network provides a Web3.0 decentralized storage network for the Metaverse. &gt; Step-By-Step Guide "},{"title":"Aleph​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#aleph","content":"Aleph allows your blockchain enabled app to securely access trusted off-chain data or computation within a couple lines of code. "},{"title":"Arweave​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#arweave","content":"Arweave enables you to store documents and applications forever. "},{"title":"@polywrap/uri-resolvers","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/uri-resolvers-js","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#installation","content":"npm install --save @polywrap/uri-resolvers-js  "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#usage","content":"This example is similar to the default resolver used by the ClientConfigBuilder in the @polywrap/client-config-builder-js package.  const resolver = RecursiveResolver.from( WrapperCacheResolver.from( [ StaticResolver.from([ ...redirects, ...wrappers, ...packages, ]), ], new WrapperCache() ) );  Reference "},{"title":"UriResolverAggregatorBase​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#uriresolveraggregatorbase","content":"/** * Abstract class for IUriResolver implementations that aggregate multiple resolvers. * The UriResolverAggregatorBase class attempts to resolve a URI by sequentially * attempting resolution with each of its composite resolvers. * */ export abstract class UriResolverAggregatorBase&lt; TResolutionError = undefined, TGetResolversError = undefined &gt; implements IUriResolver&lt;TResolutionError | TGetResolversError&gt;  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods","content":"getUriResolvers​  /** * Get a list of URI Resolvers * * @param uri - the URI to query for resolvers * @param client - a CoreClient instance that can be used to make an invocation * @param resolutionContext - a resolution context to update when resolving URIs * * @returns a list of IUriResolver or an error * */ abstract getUriResolvers( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;IUriResolver&lt;unknown&gt;[], TGetResolversError&gt;&gt;;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Attempts to resolve the URI using each of the aggregated resolvers sequentially. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt; Result&lt;UriPackageOrWrapper, TResolutionError | TGetResolversError&gt; &gt;  getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @param uri - the URI being resolved * @param result - the result of a resolution attempt * * @returns text describing the URI resolution step * */ protected abstract getStepDescription( uri: Uri, result: Result&lt;UriPackageOrWrapper, TResolutionError&gt; ): string;  tryResolveUriWithResolvers (protected)​  /** * Using each of the aggregated resolvers, attempt to resolve a URI * * @param uri - the URI to resolve * @param client - a CoreClient instance that can be used to make an invocation * @param resolvers - a list of IUriResolver implementations * @param resolutionContext - a resolution context to update when resolving URIs * * @returns a URI, a Wrap Package, or a Wrapper (or an error) * */ protected async tryResolveUriWithResolvers( uri: Uri, client: CoreClient, resolvers: IUriResolver&lt;unknown&gt;[], resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TResolutionError&gt;&gt;  "},{"title":"UriResolverAggregator​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#uriresolveraggregator","content":"/** * An implementation of UriResolverAggregatorBase */ export class UriResolverAggregator&lt; TResolutionError = undefined, TGetResolversError = undefined &gt; extends UriResolverAggregatorBase&lt; TResolutionError, TGetResolversError &gt;  "},{"title":"Types​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#types","content":"GetResolversFunc​ /** * A function that returns a list of resolvers * * @param uri - the URI to query * @param client - a CoreClient instance * */ export type GetResolversFunc = ( uri: Uri, client: CoreClient ) =&gt; Promise&lt;IUriResolver&lt;unknown&gt;[]&gt;;  GetResolversWithErrorFunc​ /** * A function that returns a list of resolvers or an error * * @param uri - the URI to query * @param client - a CoreClient instance * */ export type GetResolversWithErrorFunc&lt;TError&gt; = ( uri: Uri, client: CoreClient ) =&gt; Promise&lt;Result&lt;IUriResolver&lt;unknown&gt;[], TError&gt;&gt;;  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-1","content":"constructor​  /** * Creates a UriResolverAggregator from a list of resolvers, or from a function * that returns a list of resolvers * */ constructor(resolvers: UriResolverLike[], resolverName?: string); constructor( resolvers: ( uri: Uri, client: CoreClient ) =&gt; Promise&lt;Result&lt;IUriResolver&lt;unknown&gt;[], TGetResolversError&gt;&gt;, resolverName?: string ); constructor(resolvers: GetResolversFunc, resolverName?: string); constructor( resolvers: | UriResolverLike[] | GetResolversFunc | GetResolversWithErrorFunc&lt;TGetResolversError&gt;, private _resolverName?: string )  getUriResolvers​  /** * Get a list of URI Resolvers * * @param uri - the URI to query for resolvers * @param client - a CoreClient instance that can be used to make an invocation * * @returns a list of IUriResolver or an error * */ async getUriResolvers( uri: Uri, client: CoreClient ): Promise&lt;Result&lt;IUriResolver&lt;unknown&gt;[], TGetResolversError&gt;&gt;  getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @returns text describing the URI resolution step * */ protected getStepDescription = (): string  "},{"title":"IWrapperCache​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#iwrappercache","content":"/** A Wrapper cache */ export interface IWrapperCache { /** get a Wrapper from the cache, given its URI index */ get(uri: Uri): MaybeAsync&lt;Wrapper | undefined&gt;; /** add a Wrapper to the cache, indexed by a URI */ set(uri: Uri, wrapper: Wrapper): MaybeAsync&lt;void&gt;; }  "},{"title":"WrapperCache​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#wrappercache","content":"/** * A minimal implementation of IWrapperCache * */ export class WrapperCache implements IWrapperCache  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-2","content":"get​  /** get a Wrapper from the cache, given its URI index */ get(uri: Uri): Wrapper | undefined  set​  /** add a Wrapper to the cache, indexed by a URI */ set(uris: Uri, wrapper: Wrapper): void  "},{"title":"WrapperCacheResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#wrappercacheresolver","content":"/** * An IUriResolver implementation that caches wrappers once they are resolved. * As it is a wrapper cache resolver, URI and package caching is outside of the scope for this resolver * and can be achieved through other resolvers if necessary. * The WrapperCacheResolver wraps an IUriResolver implementation and delegates resolution to it. * */ export class WrapperCacheResolver&lt;TError&gt; implements IUriResolver&lt;TError | Error&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-1","content":" /** * Creates a WrapperCacheResolver * * @param _innerResolver - a resolver to delegate resolution to * @param _cache - a wrapper cache * */ constructor( private _innerResolver: IUriResolver&lt;TError&gt;, private _cache: IWrapperCache )  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-3","content":"from​  /** * Creates a WrapperCacheResolver from a resolver-like object * * @param innerResolver - a resolver-like item to delegate resolution to * @param cache - a wrapper cache * @param options - control wrapper manifest deserialization * * @returns a WrapperCacheResolver * */ static from&lt;TResolverError = unknown&gt;( innerResolver: UriResolverLike, cache: IWrapperCache ): WrapperCacheResolver&lt;TResolverError&gt;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * If successful, cache the result. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError | Error&gt;&gt;  "},{"title":"getUriResolutionPath​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#geturiresolutionpath","content":"/** * Get a resolution path from the history of a URI resolution attempt * * @param history - the resolution context * @returns the URI's resolution path * */ export const getUriResolutionPath = ( history: IUriResolutionStep&lt;unknown&gt;[] ): IUriResolutionStep&lt;unknown&gt;[]  "},{"title":"InfiniteLoopError​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#infinitelooperror","content":"/** * Error used if the URI resolution path contains an infinite loop * */ export class InfiniteLoopError extends Error  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-2","content":" /** * Create an InfiniteLoopError * * @param _uri - URI being resolved * @param _history - URI resolution history * */ constructor( private readonly _uri: Uri, private readonly _history: IUriResolutionStep&lt;unknown&gt;[] )  "},{"title":"ResolverWithHistory​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#resolverwithhistory","content":"/** An abstract IUriResolver implementation that updates the resolution context */ export abstract class ResolverWithHistory&lt;TError = undefined&gt; implements IUriResolver&lt;TError&gt;  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-4","content":"tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Updates the resolution context with the result. * * @remarks * This method calls the internal abstract method _tryResolveUri before * updating the resolution context. Implementations are expect to place * resolution logic in _tryResolveUri. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;  getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @param uri - the URI being resolved * @param result - the result of a resolution attempt * * @returns text describing the URI resolution step * */ protected abstract getStepDescription( uri: Uri, result: Result&lt;UriPackageOrWrapper, TError&gt; ): string;  _tryResolveUri (protected)​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Updates the resolution context with the result. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ protected abstract _tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;;  "},{"title":"ResolverWithLoopGuard​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#resolverwithloopguard","content":"/** An IUriResolver implementation that prevents infinite loops in the resolution path. */ export class ResolverWithLoopGuard&lt;TError = undefined&gt; implements IUriResolver&lt;TError | InfiniteLoopError&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-3","content":" /** * Construct a ResolverWithLoopGuard * * @param _resolver - a resolution to delegate resolution to * */ constructor(private _resolver: IUriResolver&lt;TError&gt;)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-5","content":"from​  /** * Create a ResolverWithLoopGuard from a resolver-like object * * @param resolver - a resolver-like item to delegate resolution to * * @returns a ResolverWithLoopGuard * */ static from&lt;TResolverError = unknown&gt;( resolver: UriResolverLike ): ResolverWithLoopGuard&lt;TResolverError&gt;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Ensures the URI is not caught in an infinite loop by checking if it is already resolving. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError | InfiniteLoopError&gt;&gt;  "},{"title":"PackageToWrapperResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#packagetowrapperresolver","content":"/** * An IUriResolver implementation that initalizes wrappers from resolved packages. * The PackageToWrapperResolver wraps an IUriResolver implementation and delegates resolution to it. * */ export class PackageToWrapperResolver&lt;TError&gt; implements IUriResolver&lt;TError | Error&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-4","content":" /** * Creates a PackageToWrapperResolver * * @param _innerResolver - a resolver to delegate resolution to * @param _options - control wrapper manifest deserialization * */ constructor( private _innerResolver: IUriResolver&lt;TError&gt;, private _options?: { deserializeManifestOptions?: DeserializeManifestOptions; } )  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-6","content":"from​  /** * Creates a PackageToWrapperResolver from a resolver-like object * * @param innerResolver - a resolver-like item to delegate resolution to * @param options - control wrapper manifest deserialization * * @returns a PackageToWrapperResolver * */ static from&lt;TResolverError = unknown&gt;( innerResolver: UriResolverLike, options?: { deserializeManifestOptions?: DeserializeManifestOptions } ): PackageToWrapperResolver&lt;TResolverError&gt;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * If successful, cache the result. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError | Error&gt;&gt;  "},{"title":"UriResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#uriresolver","content":"/** An IUriResolver factory */ export class UriResolver  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-7","content":"from​  /** * Create an IUriResolver instance * * @param resolverLike - an object that can be transformed into a resolver * @param resolverName - a name to assign to the resolver in resolution history output * */ static from&lt;TError = undefined&gt;( resolverLike: UriResolverLike, resolverName?: string ): IUriResolver&lt;TError&gt;  "},{"title":"UriResolverLike​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#uriresolverlike","content":"/** An UriResolverLike can be one of three things: * - An IUriResolver * - An object that can be transformed into a static IUriResolver * - An array of UriResolverLike * */ export type UriResolverLike = | IUriResolver&lt;unknown&gt; | IUriRedirect | IUriPackage | IUriWrapper | UriResolverLike[];  "},{"title":"UriResolutionResult​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#uriresolutionresult","content":"/** Factory for creating Result from URI resolution output */ export class UriResolutionResult&lt;TError = undefined&gt;  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-8","content":"ok​  /** Returns a Result with `ok` set to true */ static ok&lt;TError = undefined&gt;(uri: Uri): Result&lt;UriPackageOrWrapper, TError&gt;; static ok&lt;TError = undefined&gt;( uri: Uri, wrapPackage: IWrapPackage ): Result&lt;UriPackageOrWrapper, TError&gt;; static ok&lt;TError = undefined&gt;( uri: Uri, wrapper: Wrapper ): Result&lt;UriPackageOrWrapper, TError&gt;; static ok&lt;TError = undefined&gt;( uriPackageOrWrapper: UriPackageOrWrapper ): Result&lt;UriPackageOrWrapper, TError&gt;; static ok&lt;TError = undefined&gt;( uriPackageOrWrapper: Uri | UriPackageOrWrapper, packageOrWrapper?: IWrapPackage | Wrapper ): Result&lt;UriPackageOrWrapper, TError&gt;  err​  /** Returns a Result with `ok` set to false */ static err&lt;TError = unknown&gt;( error: TError ): Result&lt;UriPackageOrWrapper, TError&gt;  "},{"title":"PackageResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#packageresolver","content":"/** * A Uri Resolver that resolves to an embedded wrap package and correctly updates * the resolution history. * */ export class PackageResolver extends ResolverWithHistory  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-5","content":" /** * Construct a PackageResolver * * @param _uri - the URI to redirect to the wrap package * @param wrapPackage - a wrap package * */ constructor(private _uri: Uri, private wrapPackage: IWrapPackage)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-9","content":"getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @returns text describing the URI resolution step * */ protected getStepDescription = (): string  _tryResolveUri (protected)​  /** * Resolve a URI to a wrap package * * @param uri - the URI to resolve * @returns A Promise with a Result containing a wrap package if successful */ protected async _tryResolveUri( uri: Uri ): Promise&lt;Result&lt;UriPackageOrWrapper&gt;&gt;  "},{"title":"RedirectResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#redirectresolver","content":"/** * A Uri Resolver that resolves to a new URI and correctly updates the * resolution history. * */ export class RedirectResolver&lt; TUri extends string | Uri = string &gt; extends ResolverWithHistory  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-6","content":" /** * Construct a RedirectResolver * * @param from - the URI to redirect from * @param to - the URI to redirect to * */ constructor(from: TUri, to: TUri)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-10","content":"getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @returns text describing the URI resolution step * */ protected getStepDescription = (): string  _tryResolveUri (protected)​  /** * Resolve a URI to a new URI * * @param uri - the URI to resolve * @returns A Promise with a Result containing a URI if successful */ protected async _tryResolveUri( uri: Uri ): Promise&lt;Result&lt;UriPackageOrWrapper&gt;&gt;  "},{"title":"WrapperResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#wrapperresolver","content":"/** * A Uri Resolver that resolves to an embedded wrapper and correctly updates * the resolution history. * */ export class WrapperResolver extends ResolverWithHistory  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-7","content":" /** * Construct a WrapperResolver * * @param _uri - the URI to redirect to the wrapper instance * @param _wrapper - a wrapper * */ constructor(private _uri: Uri, private _wrapper: Wrapper)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-11","content":"getStepDescription (protected)​  /** * A utility function for generating step descriptions to facilitate resolution context updates * * @returns text describing the URI resolution step * */ protected getStepDescription = (): string  _tryResolveUri​  /** * Resolve a URI to a wrapper * * @param uri - the URI to resolve * @returns A Promise with a Result containing a wrapper if successful */ protected async _tryResolveUri( uri: Uri ): Promise&lt;Result&lt;UriPackageOrWrapper&gt;&gt;  "},{"title":"StaticResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#staticresolver","content":"/** * An IUriResolver implementation that efficiently delegates URI resolution to * static resolvers--i.e. those that resolve to embedded URIs, Wrappers, and Packages * */ export class StaticResolver&lt;TError = undefined&gt; implements IUriResolver&lt;TError&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-8","content":" /** * Construct a Static Resolver * * @param uriMap - a mapping of URI to embedded URI, package, or wrapper * */ constructor(public uriMap: Map&lt;string, UriPackageOrWrapper&gt;)  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-12","content":"from​  /** * Create a StaticResolver from a static-resolver-like object * * @param staticResolverLikes - an array of resolver-like objects to delegate resolution to * * @returns a StaticResolver * */ static from&lt;TError = undefined&gt;( staticResolverLikes: UriResolverLike[] ): StaticResolver&lt;TError&gt;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * * @param uri - the URI to resolve * @param _ - not used * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, _: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;  "},{"title":"StaticResolverLike​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#staticresolverlike","content":"/** A StaticResolverLike can be one of two things: * - An object that can be transformed into a static IUriResolver * - An array of StaticResolverLike * */ export type StaticResolverLike = | IUriRedirect | IUriPackage | IUriWrapper | StaticResolverLike[];  "},{"title":"RequestSynchronizerResolver​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#requestsynchronizerresolver","content":"/* Uri resolver that synchronizes requests to the same URI * Multiple requests to the same URI will be resolved only once * and the result will be cached for subsequent requests (only for the duration of that first request) * Can use the `shouldIgnoreCache` option to determine whether to ignore the cached request in case of an error * (default is to use the cache) */ export class RequestSynchronizerResolver&lt;TError&gt; implements IUriResolver&lt;TError&gt;  "},{"title":"constructor​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#constructor-9","content":" /** * Construct a RequestSynchronizerResolver * * @param resolverToSynchronize - the inner resolve whose resolution will be synchronized * @param options - the optional options containing the `shouldIgnoreCache` error handler * */ constructor( private resolverToSynchronize: IUriResolver&lt;TError&gt;, private options?: { shouldIgnoreCache?: (error: TError | undefined) =&gt; boolean; } )  "},{"title":"Methods​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#methods-13","content":"from​  /** * Create a RequestSynchronizerResolver from a static-resolver-like object * * @param resolver - a resolver-like object whose resolution will be synchronized * @param options - the optional options containing the `shouldIgnoreCache` error handler * * @returns a RequestSynchronizerResolver * */ static from&lt;TResolverError = unknown&gt;( resolver: UriResolverLike, options?: { shouldIgnoreCache?: (error: TResolverError | undefined) =&gt; boolean; } ): RequestSynchronizerResolver&lt;TResolverError&gt;  tryResolveUri​  /** * Resolve a URI to a wrap package, a wrapper, or a URI. * Attempts to resolve the URI using each of the aggregated resolvers sequentially. * * @param uri - the URI to resolve * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface * @param resolutionContext - the current URI resolution context * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ async tryResolveUri( uri: Uri, client: CoreClient, resolutionContext: IUriResolutionContext ): Promise&lt;Result&lt;UriPackageOrWrapper, TError&gt;&gt;  "},{"title":"Development​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#development","content":"This package is open-source. It lives within the Polywrap JavaScript Client repository. Contributions from the community are welcomed! "},{"title":"Build​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#build","content":"nvm use &amp;&amp; yarn install &amp;&amp; yarn build  "},{"title":"Test​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#test","content":"yarn test ``  "},{"title":"Deploying to CRUST Files","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrapper using the Crust Files. so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to Crust NetworkStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 👛 Metamask🥐 Crust Network🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  "},{"title":"Step 4. Upload the build folder to Crust Network​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-4-upload-the-build-folder-to-crust-network","content":"Make sure you signin using a wallet Metamask.  Click Public  Click Upload   Upload the build folder then Click Upload   Click Sign and Upload   Your wallet will ask for a signature request Click Sign  The page should look like this:   "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-5-verifying-the-package-on-ipfs","content":"You will get an IPFS hash! This will lead you to IPFS link: https://gw.crustapps.net/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq?filename=build  🎉 Congratulations 🎉 on deploying using the Crust Files! "},{"title":"Deploying to Pinata","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Pinata so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to PinataStep 5. Verifying the package on IPFS  "},{"title":"What is Pinata?​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#what-is-pinata","content":"Pinata is building the largest pinning service on IPFS! Pinata gives users the ability to upload, manage, and share their content whenever, wherever and, with whomever they want. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🪅 Pinata🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Pinata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-4--upload-the-build-folder-to-pinata","content":"Make sure you signup for a Pinata account. Click &quot;Upload&quot;  Click &quot;Folder&quot;  Click Select for a folder to upload should be the build folder   Give your file or folder a name. Example: Gm-Polywrap  Click &quot;Upload&quot; from the alert message  "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-5--verifying-the-package-on-ipfs","content":"You will get an IPFS hash! Click the name of the folder   This will lead you to IPFS link:https://gateway.pinata.cloud/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq Now that you have the IPFS hash located in the CID column in the pinata manager, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. 🎉 Congratulations 🎉 on deploying to Pinata! "},{"title":"Deploying to Fleek","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Fleek so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to FleekStep 5. Verifying the package on IPFS  "},{"title":"What is Fleek?​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#what-is-fleek","content":"Fleek is the easiest way to build, deploy, and host websites &amp; apps on IPFSFleek provides one seamless workflow with everything you need to build fast, modern sites &amp; web apps hosted on IPFS. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js ⚡ Fleek🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Fleek​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-4--upload-the-build-folder-to-fleek","content":"Make sure you signup for a Fleek account. On the left-hand side menu of your Fleek. Account page, click on the &quot;Storage&quot; link.  Then, click &quot;Create Folder&quot; Example: Gm-Polywrap  Click Confirm to create the folder   Click the Folder After that, click &quot;Upload&quot;   Select the contents of your build folder onto Fleek.  Click Confirm.  tip Due to the current Filecoin deal size limitation, files are batched together across Fleek products and uploaded as one Filecoin So it might take 24-48 hours, depending on Fleek usage, for content to appear in ipfs "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-5--verifying-the-package-on-ipfs","content":"Click the &quot;Verify on IPFS&quot; button. You will get an IPFS hash! For an example of what you should see, visit this IPFS link. Now that you have the IPFS hash, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. You can also register an ENS domain and have it resolved to this IPFS content. 🎉 Congratulations 🎉 on deploying to Fleek! "},{"title":"Publish to ENS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"The ENS App​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens#the-ens-app","content":"ENS App is a distributed, open, and extensible naming system based on the Ethereum blockchain. "},{"title":"Plugin an existing JS SDK","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/create-js-plugin","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#introduction","content":"In this guide, we'll walk you through creating your own JavaScript-based plugin wrapper that can be added to the JavaScript Polywrap Client. caution Plugins do not retain all of Polywrap's benefits. We recommend re-writing your existing JavaScript SDKs as Wasm wrappers if possible. As always, if you need any help, message us on Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#prerequisites","content":"You'll need the following installed before building your plugin: nvmyarn You'll be using TypeScript to implement your Polywrap plugin. tip In the future, TypeScript will be one of many supported languages for implementing plugins. As more Polywrap Clients are released in various languages, implementing plugins in those languages will be supported as well. "},{"title":"Getting started​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#getting-started","content":"To get started, use the following command to spin up a project folder for your plugin. npx polywrap create plugin typescript &lt;project-name&gt;  Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-plugin. Once complete, you'll see a new folder appear, named after the custom name you've chosen. Please navigate into this new directory (using cd for example). "},{"title":"Installation​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#installation","content":"Let's ensure all of your project's dependencies are installed. From inside your project's directory, simply run: nvm install &amp;&amp; nvm useyarn "},{"title":"Overview of project files​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#overview-of-project-files","content":"Your project should look something like this: polywrap.yaml # Plugin Manifest src/ | index.ts # Entry File │ schema.graphql # Schema  "},{"title":"polywrap.yaml​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#polywrapyaml","content":"The Plugin Project Manifest describes the layout of a plugin. "},{"title":"schema.graphql​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the plugin's logic. Learn more about the plugin's code architecture by reading Plugin Architecture "},{"title":"Building the plugin​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#building-the-plugin","content":"To build your plugin, all you need is the following command: yarn build # alias for &quot;npx polywrap build&quot;  "},{"title":"Example Plugins​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#example-plugins","content":"See Understanding Plugins for some examples of Plugins used within the default configuration of the Polywrap Client. "},{"title":"Configure a Plugin Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/plugin-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Plugin Manifest","url":"/tutorials/create-plugin-wrappers/plugin-manifest#content","content":"The Plugin Manifest contains the name of the plugin, programming language used to write the plugin, the location of the plugin's entry file (i.e. the file that exports the plugin contents), and the GraphQl schema that declares the plugin's interface. SchemaExample format: # Polywrap manifest format version. Values: 0.3.0 project: # Basic project properties. name: # Name of this project. type: # Type of this project. source: # Project source files. module: # Path to the project's entry point. schema: # Path to the project's graphql schema. import_abis: # Specify ABIs to be used for the import URIs within your schema.  "},{"title":"Plugin Architecture","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/plugin-architecture","content":"","keywords":""},{"title":"Required Exports​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#required-exports","content":"A plugin must export a PluginFactory to be used by the Polywrap Client. A PluginFactory is a function that returns a PluginPackageManifest and a factory method that generates an instance of the plugin. "},{"title":"TypeScript Support​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#typescript-support","content":"The Polywrap CLI's codegen and build commands will generate a wrap folder containing useful types. The generated types will save you time and energy. You won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs. You can forget about boilerplate code and focus on your plugin's logic. While the types are not strictly required, we recommend them as a best practice. The generated types include: Module - An interface containing the methods declared in the plugin's schemaArgs_* - An interface for each method, containing the method arguments declared in the schemaCustom Types - An interface for each custom type declared in the schemamanifest - A PluginPackageManifest for the plugin (also useful for JavaScript developers!) "},{"title":"Example​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#example","content":"&quot;Example: import { Module, Args_sampleMethod, manifest } from &quot;./wrap&quot;; // imports from generated &quot;wrap&quot; folder import { PluginFactory, PluginPackage } from &quot;@polywrap/plugin-js&quot;; // plugin must export a PluginFactory export interface SamplePluginConfig { defaultValue: string; } export class SamplePlugin extends Module&lt;SamplePluginConfig&gt; { // Plugin inherits from Module constructor(config: SamplePluginConfig) { super(config); } public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument return args.data + this.config.defaultValue; } } export const samplePlugin: PluginFactory&lt;SamplePluginConfig&gt; = ( // exported PluginFactory is used by Polywrap client config: SamplePluginConfig ) =&gt; { return new PluginPackage( new SamplePlugin(config), // factory method produces a Module manifest // imported from ./wrap ); }; export const plugin = samplePlugin; // PluginFactory is exported with name &quot;plugin&quot;  "},{"title":"Add Metadata","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/add-metadata","content":"Add Metadata Developers can add content, such as a README.md, to their wrap packages. The location of this content must be defined in the project manifest under the resources key. resources: &quot;./resources&quot; By convention, the resources directory should be located at the root of the project. polywrap.yaml # Project Manifest resources/ # Resources directory src/ # Source code ","keywords":""},{"title":"Configure a Polywrap Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/polywrap-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Polywrap Manifest","url":"/tutorials/create-wasm-wrappers/polywrap-manifest#content","content":"The Polywrap Manifest contains the name of the wrapper, programming language used to write it, and the location of the wrapper schema that declares the wrapper's interface. It optionally includes a path to the wrapper's entry file (e.g. src/index.ts, src/lib.rs) and paths to other manifests that can be used to configure the build and deploy process. It can also contain an array of URI Redirects. SchemaExample format: # The manifest format version project: # Project information name: # Name of wrapper type: # Type/language of project source: # Source code information schema: # Path to wrapper schema module: # (Optional) Path to entry file import_abis: # (Optional) Array of URI redirects used to resolve imports in the schema - uri: # One of the schema's import URI abi: # Path to a local ABI or schema. Supported file formats: [*.graphql, *.info, *.json, *.yaml] extensions: build: # (Optional) Path to Build Manifest file resources: # (Optional) Path to Resources directory  "},{"title":"Default plugins","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/default-plugins","content":"","keywords":""},{"title":"Import to schema​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#import-to-schema","content":"We'll use one of the default plugins, HTTP, to show how you can import its modules into your wrapper's schema (schema.graphql file). We typically import plugins into a schema by importing the interface they implement and letting users of the wrapper decide which plugin to use. #import { Module, Request } into Http from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; Below, we explain what each part of this code means. #import Imports specific modules from a deployed or local plugin { Module, Request } These are specific modules that we're unpacking from the one of Polywrap's default plugins, HTTP. into Http This is a namespace, enabling you to use the modules in your schema e.g. Http_Module or Http_Request from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; wrap:// is the Polywrap URI schema.ens is the URI authority. It tells the Polywrap client what kind of URI it needs to resolve. See URIs for more information.wraps.eth:http@1.1.0 is the URI path, which in this case is an ENS address. "},{"title":"Use in Wasm Wrapper​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#use-in-wasm-wrapper","content":"Once types have been imported, the functionality of these imported modules can be used in wrapper development. Upon yarn build, the imported types and modules will be made available to you in the src/wrap folder. To use them, you simply need to import the specific modules that you'd like to use. If you're building an AssemblyScript-based wrapper, the import might look like this: import { Http_Module, Http_Request } from './wrap';  The Http_Module will contain the methods shown here, under the Module type. Once imported, you can access methods like so: Http_Module.get({ ... }) "},{"title":"Commonly used default plugins​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#commonly-used-default-plugins","content":"This section contains brief guides on the default plugins: EthereumProvider, FileSystem, HTTP, Logger, Concurrent. "},{"title":"Ethereum Provider​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#ethereum-provider","content":"The Ethereum Provider plugin can send RPC requests to Ethereum-compatible (EVM) blockchains. Schema: Link Importing the Ethereum Provider plugin into your wrapper's schema: #import { Module } into Provider from &quot;plugin/ethereum-provider@2.0.0&quot;  Example: Link pub fn request_sync&lt;T: Serialize + Send + Sync, R: DeserializeOwned&gt;( &amp;self, method: &amp;str, params: T, ) -&gt; Result&lt;R, ProviderError&gt; { let params_v = JSON::to_value(&amp;params).unwrap(); let res = ProviderModule::request(&amp;ArgsRequest { method: method.to_string(), params: Some(params_v), connection: self.connection.clone(), }).map_err(|err| ClientError::Error(err))?; let res = JSON::from_value(res).map_err(|err| ClientError::SerdeJson { err, text: &quot;from str failed&quot;.to_string(), })?; Ok(res) }  "},{"title":"FileSystem​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#filesystem","content":"The FileSystem plugin can interact with the host filesystem. Schema: Link Importing the FileSystem plugin into your wrapper's schema: #import { Module } into FileSystem from &quot;ens/wraps.eth:file-system@1.0.0&quot;  Example: Link pub fn get_file(args: ArgsGetFile, _env: Option&lt;Env&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; { let res = FileSystemModule::read_file(&amp;ArgsReadFile { path: args.path }); res.ok() }  "},{"title":"HTTP​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#http","content":"The HTTP plugin can send HTTP requests. Schema: Link Example Implementation​ In this example, we will implement a simple Ping method which pings CoinGecko to see their server status using an HTTP Get request from your wrapper. In our ./src/schema.graphql file, we’ll write the schema for our wrapper. At the top of this file, import the HTTP module into your wrapper: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot;  Then, define the types and fields on the Ping method. First, add a new Ping type at the bottom of the schema. type Ping { gecko_says: String! }  Then, add an argument-less method called ping that returns a non-nullable Ping to the Module type. Our completed schema looks like this: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; type Module { ping: Ping! } type Ping { gecko_says: String! }  Now, we'll implement the ping method in ./src/index.ts At the top of the file, we'll import the HTTP/Ping methods and types. import { HTTP_Module, HTTP_ResponseType, Ping, } from './wrap';  Then, implement Ping function: export function ping(): Ping { // Writing the HTTP request / response const response = HTTP_Module.get({ url: 'https://api.coingecko.com/api/v3/ping', request: { headers: [], urlParams: [], body: '', responseType: HTTP_ResponseType.TEXT, }, }).unwrap(); // Error handling for the response if (!response || response.status !== 200 || !response.body) { const errorMsg = response &amp;&amp; response.statusText ? (response.statusText as string) : 'An error occurred while fetching data from Coingecko API'; throw new Error(errorMsg); } const json = &lt;JSON.Obj&gt;JSON.parse(response.body); // Response from Coingecko with field `geckoSays` const geckoSays = json.getString('gecko_says'); if (geckoSays) { return { gecko_says: geckoSays.valueOf(), }; } throw new Error('Invalid response body!'); }  "},{"title":"Logger​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#logger","content":"The Logger plugin enables logging in a Wasm wrapper, which can be useful for debugging. In our ./src/schema.graphql file, import the Logger module into your wrapper: #import { Module } into Logger from &quot;ens/wraps.eth:logger@1.0.0&quot;  Then in your implementation file ./src/index.ts, import the Logger function: import { Logger_Module, Logger_Logger_LogLevel, } from './wrap';  And use it like so:  Logger_Module.log({ level: Logger_Logger_LogLevel.INFO, message: `Insert useful log message here`, });  When you run your test e.g. yarn test:e2e, you will see the logged message in the console. "},{"title":"Concurrent​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#concurrent","content":"The Concurrent plugin enables concurrent execution of Wasm wrapper sub-invocations. The meaning of &quot;concurrent&quot; depends on the plugin implementation, which varies by language. Schema: Link Importing the Concurrent plugin into your wrapper's schema: #import { Module } into Concurrent from &quot;ens/wraps.eth:concurrent@1.0.0&quot;  Example: Link pub fn cat_task(ipfs_provider: &amp;str, cid: &amp;str, timeout: u32, client_uri: &amp;str) -&gt; ConcurrentTask { ConcurrentTask { uri: client_uri.to_string(), method: String::from(&quot;cat&quot;), args: serialize_cat_args(&amp;ClientArgsCat { cid: cid.to_string(), ipfs_provider: ipfs_provider.to_string(), timeout: Some(timeout), cat_options: None, }).unwrap() } } pub fn cat_task_result(task_result: &amp;ConcurrentTaskResult) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { if matches!(task_result.status, ConcurrentTaskStatus::COMPLETED) { return match &amp;task_result.result { Some(result) =&gt; Ok(deserialize_cat_result(result.as_ref()).unwrap()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } return match &amp;task_result.error { Some(error) =&gt; Err(error.to_string()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } pub fn exec_parallel( providers: &amp;Vec&lt;&amp;str&gt;, cid: &amp;str, timeout: u32, ) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { // get ipfs http client uri let client_uri: String = get_ipfs_http_client_uri()?; // get Concurrent implementation let impls = Concurrent::get_implementations(); if impls.len() &lt; 1 { println!(&quot;Parallel execution is not available. Executing sequentially instead. \\ Parallel execution requires an implementation of the Concurrent interface. \\ You can declare an interface implementation in your Polywrap Client configuration.&quot;); return exec_sequential(providers, cid, timeout); } let concurrent_module = ConcurrentModule::new(impls[0].clone()); // schedule tasks let mut tasks: Vec&lt;ConcurrentTask&gt; = Vec::new(); for &amp;provider in providers { tasks.push(cat_task(provider, cid, timeout, &amp;client_uri)); } let task_ids: Vec&lt;i32&gt; = concurrent_module.schedule(&amp;ArgsSchedule { tasks })?; // request task results let return_when = ConcurrentReturnWhen::ANY_COMPLETED; let result_args = &amp;ArgsResult { task_ids: task_ids.clone(), return_when }; let results: Vec&lt;ConcurrentTaskResult&gt; = concurrent_module.result(result_args)?; // return completed result value or panic let mut errors: Vec&lt;String&gt; = Vec::new(); for i in 0..results.len() { let result = cat_task_result(&amp;results[i]); if result.is_ok() { return result; } let error = build_exec_error(providers[i], timeout, result.unwrap_err().as_str()); errors.push(error); } return Err(errors.join(&quot;\\n&quot;)); }  "},{"title":"Adding new Methods","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods","content":"","keywords":""},{"title":"Custom functionality: IPFS SimpleStorage​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#custom-functionality-ipfs-simplestorage","content":"It's time to build and customize your own Polywrap Wasm wrapper! We'll be adding IPFS support to the SimpleStorage API. "},{"title":"Update the schema​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#update-the-schema","content":"The first step to adding new wrapper functionality is defining the method we want our users to invoke. Add the following method &amp; custom data types to your ./src/schema.graphql schema file: ./src/schema.graphql type Module { ... setIpfsData( options: SetIpfsDataOptions! ipfsProvider: String! connection: Ethereum_Connection ): SetIpfsDataResult! } type SetIpfsDataOptions { address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Implement the setIpfsData method​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#implement-the-setipfsdata-method","content":"In the ./src/index.ts file, import the new types we've defined: ./src/index.ts import { Ethereum_Module, Args_deployContract, Args_setData, Args_getData, Ipfs_Module, Args_getIpfsData, Args_setIpfsData, SetIpfsDataResult, ModuleBase } from './wrap';  These new types will not exist yet, but don't worry, they'll be generated in the ./src/wrap/* folder once the yarn build command is run. Next, we'll implement the setIpfsData method. Add this function to the bottom of your ./src/index.ts file: ./src/index.ts setIpfsData(args: Args_setIpfsData): SetIpfsDataResult { // 1. Upload the data to IPFS const ipfsAddResult = Ipfs_Module.addFile({ data: { name: &quot;data&quot;, data: String.UTF8.encode(args.options.data) }, ipfsProvider: args.ipfsProvider, timeout: null, addOptions: null, }).unwrap(); const ipfsHash = ipfsAddResult.hash; // 2. Add the data's IPFS hash to SimpleStorage using `setHash(...)` const txReceipt = Ethereum_Module.callContractMethodAndWait({ address: args.options.address, method: 'function setHash(string value)', args: [ipfsHash], connection: args.connection, options: null, }).unwrap(); // 3. Return the result return { ipfsHash, txReceipt: txReceipt.transactionHash, }; }  As you can see, the SimpleStorage.sol smart contract already exposes a setHash() method. In steps 1 and 2, our SimpleStorage Wasm wrapper is sending a &quot;sub-invocation&quot; to the IPFS and Ethereum plugin wrappers we imported in our schema. Wrappers can be implemented as a WebAssembly-based wrapper, or a plugin wrapper in the client's language (ex: JavaScript). For more information on plugins, see the &quot;Plugin an Existing JS SDK&quot; documentation. The Ethereum_Module.callContractMethodAndWait function also accepts an optional argument, connection. This option allows you to select the network which you're transacting with, by specifying a node's endpoint, or a network (name or chain ID) (e.g. &quot;rinkeby&quot;). To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Adding more methods​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#adding-more-methods","content":"With our first method implementation complete, it's now time to add more. The steps are the same as above. Update the ./src/schema.graphql file like so: ./src/schema.graphql type Module { ... getIpfsData( address: String! ipfsProvider: String! connection: Ethereum_Connection ): String! ... }  Implement the getIpfsData(...) method like so in ./src/index.ts: ./src/index.ts getIpfsData(args: Args_getIpfsData): string { const hash = Ethereum_Module.callContractView({ address: args.address, method: 'function getHash() view returns (string)', args: null, connection: args.connection }).unwrap(); return String.UTF8.decode( Ipfs_Module.cat({ cid: hash, ipfsProvider: args.ipfsProvider, timeout: null, catOptions: null }).unwrap() ); }  To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Build, deploy and test","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test","content":"","keywords":""},{"title":"Build​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#build","content":"Let's start building our project! Simply run: yarn build  In the output window, you'll see that our smart contract was compiled, and our Polywrap wrapper was built and output to the ./build/* folder. It contains the following files: build/ |── wrap.wasm # Wrapper Logic └── wrap.info # Wrapper Manifest  This directory's contents will be uploaded to decentralized storage, and enable any Polywrap Client to download, and execute your wrapper's functionality within the application. The wrap.wasm file is the WebAssembly file that was compiled from AssemblyScript. Lastly, the wrap.info file describes the layout of the package, as well as its methods and custom types. "},{"title":"Deploy​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#deploy","content":"To deploy our Polywrap wrapper and associated smart contracts for testing, let's first setup a test environment. Simply run: yarn test:env:up  This will stand-up an Ethereum node, as well as an IPFS node. tip In the future, test environments will be easily configurable to include any nodes your Polywrap wrapper requires. Next, let's deploy the SimpleStorage.sol smart contract, and the simplestorage.eth wrapper URI by running: yarn deploy  "},{"title":"Test​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#test","content":"With our Polywrap wrapper live at simplestorage.eth on our test network, it's now time to test it out! This is where our workflows come in handy. Run yarn test to see this in action. In the output window, you'll see a combination of jobs and returned results from the Polywrap wrapper. In this workflow, we send a combination of setData and getData queries which modify the SimpleStorage.sol contract's stored value. Now that we've built the SimpleStorage Wasm wrapper, let's add custom functionality to it in the next section! "},{"title":"Deploy locally & run tests","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test","content":"","keywords":""},{"title":"Deploy​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#deploy","content":"With our workflow complete, let's test the Wasm wrapper on our local environment! First, let's set up our test environment with the following command in your terminal: yarn test:env:up  tip This command starts up a test environment with a local Ethereum network using Ganache, an ENS smart contract, and a local IPFS node. To close the test environment, simply run: yarn test:env:down  Next, we will deploy our both our SimpleStorage.sol smart contract as well as our wrapper with the following command: yarn deploy  tip Behind the scenes, yarn deploy will run the following commands: yarn deploy:api &amp;&amp; yarn deploy:contract Let's break down each of these commands, starting with yarn deploy:api, which itself runs this command: npx polywrap deploy The polywrap CLI's deploy command executes a deployment pipeline defined in a polywrap.deploy.yaml manifest. Our deployment pipeline builds and deploys our wrapper to our local test environment. The wrapper is assigned to an Ethereum Name Service (ENS) domain registered in the test environment that is set to resolve to our local IPFS node. We next deploy the SimpleStorage smart contract to the Ethereum test network using a script we've written for you: node ./scripts/deploy-contract.js We'll be interacting with this deployed smart contract using our Wasm wrapper. "},{"title":"Test​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#test","content":"Now, we'll use the following command to check whether our wrapper and smart contract are working properly: yarn test:workflow  This command uses the Polywrap CLI's run command, which will execute a series of Polywrap invocations and return the result to you. "},{"title":"Conclusion​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#conclusion","content":"🎉 Congratulations! You've create a custom Wasm wrapper! Hopefully this article has given you a clear understanding of the Polywrap toolchain's primary features. If at any time in this process you get stuck or have questions, please don't hesitate to reach out on Discord. "},{"title":"The Polywrap project folder","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder","content":"","keywords":""},{"title":"polywrap.yaml​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#polywrapyaml","content":"The polywrap.yaml is a manifest file describing the layout of a Polywrap Wasm wrapper. "},{"title":"schema.graphql​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the wrapper's logic. "},{"title":"src/contracts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#srccontracts","content":"The src/contracts directory contains our protocol's Ethereum-based smart contracts. "},{"title":"workflows/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#workflows","content":"Workflows provide a simple way to test your Polywrap without having to write custom testing logic (with JavaScript and Jest, for example). We'll be using this functionality further down in this guide with the polywrap run command, allowing us to easily send test queries against our API. "},{"title":"scripts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#scripts","content":"We've defined some simple build &amp; deployment scripts for our Solidity smart contracts. These are basic utilities, and can be replaced entirely by a Truffle or Hardhat project. In the next section, we'll build this example Wasm wrapper and see what gets outputted in the build folder! "},{"title":"Project setup","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#prerequisites","content":"You'll need the following installed before building your wrapper: nvmyarndockerdocker-compose You'll be using AssemblyScript to implement your wrapper's logic. AssemblyScript compiles to WebAssembly. tip For now, AssemblyScript and Rust are the only languages with which you can implement your wrapper. In the future, we will support additional languages that compile to WebAssembly, such as Go. If you have experience programming in TypeScript, you'll feel at home with AssemblyScript since the language's syntax is very similar. 👋 This guide is meant for those who want to build and deploy their own wrappers. If you're interested in integrating deployed wrappers into your own app, see our Integrate into a JS App guide. "},{"title":"Create your project​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#create-your-project","content":"Let's begin by downloading the Polywrap demos repository, which contains the SimpleStorage Wasm wrapper we will be using in this guide: git clone https://github.com/polywrap/demos.git  From the root of this new directory, navigate to simple-storage/wrapper/assemblyscript. tip The best way to start a new wrapper project is with a project template generated using our CLI. npx polywrap create wasm assemblyscript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choice. For example my-wrapper. After running this command, you'll see a new folder appear with the custom name you've chosen. The folder will contain everything you need to get started! "},{"title":"Installation​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#installation","content":"Let's ensure all of your project's dependencies are installed. From inside the project's directory, simply run: nvm install &amp;&amp; nvm useyarn The Polywrap CLI is now installed locally to your project's directory. Going forward we'll use this local installation by running npx polywrap. We recommend not installing the polywrap package globally to avoid future version conflicts, and maximize reproducibility for the other developers you're working with. Let's head over to the next section to see what's in this new directory! "},{"title":"Writing tests with workflows","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/writing-tests-with-workflows","content":"","keywords":""},{"title":"Testing​","type":1,"pageTitle":"Writing tests with workflows","url":"/tutorials/create-wasm-wrappers/tutorial/writing-tests-with-workflows#testing","content":"In order to test this new functionality, we'll update the existing ./workflows/e2e.yaml workflow file to include the new methods we've added (setIpfsData, and getIpfsData). Add the following case to the e2e.yaml workflow in the ./workflows folder. ./workflows/e2e.yaml case2: steps: - uri: fs/build method: setIpfsData args: options: address: &quot;$cases.0.data&quot; data: &quot;Hello from IPFS!&quot; ipfsProvider: &quot;http://localhost:5001&quot; - uri: fs/build method: getIpfsData args: address: &quot;$cases.0.data&quot; ipfsProvider: &quot;http://localhost:5001&quot;  Once our workflow has been defined, we may want to be able to validate our actual results against our expectations. Workflow validation uses CUE, a flexible and expressive data validation language. CUE must be installed to complete this step. If you don't want to install anything right now, don't worry! Our results will be easy to verify with manually. To continue with automated testing, let's add our expected output to a new file in the workflows folder. We will call the file validator.cue. ./workflows/validator.cue package e2e cases: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{40}$&quot;, error?: _|_, // Never fails } case1: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{64}$&quot;, error?: _|_, } $1: { data: uint, error?: _|_ } } case2: { $0: { data: { txReceipt: string, ipfsHash: &quot;QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis&quot; }, error?: _|_, } $1: { data: &quot;Hello from IPFS!&quot;, error?: _|_, } } }  With our workflow complete, we'll deploy and test our Wasm wrapper locally in the next section! "},{"title":"Environmental variables","type":0,"sectionRef":"#","url":"/tutorials/env-variables","content":"","keywords":""},{"title":"Schema declaration​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#schema-declaration","content":"To use environmental variables, wrapper developers must first declare an Env type and add the @env directive to methods in the Wrapper Schema. You can learn more about the schema declarations in the Environmental Variables section of the Wrapper Schema documentation. type Env { str: String! } type Module { foo( arg: String! ): String! @env(required: true) }  "},{"title":"Access Env in the module​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#access-env-in-the-module","content":"Environmental variables can be used in both plugin wrappers and Wasm wrappers. "},{"title":"Env in plugin wrappers​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#env-in-plugin-wrappers","content":"Plugin wrapper developers can access the Env instance as a class property. const env: Env = this.env;  "},{"title":"Env in wasm wrappers​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#env-in-wasm-wrappers","content":"Wasm wrapper developers can access the Env instance by accepting the Env as a second argument in their module's methods. When an application developer invokes the method, the environmental variables they set in their ClientConfig will be provided. AssemblyScriptRust export class Module extends ModuleBase { // App developers are required to provide Env to invoke this method methodRequireEnv(_: Args_methodRequireEnv, env: Env): Env { return env; } // Env is optional when invoking this method methodOptionalEnv(_: Args_methodOptionalEnv, env: Env | null): Env | null { return env ? (env as Env) : null; } }  "},{"title":"Case study: Uniswap v3 Wrapper","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap","content":"","keywords":""},{"title":"Project scaffolding​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#project-scaffolding","content":"The best way to set up a Polywrap project is to start with one of the project templates available in the Polywrap CLI. The polywrap create command lets you bootstrap your project structure without effort. The initial project setup includes a mutation folder and a query folder within src, which correspond to the two types of modules a wrapper can have. It also includes a polywrap.yaml manifest file, a polywrap.build.yaml Build Manifest file, and a polywrap.meta.yaml Meta Manifest file. The polywrap.yaml manifest tells the Polywrap CLI what language your wrapper is in, where your module schemas are located, and more. Our polywrap.yaml looked like this: format: 0.0.1-prealpha.5 build: ./polywrap.build.yaml meta: ./polywrap.meta.yaml language: wasm/assemblyscript modules: mutation: schema: ./src/mutation/schema.graphql module: ./src/mutation/index.ts query: schema: ./src/query/schema.graphql module: ./src/query/index.ts  The Build Manifest lets you customize the build process. The Meta Manifest lets you add meta-data to your project, like a description and a link to your repo. For the Uniswap v3 wrapper, we left the polywrap.yaml manifest and the Build Manifest unchanged. We added detail to the Meta Manifest much later, when wrapper development was largely complete. "},{"title":"Writing the interface in a GraphQL Schema​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#writing-the-interface-in-a-graphql-schema","content":"We started by reading through the entire Uniswap v3 JavaScript SDK repo on GitHub to record all the types and methods we would reproduce, and to take note of their interactions. The interface of a Polywrap API is declared in a GraphQL schema. We wrote a schema type for each externally-facing class in the SDK, with properties that matched those in the class with public access. We wrote a method declaration in the schema for each externally-facing function and class method in the SDK. We even copied over the SDK's inline documentation to fill the schema with context. #An abridged look at our schema &quot;&quot;&quot;ERC20-compliant token or Ether&quot;&quot;&quot; type Token { &quot;&quot;&quot;Id of chain where token exists&quot;&quot;&quot; chainId: ChainId! &quot;&quot;&quot;Address of token's ERC20 contract&quot;&quot;&quot; address: String! &quot;&quot;&quot;Token description&quot;&quot;&quot; currency: Currency! } type Query { &quot;&quot;&quot;Returns true if the tokens are equivalent, false otherwise&quot;&quot;&quot; tokenEquals( tokenA: Token! tokenB: Token! ): Boolean! &quot;&quot;&quot;Returns true if the address of tokenA would precede the address of token B when sorted alphabetically&quot;&quot;&quot; tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean! }  A wrapper can have two modules: a query module and a mutation module. Each module has its own schema that, along with a an optional common schema for shared types, are combined at build time. The difference between mutations and queries is simple: mutations modify state--this typically means blockchain state in web3 applications--while queries do not. The Uniswap v3 SDK does not modify on-chain state, so all of its functionality was placed in the query module schema. The first draft of the Uniswap v3 wrapper's schema was written in just a few hours, though it was revised during development to fix mistakes and improve the user experience. "},{"title":"Implementing the first functions​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#implementing-the-first-functions","content":"When porting an SDK, it's important to understand its project structure. The organization of the SDK's source code can indicate how wrapper development should proceed. Development should allow for iterative changes and testing. The Unsiwap v3 SDK can be mentally modularized into a roughly linear set of dependent components. We can start with the concept of a Token, which is the component of a CurrencyAmount and a Pool. A Route is a set of pools and currencies. A Trade is constructed from two currency amounts and one or more routes. Based on this pattern, it made sense for us to start with Token. In Uniswap's JavaScript SDK, Token has properties like chainId and address, as well as two class methods: equals and sortsBefore. // Methods found in the Token class in Uniswap's SDK Core package public equals(other: Currency): boolean { return other.isToken &amp;&amp; this.chainId === other.chainId &amp;&amp; this.address === other.address } public sortsBefore(other: Token): boolean { invariant(this.chainId === other.chainId, 'CHAIN_IDS') invariant(this.address !== other.address, 'ADDRESSES') return this.address.toLowerCase() &lt; other.address.toLowerCase() }  Using the Polywrap CLI's codegen command, we generated AssemblyScript classes corresponding to each type we defined in the schema. This was as simple as typing polywrap codegen. The classes work like TypeScript interfaces (statically typed JavaScript objects) that include some boilerplate serialization logic. When you declare a function in your schema that returns a custom type or accepts one as an argument, these generated classes are used as the AssemblyScript analogs. The codegen command simultaneously generates another flavor of AssemblyScript class: function inputs. An Input_* class is generated for each function, where * is the name of the function. The classes have properties corresponding to the arguments defined in the schema. These Input_* classes are used as inputs to the functions declared in the GraphQL schema. The Polywrap CLI places the generated files in directories named w3, which can be found within each module folder (as declared in your polywrap.yaml manifest). From there you can implement and use them. Once we generated the classes, we imported the generated types and implemented the functions just as we found them in the Uniswap SDK. The function signatures match the schema definitions we declared earlier. // An abridged copy of src/query/token.ts in the Uniswap v3 wrapper import { Input_tokenEquals, Input_tokenSortsBefore, Token, } from &quot;./w3&quot;; // Checks if the current instance is equal to another (has an identical chainId and address). export function tokenEquals(input: Input_tokenEquals): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; return tokenA.chainId == tokenB.chainId &amp;&amp; tokenA.address == tokenB.address; } // Checks if the current instance sorts before another, by address. export function tokenSortsBefore(input: Input_tokenSortsBefore): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; const tokenAddress: string = tokenA.address.toLowerCase(); const otherAddress: string = tokenB.address.toLowerCase(); return tokenAddress.localeCompare(otherAddress) &lt; 0; }  After implementing the token functions, it was possible to build the project (after commenting out methods in the schema that had not yet been implemented) and write the first automated tests. "},{"title":"Importing plugins and wrappers​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#importing-plugins-and-wrappers","content":"The Uniswap v3 wrapper imports external dependencies to help it with certain tasks. A wrapper can import other wrappers or plugins. One of the most important dependencies we used is Polywrap's Ethereum plugin. The Ethereum plugin is based on the popular ethers.js package. It can be used to prepare and send Ethereum transactions in much the same way. Although the Uniswap v3 JavaScript SDK does not include methods that mutate state on the Ethereum blockchain, several of its functions do return encoded Ethereum transaction calldata that can be sent to Uniswap's on-chain smart contracts. The SDK uses ethers.js to encode calldata. We can do the same with the Ethereum plugin. Our src/query/schema.graphql schema declares several imports at the top of the file. Among these is the Ethereum plugin, which is included in the Polywrap client by default. #import { Query } into Ethereum from &quot;wrap://ens/ethereum.polywrap.eth&quot; #import { Query } into SHA3 from &quot;wrap://ens/sha3.polywrap.eth&quot; #import { Query } into ERC20 from &quot;wrap://ipfs/QmeiPWHe2ixfitcgjRwP5AaJD5R7DbsGhQNQwT4rFNyxx8&quot; #import { Query } into Subgraph from &quot;wrap://ipfs/QmcnrHegojMFqHkRhixazY67Zb9mSbMLv6sSxyDpUtnrQS&quot; #import { ChainId, TradeType, Currency, Token, Price, TokenAmount, Tick, Pool, FeeAmount, Route, TradeSwap, Trade, BestTradeOptions, Position, PermitOptions, FeeOptions, SwapOptions, MethodParameters, MintAmounts } from &quot;../common/schema.graphql&quot;  Wrappers and plugins are queried at URIs. When a user wants to call an API function with the Polywrap Client, they use a URI to tell the Client which API they are calling. The URI's are also used to import wrapper dependencies. Even though the Ethereum plugin is a JavaScript package that gets loaded into memory, it is still queried at a URI that is redirected and resolved to the in-memory instance. Once imports are declared, we can run the codegen command of the Polywrap CLI to generate imported modules and types. The imported module class includes all of the methods declared in its own GraphQL schema. If we want to know what's in it, we might look there first. We used the Ethereum plugin's encodeFunction method to encode calldata for Uniswap's Multicall smart contract. // An abridged copy of src/query/routerUtils.ts in the Uniswap v3 wrapper import { Ethereum_Query, Input_encodeMulticall, } from &quot;./w3&quot;; export function encodeMulticall(input: Input_encodeMulticall): string { const calldatas: string[] = input.calldatas; return calldatas.length == 1 ? calldatas[0] : Ethereum_Query.encodeFunction({ method: &quot;function multicall(bytes[] calldata data) external payable returns (bytes[] memory results)&quot;, args: ['[&quot;' + calldatas.join('&quot;, &quot;') + '&quot;]'], }).unwrap(); }  "},{"title":"Using base schema types​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#using-base-schema-types","content":"Polywrap schemas support additional default types beyond those found in standard GraphQL. The BigInt type is used in the Uniswap v3 wrapper to represent integers larger than 32 bits. Since Ethereum supports unsigned integers as large as 256 bits, we needed to support them as well. &quot;&quot;&quot;An amount of a token&quot;&quot;&quot; type TokenAmount { &quot;&quot;&quot;Token&quot;&quot;&quot; token: Token! &quot;&quot;&quot;Raw amount of the token, not adjusted for the token's decimals&quot;&quot;&quot; amount: BigInt! }  The BigInt type looks like a standard GraphQL type in the schema. In AssemblyScript, the type is received as an instance of the BigInt class from in the as-bigint AssemblyScript package. // compares two TokenAmount types for equality, returning true if they have the // same token and same amount export function tokenAmountEquals(input: Input_tokenAmountEquals): boolean { const amtA: TokenAmount = input.tokenAmountA; const amtB: TokenAmount = input.tokenAmountB; return ( tokenEquals({ tokenA: amtA.token, tokenB: amtB.token }) &amp;&amp; amtA.amount.eq(amtB.amount) ); }  Other base schema types include BigNumber, JSON, and Map&lt;T,U&gt;. These types, along with BigInt, can be imported directly into AssemblyScript modules from the polywrap/wasm package. "},{"title":"Testing​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#testing","content":"We adapted all of the tests in Uniswap's SDK to work with the wrapper. This ensured that the wrapper met at least the same standards of quality the Uniswap team expected of their SDK. The Uniswap team tested their SDK with artificial data that allowed them to calculate the expected results and compare those results to the outputs of their code. We used the same test cases and expected the same results from our wrapper. We also wrote tests based on real-world data, using a fork of the Ethereum Mainnet network, to compare the results of our wrapper queries with results produced by the SDK. This helped us test the wrapper with input of greater complexity. We wrote automated tests using two different testing frameworks: as-pect and jest. "},{"title":"AssemblyScript tests with as-pect​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#assemblyscript-tests-with-as-pect","content":"as-pect is an AssemblyScript testing framework, and that is why we used it. Unit tests written in the native language of the wrapper can be used to test classes and functions that are written to support the main wrapper code. This reduces the layers of complexity that would be associated with testing only the functions declared in our GraphQL schema. For example, we wrote a PriorityQueue class to sort trades for the bestTradeExactIn and bestTradeExactOut functions. We used as-pect to test it. This simplified testing and debugging forbestTradeExactIn and bestTradeExactOut. We wrote many of our other tests in as-pect as well, in part because it was straightforward to copy and paste test scripts from the Uniswap v3 SDK repo and adapt the syntax. One quirk with as-pect is that the following must be added to its configuration file to get it working with Polywrap. imports: { w3: { __w3_invoke_args: () =&gt; {}, __w3_invoke_result: () =&gt; {}, __w3_invoke_error: () =&gt; {}, __w3_subinvoke: () =&gt; {}, __w3_subinvoke_result: () =&gt; {}, __w3_subinvoke_result_len: () =&gt; {}, __w3_subinvoke_error: () =&gt; {}, __w3_subinvoke_error_len: () =&gt; {}, __w3_abort: () =&gt; {}, } },  "},{"title":"End-to-end tests in JavaScript with Jest​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#end-to-end-tests-in-javascript-with-jest","content":"Not all tests can be written in the wrapper's native language, nor should they be. Code that depends on other wrappers or plugins must be tested by making calls to the Polywrap Client. The Client coordinates inter-API communication. We wrote many of our most important tests in the popular JavaScript framework jest. Were we to write the Uniswap v3 wrapper again, we would actually use a lot less as-pect and a lot more jest. One advantage of testing with jest is that it requires developers to make calls in the same way users of their wrappers are likely to make them. A disadvantage is that it requires developers to set up the Polywrap client and a test environment, which is easy but takes more time. You can learn how to set up a Polywrap test environment in JavaScript by reading Write an end to end test. "},{"title":"Other tips for testing in JavaScript​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#other-tips-for-testing-in-javascript","content":"The Polywrap CLI can automatically generate TypeScript types using the polywrap app command. The types mirror those declared in your GraphQL schema. If you love brevity, you can write functions that &quot;wrap&quot; your wrapper calls. This can make your tests a bit easier to read. // This function lets us call the createRoute function in the Uniswap v3 wrapper with one line of code export async function createRoute(client: PolywrapClient, ensUri: string, pools: Pool[], inToken: Token, outToken: Token): Promise&lt;Route&gt; { const query = await client.invoke&lt;Route&gt;({ uri: ensUri, module: &quot;query&quot;, method: &quot;createRoute&quot;, input: { pools, inToken, outToken, }, }); if (query.error) { throw query.error; } return query.data!; } // example usage const route_0_1: Route = await createRoute(client, ensUri, [pool_0_1], token0, token1);  "},{"title":"Documentation​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#documentation","content":"As a final touch, we generated ample documentation for the Uniswap v3 wrapper. Polywrap's GraphQL parser can read documentation comments (comments with triple quotes) from the wrapper's GraphQL schema. Using this capability, Polywrap built a tool to help developers create documentation for their wrappers. The Polywrap CLI will soon be able to use GraphQL schemas to automatically generate markdown that is compatible with popular documentation tools like Docusaurus. We tested the tool to generate the reference documentation for the Uniswap v3 wrapper. "},{"title":"Configuring the Polywrap Client","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/configure-client","content":"","keywords":""},{"title":"The ClientConfigBuilder​","type":1,"pageTitle":"Configuring the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#the-clientconfigbuilder","content":"You can use the ClientConfigBuilder class present in @polywrap/client-config-builder-js to easily build the ClientConfig object: const config = new ClientConfigBuilder() .addDefaults() // add or remove configs here using ClientConfigBuilder methods... .build(); const client = new PolywrapClient(config);  "},{"title":"Creating the Polywrap client instance","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/create-client-instance","content":"Creating the Polywrap client instance Once the Polywrap JS client has been installed, the next step is to create a PolywrapClient instance: import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient(); At this point, you can already invoke wrappers. In the simple example below, we send one to the &quot;hello world&quot; wrapper. client.invoke({ uri: &quot;ens/wraps.eth:logging@1.0.0&quot;, method: &quot;info&quot;, args: { message: &quot;Hello World!&quot; } }); ","keywords":""},{"title":"Installing the Polywrap JS client","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/install-client","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#introduction","content":"If you're a JavaScript developer building Browser, Node.js, or React based apps, this guide is for you. tip In the future, JavaScript will be one of many supported languages. Our goal is to enable the use of Polywrap in every major programming language. By the end of this document, you'll gain the following skills: How to instantiate the Polywrap client in your JavaScript AppInvoke any wrapper using the Polywrap clientConfigure the Polywrap clientBuild React apps with ease If you get stuck during this guide, send us a message on our Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#prerequisites","content":"As prerequisites for this guide, we recommend having familiarity with TypeScript. React will also be used in the latter sections. "},{"title":"Installation​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#installation","content":"To use wrappers in your app, all you need is the Polywrap Client! npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js, and browser applications. "},{"title":"Examples​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#examples","content":"Some example projects that integrate the JS client can be found here. The next section assumes that you're integrating Polywrap into an existing app project. If you want a quick start with our template project, simply run: npx polywrap create app typescript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-app. This command will create a new project folder with a &quot;Hello World&quot; app that lets you interact with two simple Wasm wrappers at wrap://ens/wraps.eth:logging@1.0.0 and wrap://ens/wraps.eth:ethereum@1.0.0. "},{"title":"Generate types for your app","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/types-for-app","content":"","keywords":""},{"title":"App Manifest content​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/integrate-wrappers/types-for-app#app-manifest-content","content":"The App Manifest contains the name of the project, the programming language used to write it, and the location of the wrapper schema that states which code to generate. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of project language: # App programming language schema: # Path to wrapper schema import_abis: # (Optional) Array of URI redirects for schema imports - uri: # Source URI to be redirected abi: # Path to a local ABI (or schema). Supported file formats: [*.graphql, *.info, *.json, *.yaml]  "},{"title":"Wrapper Schema for apps​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/integrate-wrappers/types-for-app#wrapper-schema-for-apps","content":"To automatically generate types for an application or test suite, we must tell the Polywrap CLI which types to generate. This is done using a Wrapper Schema. In your wrapper schema, you can add an import statement for each wrapper you're using in your project. You can use the * syntax to import a wrapper's module and all of its types, or you can list the types you'd like to use. Wrapper schema for the Hello World app #import * into Logging from &quot;ens/wraps.eth:logging@1.0.0&quot;  Learn more about schema imports at Wrapper Schema. "},{"title":"React integration","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/react-integration","content":"","keywords":""},{"title":"PolywrapProvider​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () =&gt; { return ( &lt;PolywrapProvider&gt; &lt;HelloWorld /&gt; &lt;/PolywrapProvider&gt; ); };  PolywrapProvider Props​ The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: &lt;PolywrapProvider redirects={ [] }/&gt;  Multiple PolywrapProviders​ If you need to use multiple providers, you can do so using the createPolywrapProvider(&quot;...&quot;) method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) =&gt; { return ( &lt;CustomPolywrapProvider&gt; {children} &lt;/CustomPolywrapProvider&gt; ); };  "},{"title":"usePolywrapClient​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient();  "},{"title":"usePolywrapInvoke​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wrappers! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, error, loading } = usePolywrapInvoke({ provider: &quot;custom&quot;, uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  "},{"title":"Configure interfaces in the client","type":0,"sectionRef":"#","url":"/tutorials/interfaces/client-config-interfaces","content":"Configure interfaces in the client The Polywrap Client can be configured to use one or more implementations for an abstract interface wrapper. You can use the Client Config Builder to register implementations for an interface URI. const config = new ClientConfigBuilder() .addDefaults() .addInterfaceImplementations( &quot;wrap://ens/wrap.interface.eth&quot;, [ &quot;wrap://ens/wrap.implementation1.eth&quot;, &quot;wrap://ens/wrap.implementation2.eth&quot;, &quot;wrap://ens/wrap.implementation3.eth&quot;, ] ) .build(); ","keywords":""},{"title":"Interface instances","type":0,"sectionRef":"#","url":"/tutorials/interfaces/interface-instances","content":"","keywords":""},{"title":"Instantiating an interface​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#instantiating-an-interface","content":"After an interface is imported in your Wrapper Schema, you can update the generated classes with the Polywrap CLI's codegen command. You will then be able to import the interface module in your wrapper. To instantiate an interface module, you must provide a URI that resolves to a wrapper that implements the interface. import { MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const instance = new MyInterface_Module(&quot;wrap://...&quot;); ... }  "},{"title":"Getting Interface Implementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#getting-interface-implementations","content":"To instantiate an interface agnostic to the implementation, you can use getImplementations to obtain a list of interface implementations registered in the Polywrap Client. "},{"title":"Declaring getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#declaring-getimplementations","content":"In addition to importing the interface module in the Wrapper Schema, you must declare that getImplementations will be used for the interface with the use { getImplementations } keywords. #import { Module } into MyInterface from &quot;wrap://ens/interface.eth&quot; #use { getImplementations } for MyInterface  "},{"title":"Using getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#using-getimplementations","content":"Now you can import the interface namespace and call its getImplementations method. The getImplementations method returns an array of URI strings that can be used to instantiate the interface module. import { MyInterface, MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const impls = MyInterface.getImplementations(); if (impls.length &lt; 1) { throw new Error(&quot;...&quot;) } const instance = new MyInterface_Module(impls[0]); ... }  "},{"title":"Define and implement interfaces","type":0,"sectionRef":"#","url":"/tutorials/interfaces/define-implement-interfaces","content":"","keywords":""},{"title":"Declaring an interface project​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#declaring-an-interface-project","content":"Interface projects are declared using a Polywrap Manifest. To indicate that a project is an abstract interface, set the project type to interface. Interface projects do not have a module. Only a schema path is declared. format: 0.3.0 project: name: UriResolver type: interface source: schema: ./src/schema.graphql  "},{"title":"Defining an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#defining-an-interface","content":"Defining an interface is as simple as writing the Wrapper Schema. Once the schema is complete, you are ready to deploy the interface wrapper. "},{"title":"Implementing an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#implementing-an-interface","content":"As described in Wrapper Schema, an interface can be imported and then implemented with the implements keyword. When a module implements an interface module, it inherits all of its method declarations. The URI Resolver Extensions plugins implement the URI Resolver interface and inherit its methods. ENS Resolver SchemaURI Resolver Schema #import { Module, MaybeUriOrManifest } into UriResolver from &quot;ens/wraps.eth:uri-resolver-ext@1.1.0&quot; #import { Module } into Ethereum from &quot;ens/wraps.eth:ethereum@2.0.0&quot; type Module implements UriResolver_Module {}  "},{"title":"Configure Polywrap infrastructure pipeline","type":0,"sectionRef":"#","url":"/tutorials/testing-wrappers/infra-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#declaration","content":"Unlike some manifests, the Infra Manifest does not need to be declared in your Polywrap manifest. "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#content","content":"The Infra Manifest consists of environmental variable declarations and one or more infrastructure modules. Each module points to a local, remote, or default docker-compose file. SchemaExample format: # The manifest format version env: # Declare environmental variables here modules: myRemote: # A remote package with a docker-compose file package: # Package name version: # Package version registry: # Package registry name dockerComposePath: # (Optional) Path to docker-compose file in the package directory myLocal: # A local package with a docker-compose file path: # Path to the package eth-ens-ipfs: default # A module available by default  "},{"title":"Infrastructure Modules​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#infrastructure-modules","content":"An Infra Manifest can declare any number of infrastructure modules. Polywrap currently supports three types of infrastructure modules: A local module exists on your local filesystem.A remote module is a package hosted by a package registry.The default module is included with the CLI. "},{"title":"Local​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#local","content":"A local infrastructure module is a path from the Infra Manifest to a local folder with a docker-compose file. Example: local module configuration format: 0.1.0 modules: myLocal: path: ../local-packages/myLocal  "},{"title":"Remote​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#remote","content":"A remote infrastructure module is a package hosted at a package registry. The package must contain a docker-compose file. The path to the docker-compose file must be declared in the Infra Manifest if the file is not located in the package root. Remote packages can be shared. Users can add remote packages to their manifest to replicate the infrastructure modules defined by other users or projects. Example: remote module configuration format: 0.1.0 modules: myIpfsNode: package: &quot;@namestys/ipfs-node&quot; version: &quot;1.0.2&quot; registry: npm dockerComposePath: ./config/docker-compose.yaml  "},{"title":"Default​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/testing-wrappers/infra-pipeline#default","content":"A default infrastructure module is included with the polywrap CLI. It is declared in the Infra Manifest as a module named eth-ens-ipfs and the value default. If an Infra Manifest is not found, the Polywrap CLI infra command can still use this module. To use the default module without an Infra Manifest, pass eth-ens-ipfs as an argument to the infra command's modules option: npx polywrap infra up --modules=eth-ens-ipfs  The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wrappers and deploy them to an ENS registry on your locally hosted testnet. The Ethereum address of the ENS registry is 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab. Example: local module configuration format: 0.1.0 modules: eth-ens-ipfs: default  "},{"title":"Testing Wrappers In TypeScript","type":0,"sectionRef":"#","url":"/tutorials/testing-wrappers/in-typescript","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#introduction","content":"In this tutorial we'll learn how to develop custom end to end (e2e) tests for your wrapper in TypeScript. These tests will be make calls into your wrapper using the JavaScript / TypeScript Polywrap Client. "},{"title":"Prerequisites​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#prerequisites","content":"You'll need the following NPM packages installed before testing your wrapper: @polywrap/client-js@polywrap/cli-jsjest "},{"title":"Project Setup​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#project-setup","content":"The tests we'll be developing will live next to your wrapper's source-code. Polywrap has published pre-configured projects for both wasm/rust and wasm/assemblyscript wrappers. You can use &amp; reference these when configuring your own project. In this tutorial we'll assume a fresh wasm/assemblyscript project has been created via the polywrap create wasm assemblyscript ... CLI command. "},{"title":"Build The Wrapper​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#build-the-wrapper","content":"Before any tests can be run, we must ensure the wrapper has been freshly built. This will ensure we test against the latest version of the wrapper's source-code. When using jest, we leverage the beforeAll function to do this. Additionally, the @polywrap/cli-js package makes it easy to invoke the polywrap build CLI command to build your wrapper. import { Commands } from &quot;@polywrap/cli-js&quot;; describe(&quot;e2e Wrapper Tests&quot;, () =&gt; { beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); });  This should result in a wrapper package being emitted to the build/ directory. "},{"title":"Configure a Polywrap Client​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#configure-a-polywrap-client","content":"Before we create a new Polywrap client, we must create a configuration for it to use. This can be done through use of the ClientConfigBuilder. In the case of this example we'll be using the default configuration bundle. If your wrapper requires any custom integration dependencies like plugins or environment variables, then now would be the time to configure this. import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; describe(&quot;e2e Wrapper Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); ... });  "},{"title":"Load The Wrapper​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#load-the-wrapper","content":"We'll be loading our wrapper directly from the build/ directory in the file-system. This can be accomplished in 1 of 2 ways: Package Embedding import { WasmPackage } from &quot;@polywrap/wasm-js&quot;; import fs from &quot;fs&quot;; ... const buildDir = `${__dirname}/../../build`; const embedPackage = WasmPackage.from( fs.readFileSync(`${buildDir}/wrap.info`), fs.readFileSync(`${buildDir}/wrap.wasm`) ); const uri = &quot;wrap://embed/test-wrapper&quot;; const config = new ClientConfigBuilder() .addPackage(uri, embedPackage) .build();  File-System URIs const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`;  In both cases, you end up with a uri which can be used to invoke your wrapper through the client. "},{"title":"Test Your Wrapper​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#test-your-wrapper","content":"Now that we have a client invoke wrappers, and a uri to reference our wrapper, we're ready to write some tests.  test(&quot;Test Case&quot;, async () =&gt; { const result = await client.invoke({ uri, method: &quot;sampleMethod&quot;, args: { arg: &quot;foo bar baz&quot; } }); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value).toMatchObject({ result: &quot;foo bar baz&quot; }); });  "},{"title":"Type Safety​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#type-safety","content":"In the example above, it shows the use of the client.invoke(...) In the example above, it shows the use of the client.invoke(...)` method, which is generic. This means that if your wrapper's schema changes, and (for example) the method being called no longer exists or its types change, the test will fail. In order to help ensure this can be caught sooner, and easier to debug, we suggest generating TypeScript types for your wrapper's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  And an import schema like so: #import * into Wrapper from &quot;wrap://file/build&quot;  We suggest putting these files in a folder next to your tests, for example src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way.  test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  debug, we suggest generating TypeScript types for your wrapper's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  We suggesting putting this polywrap.yaml manifest in a folder next to your tests like src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way. import { Wrapper_Module } from &quot;./types/wrap&quot;; ... test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  "},{"title":"Conclusion​","type":1,"pageTitle":"Testing Wrappers In TypeScript","url":"/tutorials/testing-wrappers/in-typescript#conclusion","content":"And that's a wrap! import { Commands } from &quot;@polywrap/cli-js&quot;; import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { Wrapper_Module } from &quot;./types/wrap&quot;; jest.setTimeout(50000); describe(&quot;e2e Wrapper Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`; beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); }); });  If you'd like to see an in-production wrapper w/ tests in TypeScript, checkout the ethereum wrapper's tests here. "},{"title":"URI redirects","type":0,"sectionRef":"#","url":"/tutorials/understanding-uri-redirects","content":"URI redirects Similar to how browsers can redirect from one URI to another, the Polywrap client can have custom URI redirects configured as well. For example, if we'd like to redirect all queries from the ens/api.helloworld.polywrap.eth URI to our own custom URI (ens/api.myhelloworld.eth , for example), we'd simply configure the client like so: const config = new ClientConfigBuilder() .addDefaults() .addRedirect(&quot;ens/api.helloworld.polywrap.eth&quot;, &quot;ens/api.myhelloworld.eth&quot;) .build(); const client = new PolywrapClient(config); caution The ens/api.myhelloworld.eth wrapper must fully implement the ens/api.helloworld.polywrap.eth schema.","keywords":""},{"title":"Understanding plugins","type":0,"sectionRef":"#","url":"/tutorials/understanding-plugins","content":"","keywords":""},{"title":"Default Plugin wrappers​","type":1,"pageTitle":"Understanding plugins","url":"/tutorials/understanding-plugins#default-plugin-wrappers","content":"The Polywrap client has a default configuration that enables developers to use the following plugins and the interfaces they implement: Logger Plugin wrap://ens/wraps.eth:logger@1.0.0 HTTP Plugin ens/wraps.eth:http@1.1.0ens/wraps.eth:http@1.0.0 FileSystem Plugin ens/wraps.eth:file-system@1.0.0 Concurrency Plugin ens/wraps.eth:concurrent@1.0.0 Ethereum Provider Plugin V1 ens/wraps.eth:ethereum-provider@1.1.0ens/wraps.eth:ethereum-provider@1.0.0 V2 ens/wraps.eth:ethereum-provider@2.0.0 "},{"title":"Configuring Plugins​","type":1,"pageTitle":"Understanding plugins","url":"/tutorials/understanding-plugins#configuring-plugins","content":"Some plugins, like the Ethereum Provider, require additional configuration in certain environments like the browser. We can configure the Ethereum Provider plugin to use MetaMask (or any other Ethereum JS provider) for its provider &amp; signer using the Client Config Builder: import { ClientConfigBuilder, IWrapPackage, PolywrapClient, } from &quot;@polywrap/client-js&quot;; import { Connection, Connections, ethereumProviderPlugin, } from &quot;@polywrap/ethereum-provider-js&quot;; // Enable Metamask const ethereum = (window as any).ethereum; await ethereum.request({ method: &quot;eth_requestAccounts&quot;, }); // Configure the Ethereum plugin w/ MetaMask const config = new ClientConfigBuilder() .addDefaults() .addPackages({ &quot;wrap://ens/wraps.eth:ethereum-provider@2.0.0&quot;: ethereumProviderPlugin({ connections: new Connections({ networks: { goerli: new Connection({ provider: ethereum, }), }, defaultNetwork: &quot;goerli&quot;, }), }) as IWrapPackage, }) .build(); const client = new PolywrapClient(config);  "},{"title":"Running Workflows","type":0,"sectionRef":"#","url":"/tutorials/workflows/running-workflows","content":"","keywords":""},{"title":"Writing workflows​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/workflows/running-workflows#writing-workflows","content":"A workflow consists of a tree of Jobs and Steps. A Job is an independent, named unit that can contain an array of Steps named steps and/or a set of sub-Jobs named jobs. Each Job runs asynchronously, and therefore Jobs may run in any order. Although all the sub-jobs are guaranteed to be executed after the parent job completes. Outputs of the parent jobs can be referenced as the input of any of its sub-jobs. By default, test will run all jobs in a workflow. A Job index can be provided to test to execute a specific job. A Step is a wrapper invocation. An array of Steps runs synchronously--i.e. in the order defined in the workflow. The result of a Job or Step can be passed as an input argument to a Job or Step that is its child in the tree hierarchy. SchemaExample name: # name of the workflow jobs: # a set of one or more jobs case1: # a job, named by the user steps: # an array of steps - uri: fs/build # uri of invocation method: query # method to invoke args: # method arguments  "},{"title":"Workflow output​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/workflows/running-workflows#workflow-output","content":"The output of a workflow can be written as a file in the JSON or YAML format with the output-file option of the Polywrap CLI'stest command. Workflow output is printed to the console by default. Console output can be suppressed with the quiet option of the Polywrap CLI's test command. "},{"title":"Workflow Validation","type":0,"sectionRef":"#","url":"/tutorials/workflows/workflow-validation","content":"","keywords":""},{"title":"CUE​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/workflows/workflow-validation#cue","content":"Validation files are written in CUE, an open-source data validation language. It has a simple syntax and is easy to use. CUE provides flexible data validation, including: matching exact valuesmatching typesmatching bounds (e.g. result &gt; 2)matching regular expressions To validate a workflow, you must have CUE installed on your computer. "},{"title":"Writing a validation script​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/workflows/workflow-validation#writing-a-validation-script","content":"A validation script should match the structure of the workflow it seeks to validate. It is compared against the output of the workflow. tip To validate a particular job in a workflow, your validation file should be modified to match the output of that particular job. The json-rpc demo uses aworkflow andvalidator to replicate its full integration test suite. We've provided a sample workflow and validation script based on the json-rpc demo here: workflow.yamlvalidator.cue name: json-rpc jobs: case1: steps: - uri: fs/build method: query args: url: &quot;https://archival-rpc.testnet.near.org&quot; request: method: &quot;gas_price&quot; params: &quot;[93019381]&quot; id: &quot;1&quot;  "},{"title":"Wrapper Schema","type":0,"sectionRef":"#","url":"/tutorials/wrapper-schema","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#declaration","content":"A wrapper project's schema must be declared in the project manifest (Polywrap Manifest or Plugin Manifest). source: module: ./src/index.ts schema: ./src/schema.graphql  "},{"title":"Codegen​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#codegen","content":"The wrapper schema tells the Polywrap compiler which types and serialization logic to generate. Generated types are updated every time you build the wrapper. The polywrap CLI also provides a codegen command to quickly update the generated wrap folder where generated types are stored. The Polywrap compiler generates types for method arguments and custom schema types. Wrapper developers must use the generated method arguments for methods declared in the schema, and generated types for method return values when the return value is of a custom type. The generated types come with serialization logic that allows Wrappers to communicate with the client. The following example demonstrates this practice. DeclarationImplementation type Module { sampleMethod(arg: String!): SampleResult! } type SampleResult { result: String! }  "},{"title":"Language Syntax​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#language-syntax","content":"Wrapper schemas are written in Polywrap's variant of the GraphQL schema definition language (SDL). Polywrap's GraphQL variant is simpler than standard GraphQL and easy to learn. "},{"title":"Custom Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#custom-types","content":"Custom types are declared with the type keyword. They can be given any number of properties. Properties can be of any supported type, including other custom types. type CustomType { myString: String! myObject: AnotherType! } type AnotherType { myInt: Int! }  "},{"title":"Nullability​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#nullability","content":"As in standard GraphQL, properties, method arguments, and method return values are declared non-nullable by appending a ! at the end of the type name. The absence of a ! indicates that a value is nullable. type CustomType { nullable: String # can be String or null nonNullable: String! # must be String }  "},{"title":"Methods​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#methods","content":"Methods are declared within the Module type. Methods must return a value. type Module { foo( arg: CustomType! bar: CustomType ): ReturnType! }  Custom types and modules can be imported from other wrappers by placing an import statement at the top of the schema. Imports become available in the schema immediately and in the wrapper following codegen. "},{"title":"Imports​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#imports","content":"Imported types and modules must be assigned a namespace. References to them are prepended with the namespace. #import { Module, CustomType } into Namespace from &quot;wrap://authority/path&quot; type CustomType { prop: Namespace_CustomType! }  "},{"title":"Example​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#example","content":"The following example uses all of the elements we've discussed so far. #import { Module, Connection } into Ethereum from &quot;wrap://ens/wraps.eth:ethereum@2.0.0&quot; #import { Module } into Ipfs from &quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot; type Module { # methods are declared in type Module getIpfsData( address: String! # types ending with ! are non-nullable ipfsProvider: String! connection: Ethereum_Connection # imported types are used like local types ): String! setIpfsData( options: SetIpfsDataOptions! # custom types can be arguments ipfsProvider: String! connection: Ethereum_Connection ): SetIpfsDataResult! # custom types can be return values } type SetIpfsDataOptions { # custom types are declared with &quot;type&quot; keyword address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Default Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#default-types","content":"Polywrap's schema definition language supports three kinds of default types: Basic types like integers and stringsComplex types like BigInt and JSONGeneric types like Array and Map These types may be implemented differently in different programming languages. The language-specific implementations are clarified in each of the following sections. "},{"title":"Basic Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#basic-types","content":"Basic types include primitive types like integers and boolean values, as well as Strings and Bytes. SchemaClientWasm wrapper Schema Type\tDescriptionUInt\t32-bit unsigned integer UInt8\t8-bit unsigned integer UInt16\t16-bit unsigned integer UInt32\t32-bit unsigned integer Int\t32-bit signed integer Int8\t8-bit signed integer Int16\t16-bit signed integer Int32\t32-bit signed integer String\tUTF-8 string Boolean\tTrue or false stored as 1 byte Bytes\tArray of 8-bit unsigned integers "},{"title":"Complex Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#complex-types","content":"Complex types are represented as basic types to the Polywrap client and plugin wrappers. Within Wasm wrappers, they are implemented as classes or structs with behavior. For example, consider an application developer invoking a Wasm wrapper with the JavaScript client. If the invoked method requires an argument of type BigInt, the application developer will provide a stringrepresentation of an integer number to satisfy the argument. Within the wrapper, the string is deserialized into an instantion of the wrapper language's implementation of a BigInt. If the invoked method returns a BigInt, the wrapper will serialize the returned BigInt, which the client will then deserialize into a string before returning it to the application developer. SchemaClientWasm wrapper Schema Type\tDescriptionBigInt\tMultiple precision integer BigNumber\tMultiple precision float JSON\tJSON object "},{"title":"Generic Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#generic-types","content":"When using a generic type, with the exception of arrays, schema writers must add a directive annotation declaring its subtype(s). The directive takes the form @annotate(type: &quot;TypeName&lt;T\\&gt;&quot;), where T is the type of the subtype. The generic type and its subtype(s) can be independently nullable or non-nullable. The following example illustrates use of the generic type directive with the Map type. type Module { getKey( key: String! map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Int! returnMap( map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) }  Like complex types, the implementation of generic types can differ by language. SchemaClientWasm wrapper Schema Type\tDescription[Type]\tArray of elements. Map\tMap of key-value pairs. "},{"title":"Interfaces​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#interfaces","content":"A module can inherit the method declarations of any other module by using the implements keyword. A module that implements an interface in this manner is required to implement and export the interface module's declared methods. Similarly, a type can inherit the property declarations of any other type by using the implements keyword. If a type implements an interface, it inherits the interface type's property declarations as though the properties were declared explicitly. #import { Module, InterfaceType } into Interface from &quot;wrap://ens/interface.eth&quot; type Module implements Interface_Module { # declares methods of Interface_Module } type ImplementationType implements Interface_InterfaceType { # declares properties of Interface_InterfaceType }  "},{"title":"Environmental Variables​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#environmental-variables","content":"Wrapper developers can declare a map of environmental variables for application developers to provide. To use environmental variables, declare an Env type and add a directive to each schema method that will use it. You can learn how to access environmental variables in code by reading the Access Env in the module section of our Environmental Variables documentation for wrapper developers. "},{"title":"Declare the Env object​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#declare-the-env-object","content":"Environmental variables are declared in a custom type named Env. type Env { str: String! number: Int! bool: Boolean! }  "},{"title":"Add the @env directive​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#add-the-env-directive","content":"To access an Env object during a method invocation, add the @env directive to a method. The @env directive has one attribute that indicates whether the Env is required or optional. type Module { # App developers are required to provide Env to invoke this method methodRequireEnv( arg: String! ): String! @env(required: true) # Env is optional when invoking this method methodOptionalEnv( arg: String! ): String! @env(required: false) }  "}]