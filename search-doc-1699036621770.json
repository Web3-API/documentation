[{"title":"Available Clients","type":0,"sectionRef":"#","url":"/clients","content":"Available Clients A Client is any library that can resolve and invoke Wraps. While anyone can create their own Polywrap client, the Polywrap Foundation maintains a number of core clients for the most common use cases. Environment\tGithub\tReference docsJavascript/Typescript\tJavascript client repository\tJS/TS client reference documentation Rust\tRust client repository\tRust client reference documentation Python\tPython client repository\tPython client reference documentation Kotlin/Android\tKotlin client repository\tKotlin client reference documentation Swift/iOS\tSwift client repository\tSwift client reference documentation Other clients: Polywrap Go Client","keywords":""},{"title":"ABI","type":0,"sectionRef":"#","url":"/concepts/abi","content":"ABI In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user. In the context of Polywrap, an ABI refers to the interface a Wrap provides. It defines invokable methods and types found within the Wrap. The Wrap Manifest file (wrap.info) contains, among other things, the Wrap's ABI, which comes as a msgpack-encoded schema of the Wrap.","keywords":""},{"title":"URI redirects","type":0,"sectionRef":"#","url":"/concepts/uri-redirects","content":"URI redirects Similar to how browsers can redirect from one URI to another, the Polywrap client can have custom URI redirects configured as well. For example, if we'd like to redirect all queries from the ens/api.helloworld.polywrap.eth URI to our own custom URI (ens/api.myhelloworld.eth , for example), we'd simply configure the client like so: const config = new ClientConfigBuilder() .addDefaults() .addRedirect(&quot;ens/api.helloworld.polywrap.eth&quot;, &quot;ens/api.myhelloworld.eth&quot;) .build(); const client = new PolywrapClient(config); caution The ens/api.myhelloworld.eth wrapper must fully implement the ens/api.helloworld.polywrap.eth schema.","keywords":""},{"title":"Environmental variables","type":0,"sectionRef":"#","url":"/concepts/env-variables","content":"","keywords":""},{"title":"Schema declaration​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#schema-declaration","content":"To use environmental variables, wrapper developers must first declare an Env type and add the @env directive to methods in the Wrapper Schema. You can learn more about the schema declarations in the Environmental Variables section of the Wrapper Schema documentation. type Env { str: String! } type Module { foo( arg: String! ): String! @env(required: true) }  "},{"title":"Access Env in the module​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#access-env-in-the-module","content":"Environmental variables can be used in both plugin wrappers and Wasm wrappers. "},{"title":"Env in plugin wrappers​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#env-in-plugin-wrappers","content":"Plugin wrapper developers can access the Env instance as a class property. const env: Env = this.env;  "},{"title":"Env in wasm wrappers​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#env-in-wasm-wrappers","content":"Wasm wrapper developers can access the Env instance by accepting the Env as a second argument in their module's methods. When an application developer invokes the method, the environmental variables they set in their ClientConfig will be provided. AssemblyScriptRust export class Module extends ModuleBase { // App developers are required to provide Env to invoke this method methodRequireEnv(_: Args_methodRequireEnv, env: Env): Env { return env; } // Env is optional when invoking this method methodOptionalEnv(_: Args_methodOptionalEnv, env: Env | null): Env | null { return env ? (env as Env) : null; } }  "},{"title":"Plugins","type":0,"sectionRef":"#","url":"/concepts/plugins","content":"","keywords":""},{"title":"Default Plugin wrappers​","type":1,"pageTitle":"Plugins","url":"/concepts/plugins#default-plugin-wrappers","content":"The Polywrap client has a default configuration that enables developers to use the following plugins and the interfaces they implement: Logger Plugin wrap://ens/wraps.eth:logger@1.0.0 HTTP Plugin ens/wraps.eth:http@1.1.0ens/wraps.eth:http@1.0.0 FileSystem Plugin ens/wraps.eth:file-system@1.0.0 Concurrency Plugin ens/wraps.eth:concurrent@1.0.0 Ethereum Provider Plugin V1 ens/wraps.eth:ethereum-provider@1.1.0ens/wraps.eth:ethereum-provider@1.0.0 V2 ens/wraps.eth:ethereum-provider@2.0.0 "},{"title":"Configuring Plugins​","type":1,"pageTitle":"Plugins","url":"/concepts/plugins#configuring-plugins","content":"Some plugins, like the Ethereum Provider, require additional configuration in certain environments like the browser. We can configure the Ethereum Provider plugin to use MetaMask (or any other Ethereum JS provider) for its provider &amp; signer using the Client Config Builder: import { ClientConfigBuilder, IWrapPackage, PolywrapClient, } from &quot;@polywrap/client-js&quot;; import { Connection, Connections, ethereumProviderPlugin, } from &quot;@polywrap/ethereum-provider-js&quot;; // Enable Metamask const ethereum = (window as any).ethereum; await ethereum.request({ method: &quot;eth_requestAccounts&quot;, }); // Configure the Ethereum plugin w/ MetaMask const config = new ClientConfigBuilder() .addDefaults() .addPackages({ &quot;wrapscan.io/polywrap/ethereum-wallet@1.0&quot;: ethereumProviderPlugin({ connections: new Connections({ networks: { goerli: new Connection({ provider: ethereum, }), }, defaultNetwork: &quot;goerli&quot;, }), }) as IWrapPackage, }) .build(); const client = new PolywrapClient(config);  "},{"title":"URIs","type":0,"sectionRef":"#","url":"/concepts/uris","content":"URIs Deployed wrappers are identified using custom URIs (Uniform Resource Identifier) called WRAP URIs. For example: wrap://ens/api.helloworld.polywrap.eth WRAP URIs follow the WRAP URI Standard. WRAP URIs have 3 parts: a protocol, an authority, and a path. Scheme​ WRAP URIs use the wrap scheme. Including wrap:// in your URI is optional in practice. Authority​ The Authority is used to denote which underlying protocol/standard the URI is part of. Usually, during URI resolution, the Polywrap Client will have at least one URI Resolver for each Authority used. For example: ens/ for resolving ENS domainsipfs/ for resolving IPFS contentfs/ for resolving content on the local filesystemhttp/ for resolving content via HTTP Path​ This is simply everything that comes after the Authority, and defines the unique resource we are trying to resolve. For example: api.domain.eth for an ENS domainQmaLbZnnnHbcRRo3wNBQ2MhugmBGL9R2YYeBvj6Nk2QumP for an IPFS file/directory./build for a local directoryexample.com/my-wrapper.wasm for a Wrap downloadable over HTTP tip ens/ and ipfs/ URI resolution is supported in all Polywrap clients by default. Adding custom URI resolvers is possible. More documentation on how to do this will be released soon.","keywords":""},{"title":"Wraps","type":0,"sectionRef":"#","url":"/concepts/wraps","content":"Wraps Wraps are at the core of Polywrap - they are the portable, executable modules that can be called by any Polywrap Client. They are WASM modules accompanied by a manifest file which describes said module. A Wrap consists of at least the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions) - wrap.wasmA Wrap Manifest file that orchestrates the wrapper, and provides types and parameters for the module functions (it's ABI) - wrap.info Additional files can be present in a Wrap (e.g. metadata files), but these are not required for a Wrap to be valid.","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"/faq","content":"","keywords":""},{"title":"What is Polywrap?​","type":1,"pageTitle":"FAQ","url":"/faq#what-is-polywrap","content":"Polywrap is a framework for portable and composable SDKs. Polywrap calls these SDKs “wraps”. Wraps are WebAssembly (Wasm) modules with superpowers--every wrap contains auto-generated, standardized bindings that enable communication between modules and a host language. The Wasm modules are fully composable, meaning any two wraps can call each others' methods even when their source codes were written in different languages. When used with any Polywrap Client written for any host language, all the effort involved in marshaling data between the host language and the Wasm module is handled for you, automagically. The Polywrap client handles invocations between the user and Wasm modules, and also between the modules when the modules invoke each other. Polywrap abstracts away the complexity, providing users a seamless user experience that closely resembles the native experience of their favorite high-level programming language. "},{"title":"What are wraps?​","type":1,"pageTitle":"FAQ","url":"/faq#what-are-wraps","content":"Wraps are simply WebAssembly binaries built with Polywrap and packaged with specific metadata that allows clients to run them. "},{"title":"How are wraps run?​","type":1,"pageTitle":"FAQ","url":"/faq#how-are-wraps-run","content":"Wraps are run by clients. Clients will fetch a wrap and execute it locally in the context of the application. Clients exist in a variety of languages: JavaScript, Rust, Python, etc. "},{"title":"How does this execution happen?​","type":1,"pageTitle":"FAQ","url":"/faq#how-does-this-execution-happen","content":"In a nutshell, wrap execution follows these steps: The application requests the execution of a wrapInternally, the client: Fetches the requested wrapExecutes the wrap's function inside a WebAssembly runtime The client returns the result of the wrap's function call back to the application Or, if you prefer diagrams:  "},{"title":"Where do wraps come from?​","type":1,"pageTitle":"FAQ","url":"/faq#where-do-wraps-come-from","content":"Wraps can be bundled with the application, or loaded from external sources: file storage, the Internet, you name it. Clients allows developers to configure this. "},{"title":"Who/what can use wraps?​","type":1,"pageTitle":"FAQ","url":"/faq#whowhat-can-use-wraps","content":"Wraps are used within apps and other wraps. They are defined via their metadata, which allows apps to integrate wraps, and wraps to import other wraps. "},{"title":"Why wraps?​","type":1,"pageTitle":"FAQ","url":"/faq#why-wraps","content":"Wraps can run and live anywhere: Clients exist in many languages.Wraps can be bundled with apps or downloaded when needed. Wraps can call other wraps: Wrap metadata is imported at built-time.Wrap code is executed at run-time. Wraps help secure your app: They execute in a secure WebAssembly environment.They don't have direct access to their host environment. "},{"title":"How do I access host capabilities?​","type":1,"pageTitle":"FAQ","url":"/faq#how-do-i-access-host-capabilities","content":"Polywrap has a plugin system that enables application developers to allow access to host capabilities. Wraps can call host functions defined in plugins. Plugins are also infused with Polywrap superpowers--bindings that allow them to appear to the Polywrap client and be invoked just like a wrap. Unlike wraps, plugins are not portable. Plugins are written in a Polywrap Client's native language and must be registered with the client at runtime. "},{"title":"Can I write my own plugins?​","type":1,"pageTitle":"FAQ","url":"/faq#can-i-write-my-own-plugins","content":"Yes, you can write any host capabilities you need as plugins in your application’s language. Polywrap also provides a set of basic plugins out-of-the-box: FilesystemHTTP/SEthereum wallet connectionLogging "},{"title":"How should I get started?​","type":1,"pageTitle":"FAQ","url":"/faq#how-should-i-get-started","content":"To execute your first wrap, follow one of our Quick Start guides: Javascript/TypescriptRustPythonKotlinSwift "},{"title":"WASM","type":0,"sectionRef":"#","url":"/concepts/wasm","content":"WASM WASM (WebAssembly) is a binary instruction format designed to provide a portable and efficient target for the compilation of high-level programming languages such as C, C++, Rust, and others. It is a low-level, virtual machine-based format that is designed to be executed in web browsers, but can also be used in other contexts. WASM allows web developers to write web applications in languages other than JavaScript, while still being able to execute them in the browser. This provides a number of benefits, including better performance, improved security, and the ability to reuse existing code. In the context of Polywrap, WASM is used as the underlying technology to provide a secure, portable and efficient way to run Wraps. Polywrap loads and executs Wraps written in WASM, providing a sandboxed environment that ensures that the Wraps cannot interfere with the host application or other Wraps.","keywords":""},{"title":"Wrap Schema","type":0,"sectionRef":"#","url":"/concepts/wrap-schema","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#declaration","content":"A wrap project's schema must be declared in the project manifest (Polywrap Manifest or Plugin Manifest). source: module: ./src/index.ts schema: ./src/schema.graphql  "},{"title":"Codegen​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#codegen","content":"The wrap schema tells the Polywrap compiler which types and serialization logic to generate. Generated types are updated every time you build the wrap. The Polywrap CLI also provides a codegen command to quickly update the generated wrap folder where generated types are stored. The Polywrap compiler generates types for method arguments and custom schema types. Wrap developers must use the generated method arguments for methods declared in the schema, and generated types for method return values when the return value is of a custom type. The generated types come with serialization logic that allows Wraps to communicate with the client. The following example demonstrates this practice. DeclarationImplementation type Module { sampleMethod(arg: String!): SampleResult! } type SampleResult { result: String! }  "},{"title":"Language Syntax​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#language-syntax","content":"Wrap schemas are written in Polywrap's variant of the GraphQL schema definition language (SDL). Polywrap's GraphQL variant is simpler than standard GraphQL and easy to learn. "},{"title":"Custom Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#custom-types","content":"Custom types are declared with the type keyword. They can be given any number of properties. Properties can be of any supported type, including other custom types. type CustomType { myString: String! myObject: AnotherType! } type AnotherType { myInt: Int! }  "},{"title":"Nullability​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#nullability","content":"As in standard GraphQL, properties, method arguments, and method return values are declared non-nullable by appending a ! at the end of the type name. The absence of a ! indicates that a value is nullable. type CustomType { nullable: String # can be String or null nonNullable: String! # must be String }  "},{"title":"Methods​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#methods","content":"Methods are declared within the Module type. Methods must return a value. type Module { foo( arg: CustomType! bar: CustomType ): ReturnType! }  Custom types and modules can be imported from other wraps by placing an import statement at the top of the schema. Imports become available in the schema immediately and in the wrap following codegen. "},{"title":"Imports​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#imports","content":"Imported types and modules must be assigned a namespace. References to them are prepended with the namespace. #import { Module, CustomType } into Namespace from &quot;wrap://authority/path&quot; type CustomType { prop: Namespace_CustomType! }  "},{"title":"Example​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#example","content":"The following example uses all of the elements we've discussed so far. #import { Module, Connection } into Ethereum from &quot;wrap://ens/wraps.eth:ethereum@2.0.0&quot; #import { Module } into Ipfs from &quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot; type Module { # methods are declared in type Module getIpfsData( address: String! # types ending with ! are non-nullable ipfsProvider: String! connection: Ethereum_Connection # imported types are used like local types ): String! setIpfsData( options: SetIpfsDataOptions! # custom types can be arguments ipfsProvider: String! connection: Ethereum_Connection ): SetIpfsDataResult! # custom types can be return values } type SetIpfsDataOptions { # custom types are declared with &quot;type&quot; keyword address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Default Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#default-types","content":"Polywrap's schema definition language supports three kinds of default types: Basic types like integers and stringsComplex types like BigInt and JSONGeneric types like Array and Map These types may be implemented differently in different programming languages. The language-specific implementations are clarified in each of the following sections. "},{"title":"Basic Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#basic-types","content":"Basic types include primitive types like integers and boolean values, as well as Strings and Bytes. SchemaClientWasm wrap Schema Type\tDescriptionUInt\t32-bit unsigned integer UInt8\t8-bit unsigned integer UInt16\t16-bit unsigned integer UInt32\t32-bit unsigned integer Int\t32-bit signed integer Int8\t8-bit signed integer Int16\t16-bit signed integer Int32\t32-bit signed integer String\tUTF-8 string Boolean\tTrue or false stored as 1 byte Bytes\tArray of 8-bit unsigned integers "},{"title":"Complex Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#complex-types","content":"Complex types are represented as basic types to the Polywrap client and plugin wraps. Within Wasm wraps, they are implemented as classes or structs with behavior. For example, consider an application developer invoking a Wasm wrap with the JavaScript client. If the invoked method requires an argument of type BigInt, the application developer will provide a stringrepresentation of an integer number to satisfy the argument. Within the wrap, the string is deserialized into an instantion of the wrap language's implementation of a BigInt. If the invoked method returns a BigInt, the wrap will serialize the returned BigInt, which the client will then deserialize into a string before returning it to the application developer. SchemaClientWasm wrap Schema Type\tDescriptionBigInt\tMultiple precision integer BigNumber\tMultiple precision float JSON\tJSON object "},{"title":"Generic Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#generic-types","content":"When using a generic type, with the exception of arrays, schema writers must add a directive annotation declaring its subtype(s). The directive takes the form @annotate(type: &quot;TypeName&lt;T\\&gt;&quot;), where T is the type of the subtype. The generic type and its subtype(s) can be independently nullable or non-nullable. The following example illustrates use of the generic type directive with the Map type. type Module { getKey( key: String! map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Int! returnMap( map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) }  Like complex types, the implementation of generic types can differ by language. SchemaClientWasm wrap Schema Type\tDescription[Type]\tArray of elements. Map\tMap of key-value pairs. "},{"title":"Interfaces​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#interfaces","content":"A module can inherit the method declarations of any other module by using the implements keyword. A module that implements an interface in this manner is required to implement and export the interface module's declared methods. Similarly, a type can inherit the property declarations of any other type by using the implements keyword. If a type implements an interface, it inherits the interface type's property declarations as though the properties were declared explicitly. #import { Module, InterfaceType } into Interface from &quot;wrap://ens/interface.eth&quot; type Module implements Interface_Module { # declares methods of Interface_Module } type ImplementationType implements Interface_InterfaceType { # declares properties of Interface_InterfaceType }  "},{"title":"Environmental Variables​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#environmental-variables","content":"Wrap developers can declare a map of environmental variables for application developers to provide. To use environmental variables, declare an Env type and add a directive to each schema method that will use it. You can learn how to access environmental variables in code by reading the Access Env in the module section of our Environmental Variables documentation for wrap developers. "},{"title":"Declare the Env object​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#declare-the-env-object","content":"Environmental variables are declared in a custom type named Env. type Env { str: String! number: Int! bool: Boolean! }  "},{"title":"Add the @env directive​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#add-the-env-directive","content":"To access an Env object during a method invocation, add the @env directive to a method. The @env directive has one attribute that indicates whether the Env is required or optional. type Module { # App developers are required to provide Env to invoke this method methodRequireEnv( arg: String! ): String! @env(required: true) # Env is optional when invoking this method methodOptionalEnv( arg: String! ): String! @env(required: false) }  "},{"title":"Javascript","type":0,"sectionRef":"#","url":"/quick-start/javascript","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client. "},{"title":"NodeJS application boilerplate​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#nodejs-application-boilerplate","content":"We'll be using a simple NodeJS application boilerplate for this guide. Using npm init or yarn init within a directory initialize an empty NodeJS project. Within package.json, change the type of the project to &quot;module&quot;. This is not required as you can also use require. package.json { &quot;name&quot;: &quot;my-app-name&quot;, //... &quot;type&quot;: &quot;module&quot;, //... }  Add an index.js file with the following code: index.js async function main() { // your code goes here... } main() .then(() =&gt; { process.exit(0); }) .catch((error) =&gt; { console.error(error); process.exit(1); });  "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#install-the-polywrap-client","content":"Using NPM: npm install --save @polywrap/client-js  Using yarn: yarn add @polywrap/client-js  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your index.js file, import the PolywrapClient and instantiate it: index.js import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  At this point, you can already invoke Wraps! In the simple example below, we will invoke the SHA3 Wrap within our main function:  const result = await client.invoke({ uri: &quot;wrapscan.io/polywrap/sha3@1.0&quot;, method: &quot;sha3_256&quot;, args: { message: &quot;Hello Polywrap!&quot;, }, }); console.log(result);  Running the application using node index.js, you should now see the following appear in your console: { ok: true, value: 'ba5a5d5fb7674f5975f0ecd0cd9a2f4bcadc9c04f5ac2ab3a887d8f10355fc38' }  Here we can see the structure of the InvokeResult object. It's ok field denotes whether the Wrap's invocation was successful, and the value is the return value of the invocation. What's going on here?​ Using the Polywrap Client, we are invoking the sha3_256 method of a Wrap found under the WRAP URI wrapscan.io/polywrap/sha3@1.0 called the SHA3 Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. The InvokeResult object​ The InvokeResult object can have one of two structures: A successful Wrap invocation returns { ok: true, value: ... } with value being the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation returns { ok: false, error: ... } with error describing the reason for invocation failure. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true power: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors.  const wethResult = await client.invoke({ uri: &quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if (!wethResult.ok) { throw wethResult.error; } console.log(&quot;WETH:&quot;, wethResult.value); const usdcResult = await client.invoke({ uri: &quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if (!usdcResult.ok) { throw usdcResult.error; } console.log(&quot;USDC:&quot;, usdcResult.value); const poolAddressResult = await client.invoke({ uri: &quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;, method: &quot;getPoolAddress&quot;, args: { tokenA: wethResult.value, tokenB: usdcResult.value, fee: &quot;MEDIUM&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if (!poolAddressResult.ok) { throw poolAddressResult.error; } console.log(&quot;Pool address:&quot;, poolAddressResult.value);  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Javascript","url":"/quick-start/javascript#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. Visit Wrapscan and the awesome-polywrap repository to find a curated list of Wraps we and our community have developed. "},{"title":"Kotlin","type":0,"sectionRef":"#","url":"/quick-start/kotlin","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Kotlin","url":"/quick-start/kotlin#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client. "},{"title":"Kotlin application boilerplate​","type":1,"pageTitle":"Kotlin","url":"/quick-start/kotlin#kotlin-application-boilerplate","content":"We'll be using a simple console application written in Kotlin for this guide. You can either set up a new application through an IDE of your choice, or use gradle to initialize a project. If using gradle, all you need to do is run gradle init within your project folder. Make sure to: Select kotlin as your implementation languageUse Kotlin as your build script DSLUse a minimum target Java version of 17 Inside build.gradle.kts, you need to update your plugins and dependencies sections: build.gradle.kts plugins { id(&quot;org.jetbrains.kotlin.jvm&quot;) version &quot;1.9.0&quot; // The versions of the JVM and serialization plugins must be the same id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;1.9.0&quot; application } //... dependencies { // Add the polywrap-client and serialization dependency required by the Polywrap Client implementation(&quot;io.polywrap:polywrap-client:0.10.4&quot;) implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-core:1.5.1&quot;) }  Now you can use the Polywrap Client inside your Kotlin app! "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Kotlin","url":"/quick-start/kotlin#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your app's main file (usually App.kt), import the Polywrap Client: App.kt import io.polywrap.configBuilder.polywrapClient // Import of the Polywrap Client itself import io.polywrap.core.resolution.Uri // The Polywrap Client uses the Uri class for invocations  You can now instantiate the Polywrap Client with a default configuration within your main function: App.kt val client = polywrapClient { addDefaults() }  At this point, you can already invoke Wraps! In the simple example below, we will invoke the SHA3 Wrap within our main function: App.kt val result = client.invoke&lt;String&gt;( uri = Uri(&quot;wrapscan.io/polywrap/sha3@1.0&quot;), method = &quot;sha3_256&quot;, args = mapOf(&quot;message&quot; to &quot;Hello Polywrap!&quot;) ) if (result.isFailure) { throw result.exceptionOrNull()!! } println(result)  Running the application using ./gradlew run or through your IDE, you should now see the following appear in your console: Success(ba5a5d5fb7674f5975f0ecd0cd9a2f4bcadc9c04f5ac2ab3a887d8f10355fc38)  This is the InvokeResult object. It's isSuccess and isFailure properties denote whether the Wrap's invocation was successful, and we will see how to get the return value of the invocation in the next section. What's going on here?​ Using the Polywrap Client, we are invoking the sha3_256 method of a Wrap found under the WRAP URI wrapscan.io/polywrap/sha3@1.0 called the SHA3 Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. The InvokeResult object​ The InvokeResult is an alias of the stdlib Result object. On successful invocations, you can extract the return value of the invocation, while on errors you can extract the underlying wrap execution exception. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Kotlin","url":"/quick-start/kotlin#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true power: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors. App.kt val wethResult = client.invoke&lt;Map&lt;String, Any&gt;&gt;( uri = Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method = &quot;fetchToken&quot;, args = mapOf( &quot;address&quot; to &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, &quot;chainId&quot; to &quot;MAINNET&quot; ) ) // Log the invocation error and stop execution if the invocation fails println(wethResult.getOrThrow()) val usdcResult = client.invoke&lt;Map&lt;String, Any&gt;&gt;( uri = Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method = &quot;fetchToken&quot;, args = mapOf( &quot;address&quot; to &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;, &quot;chainId&quot; to &quot;MAINNET&quot; ) ) // Log the invocation error and stop execution if the invocation fails println(usdcResult.getOrThrow()) val poolAddressResult = client.invoke&lt;String&gt;( uri = Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method = &quot;getPoolAddress&quot;, args = mapOf( &quot;tokenA&quot; to wethResult.getOrDefault(null), &quot;tokenB&quot; to usdcResult.getOrDefault(null), &quot;fee&quot; to &quot;MEDIUM&quot; ) ) // Log the invocation error and stop execution if the invocation fails println(poolAddressResult.getOrThrow())  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Kotlin","url":"/quick-start/kotlin#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. Visit Wrapscan and the awesome-polywrap repository to find a curated list of Wraps we and our community have developed. "},{"title":"The Polywrap CLI","type":0,"sectionRef":"#","url":"/cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#installation","content":"info For all possible ways to install the Polywrap CLI, please refer to its README. There are two main ways to install the Polywrap CLI: If you're developing in Javascript/Typescript and using Node, you can install the CLI globally: npm i -g polywrap  Alternatively, you can use the standalone version by downloading and running its install script: $ sh &lt;(curl https://raw.githubusercontent.com/polywrap/cli/origin-dev/install.sh) # Installs to `~/.polywrap` # If polywrap is already installed, the script instead checks for updates  "},{"title":"Overview​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#overview","content":"The Polywrap CLI allows us not only to build, test, and deploy Wraps, but also generate types for our applications which use the Polywrap Client. This tutorial assumes that you installed polywrap globally. You can see all available commands by running: polywrap help  "},{"title":"Create a Polywrap-powered application​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#create-a-polywrap-powered-application","content":"Polywrap allows you to integrate wraps into your app in a type-safe manner for supported languages. Currently, Polywrap has type-safety support for: TypescriptRustPythonKotlinSwift The Polywrap CLI allows you to create a template project in any of these languages with type safety built in. Let's start with creating a new project using the Polywrap CLI: TypescriptRustPythonKotlin/AndroidSwift/iOS polywrap create app typescript my-app  This will create a basic application in the language of your choice. There are two key files we want to take a look at, which define our Polywrap-powered project and allow us to perform code generation for type-safety. Let's take a look at them: "},{"title":"The Polywrap Manifest (polywrap.yaml)​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#the-polywrap-manifest-polywrapyaml","content":"In order for the Polywrap CLI to know what kind of project it's working with, it needs a Polywrap Manifest file to obtain some basic information about your project. This is the polywrap.yaml file. It has a structure similar to this: TypescriptRustPythonKotlin/AndroidSwift/iOS polywrap.yaml format: 0.5.0 project: name: Sample type: app/typescript source: schema: ./polywrap.graphql  The format property denotes the version of the Polywrap Manifest format. Under project, you can set the name field to the name of your application, while the type field describes the project type, thus letting the CLI know how to interact with the application code. Under the source section, we have a schema field with a path that leads to a Schema file. "},{"title":"The Schema File (polywrap.graphql)​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#the-schema-file-polywrapgraphql","content":"Every Polywrap project has a Schema file - it defines the types found within the project, what Wraps the project imports, and, in the context of a Wrap project, the methods that Wrap exposes. In the context of an application project, the Schema file defines which Wraps our application imports and is used by the CLI to generate code with which we can invoke our Wraps in a type-safe manner. Taking a look at the file, we can see import statements: TypescriptRustPythonKotlin/AndroidSwift/iOS polywrap.graphql #import * into Logging from &quot;wrapscan.io/polywrap/logging@1&quot; #import * into Ethers from &quot;wrapscan.io/polywrap/ethers@1.0&quot;  An import statement defines which Wraps we are importing, therefore using within our application. "},{"title":"Generating types (codegen)​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#generating-types-codegen","content":"Now that we know how we can &quot;import&quot; Wraps into our application, we can use the codegen command inside the Polywrap CLI to generate types that represent our Wraps which we can use within our application. To generate types, all we need to do is run the codegen command inside our project's root directory: polywrap codegen  This will generate types inside a wrap directory which you will be able to import within your application. "},{"title":"Introduce type-safety into your code​","type":1,"pageTitle":"The Polywrap CLI","url":"/cli#introduce-type-safety-into-your-code","content":"Now that we have our types generated, we can take a look at our sample application's main file. Let's first take a look at some of the imports: TypescriptRustPythonKotlin/AndroidSwift/iOS index.ts import { Ethers, Logging } from &quot;./wrap&quot;;  Here we can see that we've imported Module types that represent our Wraps, according to their specified namespace. Using these types, we can invoke our Wraps in a type-safe manner, without having to repeatedly specify the Wrap URI or do any guesswork regarding invoke argument/return types: TypescriptRustPythonKotlin/AndroidSwift/iOS index.ts async function main() { console.log(&quot;Invoking: Logging.info(...)&quot;); const logger = new Logging(); await logger.info({ message: &quot;Hello there&quot;, }); await logger.info({ message: &quot;Hello again&quot;, }); await logger.info({ message: &quot;One last time...&quot;, }); console.log(&quot;Invoking: Ethereum.encodeParams(...)&quot;); const eth = new Ethers(); const result = await eth.encodeParams({ types: [&quot;address&quot;, &quot;uint256&quot;], values: [&quot;0xB1B7586656116D546033e3bAFF69BFcD6592225E&quot;, &quot;500&quot;], }); if (result.ok) { console.log(`Ethers.encodeParams:\\n${result.value}`); } else { console.log(`Error - Ethereum.encodeParams:\\n${result.error}`); } }  This allows us to write all of our code in a type-safe manner, and allows for IDEs like VS Code to give us autocompletion suggestions via IntelliSense. Now we can explore our Wraps by simply importing them and trying them out! "},{"title":"Python","type":0,"sectionRef":"#","url":"/quick-start/python","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Python","url":"/quick-start/python#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client. "},{"title":"NodeJS application boilerplate​","type":1,"pageTitle":"Python","url":"/quick-start/python#nodejs-application-boilerplate","content":"We'll be using a simple empty python file named program.py as our boilerplate. "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Python","url":"/quick-start/python#install-the-polywrap-client","content":"You can install the Polywrap client using pip: pip install polywrap  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Python","url":"/quick-start/python#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your program.py file, import the PolywrapClient and instantiate it: program.py from polywrap import ( Uri, # Required to construct a valid wrap URI PolywrapClient, # The client itself PolywrapClientConfigBuilder, sys_bundle, web3_bundle, ) builder = PolywrapClientConfigBuilder().add_bundle(sys_bundle).add_bundle(web3_bundle) config = builder.build() client = PolywrapClient(config)  At this point, you can already invoke Wraps! In the simple example below, we will invoke the SHA3 Wrap: program.py result = client.invoke( uri=Uri.from_str(&quot;wrapscan.io/polywrap/sha3@1&quot;), method=&quot;sha3_256&quot;, args={ &quot;message&quot;: &quot;Hello Polywrap!&quot;, }, encode_result=False, ) print(result)  Running the application using python program.py, you should now see the following appear in your console: ba5a5d5fb7674f5975f0ecd0cd9a2f4bcadc9c04f5ac2ab3a887d8f10355fc38  This is the return value of our invocation. What's going on here?​ Using the Polywrap Client, we are invoking the sha3_256 method of a Wrap found under the WRAP URI wrapscan.io/polywrap/sha3@1.0 called the SHA3 Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. Invocation return value​ Invoking a wrap can result in one of two scenarios: A successful Wrap invocation returns the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation throws an exception describing the reason for invocation failure. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Python","url":"/quick-start/python#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true power: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors. program.py wethResult = client.invoke( uri=Uri.from_str(&quot;wrapscan.io/polywrap/uniswap-v3@1&quot;), method=&quot;fetchToken&quot;, args={ &quot;address&quot;: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, &quot;chainId&quot;: &quot;MAINNET&quot;, }, encode_result=False, ) print(wethResult) usdcResult = client.invoke( uri=Uri.from_str(&quot;wrapscan.io/polywrap/uniswap-v3@1&quot;), method=&quot;fetchToken&quot;, args={ &quot;address&quot;: &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;, &quot;chainId&quot;: &quot;MAINNET&quot;, }, encode_result=False, ) print(usdcResult) poolAddressResult = client.invoke( uri=Uri.from_str(&quot;wrapscan.io/polywrap/uniswap-v3@1&quot;), method=&quot;getPoolAddress&quot;, args={ &quot;tokenA&quot;: wethResult, &quot;tokenB&quot;: usdcResult, &quot;fee&quot;: &quot;MEDIUM&quot;, }, encode_result=False, ) print(poolAddressResult)  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Python","url":"/quick-start/python#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. Visit Wrapscan and the awesome-polywrap repository to find a curated list of Wraps we and our community have developed. "},{"title":"Plugin an existing JS SDK","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/create-js-plugin","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#introduction","content":"In this guide, we'll walk you through creating your own JavaScript-based plugin that can be added to the JavaScript Polywrap Client. caution Plugins do not retain all of Polywrap's benefits. We recommend re-writing your existing JavaScript SDKs as Wasm wraps if possible. As always, if you need any help, message us on Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#prerequisites","content":"You'll need the following installed before building your plugin: nvmyarn You'll be using TypeScript to implement your Polywrap plugin. tip In the future, TypeScript will be one of many supported languages for implementing plugins. As more Polywrap Clients are released in various languages, implementing plugins in those languages will be supported as well. "},{"title":"Getting started​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#getting-started","content":"To get started, use the following command to spin up a project folder for your plugin. npx polywrap create plugin typescript &lt;project-name&gt;  Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-plugin. Once complete, you'll see a new folder appear, named after the custom name you've chosen. Please navigate into this new directory (using cd for example). "},{"title":"Installation​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#installation","content":"Let's ensure all of your project's dependencies are installed. From inside your project's directory, simply run: nvm install &amp;&amp; nvm useyarn "},{"title":"Overview of project files​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#overview-of-project-files","content":"Your project should look something like this: polywrap.yaml # Plugin Manifest src/ | index.ts # Entry File │ schema.graphql # Schema  "},{"title":"polywrap.yaml​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#polywrapyaml","content":"The Plugin Project Manifest describes the layout of a plugin. "},{"title":"schema.graphql​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#schemagraphql","content":"Each wrap project has a Wrap Schema. The schema defines the wrap's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrap. "},{"title":"src/index.ts​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#srcindexts","content":"The index.ts file exports the wrap's method's implementations, which contain the plugin's logic. Learn more about the plugin's code architecture by reading Plugin Architecture "},{"title":"Building the plugin​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#building-the-plugin","content":"To build your plugin, all you need is the following command: yarn build # alias for &quot;npx polywrap build&quot;  "},{"title":"Example Plugins​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#example-plugins","content":"See Understanding Plugins for some examples of Plugins used within the default configuration of the Polywrap Client. "},{"title":"Configure a Plugin Manifest","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/plugin-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Plugin Manifest","url":"/tutorials/advanced/create-plugins/plugin-manifest#content","content":"The Plugin Manifest contains the name of the plugin, programming language used to write the plugin, the location of the plugin's entry file (i.e. the file that exports the plugin contents), and the GraphQl schema that declares the plugin's interface. SchemaExample format: # Polywrap manifest format version. Values: 0.3.0 project: # Basic project properties. name: # Name of this project. type: # Type of this project. source: # Project source files. module: # Path to the project's entry point. schema: # Path to the project's graphql schema. import_abis: # Specify ABIs to be used for the import URIs within your schema.  "},{"title":"Plugin Architecture","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/plugin-architecture","content":"","keywords":""},{"title":"Required Exports​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#required-exports","content":"A plugin must export a PluginFactory to be used by the Polywrap Client. A PluginFactory is a function that returns a PluginPackageManifest and a factory method that generates an instance of the plugin. "},{"title":"TypeScript Support​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#typescript-support","content":"The Polywrap CLI's codegen and build commands will generate a wrap folder containing useful types. The generated types will save you time and energy. You won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs. You can forget about boilerplate code and focus on your plugin's logic. While the types are not strictly required, we recommend them as a best practice. The generated types include: Module - An interface containing the methods declared in the plugin's schemaArgs_* - An interface for each method, containing the method arguments declared in the schemaCustom Types - An interface for each custom type declared in the schemamanifest - A PluginPackageManifest for the plugin (also useful for JavaScript developers!) "},{"title":"Example​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#example","content":"&quot;Example: import { Module, Args_sampleMethod, manifest } from &quot;./wrap&quot;; // imports from generated &quot;wrap&quot; folder import { PluginFactory, PluginPackage } from &quot;@polywrap/plugin-js&quot;; // plugin must export a PluginFactory export interface SamplePluginConfig { defaultValue: string; } export class SamplePlugin extends Module&lt;SamplePluginConfig&gt; { // Plugin inherits from Module constructor(config: SamplePluginConfig) { super(config); } public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument return args.data + this.config.defaultValue; } } export const samplePlugin: PluginFactory&lt;SamplePluginConfig&gt; = ( // exported PluginFactory is used by Polywrap client config: SamplePluginConfig ) =&gt; { return new PluginPackage( new SamplePlugin(config), // factory method produces a Module manifest // imported from ./wrap ); }; export const plugin = samplePlugin; // PluginFactory is exported with name &quot;plugin&quot;  "},{"title":"Rust","type":0,"sectionRef":"#","url":"/quick-start/rust","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client. "},{"title":"Rust application boilerplate​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#rust-application-boilerplate","content":"We'll be using a simple console application boilerplate for this guide. Using cargo init within a directory, initialize a Rust project. "},{"title":"Adding Polywrap to your application​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#adding-polywrap-to-your-application","content":"Within cargo.toml, add dependencies for polywrap and serde: cargo.toml [dependencies] polywrap = &quot;0.1.9-beta.2&quot; serde = { version = &quot;1.0.188&quot;, features = [&quot;derive&quot;] }  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your main.rs file, import polywrap: main.rs use polywrap::*;  Now, before invoking wraps, we need to define structs that describe the arguments we're passing to the invocation, and, if applicable, the invocation return types. In our first example, we will be invoking the sha3_256 function of the SHA3 Wrap, so we will define the following struct: main.rs #[derive(Serialize)] struct Sha3_256Args { message: String, }  Within our main function, we now want to initialize the Polywrap Client: main.rs let mut config = PolywrapClientConfig::new(); config .add(SystemClientConfig::default().into()) .add(Web3ClientConfig::default().into()); let client = PolywrapClient::new(config.build());  At this point, you can invoke Wraps! In the example below, we will invoke the SHA3 wrap within our main function: main.rs let result = client.invoke::&lt;String&gt;( &amp;uri!(&quot;wrapscan.io/polywrap/sha3@1.0&quot;), &quot;sha3_256&quot;, Some( &amp;to_vec(&amp;Sha3_256Args { message: &quot;test&quot;.to_string(), }) .unwrap(), ), None, None, ); match result { Ok(v) =&gt; println!(&quot;{}&quot;, v), Err(e) =&gt; panic!(&quot;{}&quot;, e), };  Running the application using cargo run, you should now see the following appear in your console: ba5a5d5fb7674f5975f0ecd0cd9a2f4bcadc9c04f5ac2ab3a887d8f10355fc38  This is the return value of our invocation. What's going on here?​ Using the Polywrap Client, we are invoking the sha3_256 method of a Wrap found under the WRAP URI wrapscan.io/polywrap/sha3@1.0 called the SHA3 Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. The invocation result​ The invoke function returns a Result enum, from which you can: Extract the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation returns an Err() describing the reason for invocation failure. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true power: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors. Again, before invoking, we want to define the structs we'll be using: main.rs #[derive(Serialize)] struct FetchTokenArgs { address: String, #[serde(rename = &quot;chainId&quot;)] chain_id: String, } #[derive(Serialize, Deserialize, Debug)] struct Currency { decimals: u32, symbol: String, name: String, } #[derive(Serialize, Deserialize, Debug)] struct Token { address: String, #[serde(rename = &quot;chainId&quot;)] chain_id: u32, currency: Currency, } #[derive(Serialize)] struct GetPoolAddressArgs { #[serde(rename = &quot;tokenA&quot;)] token_a: Token, #[serde(rename = &quot;tokenB&quot;)] token_b: Token, fee: String, }  After that, we can start using the Uniswap V3 Wrap within our main function: main.rs let weth_result = client.invoke::&lt;Token&gt;( &amp;uri!(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), &quot;fetchToken&quot;, Some( &amp;to_vec(&amp;FetchTokenArgs { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;.to_string(), chain_id: &quot;MAINNET&quot;.to_string(), }) .unwrap(), ), None, None, ); let weth = match weth_result { Ok(v) =&gt; { println!(&quot;WETH: {:#?}&quot;, v); v } Err(e) =&gt; panic!(&quot;{}&quot;, e), }; let usdc_result = client.invoke::&lt;Token&gt;( &amp;uri!(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), &quot;fetchToken&quot;, Some( &amp;to_vec(&amp;FetchTokenArgs { address: &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;.to_string(), chain_id: &quot;MAINNET&quot;.to_string(), }) .unwrap(), ), None, None, ); let usdc = match usdc_result { Ok(v) =&gt; { println!(&quot;USDC: {:#?}&quot;, v); v } Err(e) =&gt; panic!(&quot;{}&quot;, e), }; let pool_address_result = client.invoke::&lt;String&gt;( &amp;uri!(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), &quot;getPoolAddress&quot;, Some( &amp;to_vec(&amp;GetPoolAddressArgs { token_a: weth, token_b: usdc, fee: &quot;MEDIUM&quot;.to_string(), }) .unwrap(), ), None, None, ); match pool_address_result { Ok(v) =&gt; println!(&quot;Pool address: {}&quot;, v), Err(e) =&gt; panic!(&quot;{}&quot;, e), };  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Rust","url":"/quick-start/rust#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. Visit Wrapscan and the awesome-polywrap repository to find a curated list of Wraps we and our community have developed. "},{"title":"Swift","type":0,"sectionRef":"#","url":"/quick-start/swift","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client. "},{"title":"Swift Project setup​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#swift-project-setup","content":"We'll use a basic iOS App project as our template/boilerplate. Within ContentView.swift, add a button that will invoke a run function within its action and print any errors that may occur when executed: ContentView.swift import SwiftUI func run() throws -&gt; Void { print(&quot;Running...&quot;) // Your code will go here print(&quot;Done running!&quot;) } struct ContentView: View { var body: some View { VStack { Button(&quot;Run example&quot;, action: { do { try run() } catch { print(&quot;\\(error)&quot;) } }) } .padding() } }  "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#install-the-polywrap-client","content":"The Polywrap Client package is available via Swift Package Manager and Cocoapods. For detailed instructions on how to install the Polywrap Swift Client see the client's readme. We will install the Polywrap Client directly through XCode. Navigate to File -&gt; Add Package Dependency and enter https://github.com/polywrap/swift-client into the URL field. "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: Inside ContentView.swift, import the PolywrapClient package at the top of your file: ContentView.swift import SwiftUI import PolywrapClient  After this, inside the run function, initialize the Polywrap client: ContentView.swift let client = BuilderConfig() .addSystemDefault() .addWeb3Default() .build()  At this point, you can already invoke Wraps! In the simple example below, we will invoke the SHA3 Wrap within our run function: ContentView.swift let client = BuilderConfig() .addSystemDefault() .addWeb3Default() .build()  By clicking on the &quot;Run example&quot; button in the preview pane, you should now see the following appear in your console: ba5a5d5fb7674f5975f0ecd0cd9a2f4bcadc9c04f5ac2ab3a887d8f10355fc38  This is the return value of our invocation. What's going on here?​ Using the Polywrap Client, we are invoking the sha3_256 method of a Wrap found under the WRAP URI wrapscan.io/polywrap/sha3@1.0 called the SHA3 Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. Invocation return value​ Invoking a wrap can result in one of two scenarios: A successful Wrap invocation returns the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation throws an error describing the reason for invocation failure. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true power: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors.  // First we need to define our argument and return types for the fetchToken call struct FetchToken_Args : Codable { var address: String var chainId: String } struct Currency: Codable { var decimals: Int var symbol: String var name: String } struct Token: Codable { var address: String var chainId: Int var currency: Currency } // Fetch information about WETH let weth: Token = try client.invoke( uri: try Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method: &quot;fetchToken&quot;, args: FetchToken_Args( address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot; ) ) print(&quot;WETH: \\(weth)&quot;) let usdc: Token = try client.invoke( uri: try Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method: &quot;fetchToken&quot;, args: FetchToken_Args( address: &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;, chainId: &quot;MAINNET&quot; ) ) print(&quot;USDC: \\(usdc)&quot;) // Define our argument types for getPoolAddress struct GetPoolAddress_Args: Codable { var tokenA: Token var tokenB: Token var fee: String } let poolAddress: String = try client.invoke( uri: try Uri(&quot;wrapscan.io/polywrap/uniswap-v3@1.0&quot;), method: &quot;getPoolAddress&quot;, args: GetPoolAddress_Args( tokenA: weth, tokenB: usdc, fee: &quot;MEDIUM&quot; ) ) print(&quot;Pool address: \\(poolAddress)&quot;)  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Swift","url":"/quick-start/swift#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. Visit Wrapscan and the awesome-polywrap repository to find a curated list of Wraps we and our community have developed. "},{"title":"Define and implement interfaces","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/define-implement-interfaces","content":"","keywords":""},{"title":"Declaring an interface project​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#declaring-an-interface-project","content":"Interface projects are declared using a Polywrap Manifest. To indicate that a project is an abstract interface, set the project type to interface. Interface projects do not have a module. Only a schema path is declared. format: 0.3.0 project: name: UriResolver type: interface source: schema: ./src/schema.graphql  "},{"title":"Defining an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#defining-an-interface","content":"Defining an interface is as simple as writing the Wrap Schema. Once the schema is complete, you are ready to deploy the interface. "},{"title":"Implementing an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#implementing-an-interface","content":"As described in Wrap Schema, an interface can be imported and then implemented with the implements keyword. When a module implements an interface module, it inherits all of its method declarations. The URI Resolver Extensions plugins implement the URI Resolver interface and inherit its methods. ENS Resolver SchemaURI Resolver Schema #import { Module, MaybeUriOrManifest } into UriResolver from &quot;ens/wraps.eth:uri-resolver-ext@1.1.0&quot; #import { Module } into Ethereum from &quot;ens/wraps.eth:ethereum@2.0.0&quot; type Module implements UriResolver_Module {}  "},{"title":"Configure interfaces in the client","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/client-config-interfaces","content":"Configure interfaces in the client The Polywrap Client can be configured to use one or more implementations for an abstract interface. You can use the Client Config Builder to register implementations for an interface URI. const config = new ClientConfigBuilder() .addDefaults() .addInterfaceImplementations( &quot;wrap://ens/wrap.interface.eth&quot;, [ &quot;wrap://ens/wrap.implementation1.eth&quot;, &quot;wrap://ens/wrap.implementation2.eth&quot;, &quot;wrap://ens/wrap.implementation3.eth&quot;, ] ) .build(); ","keywords":""},{"title":"Interface instances","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/interface-instances","content":"","keywords":""},{"title":"Instantiating an interface​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#instantiating-an-interface","content":"After an interface is imported in your Wrap Schema, you can update the generated classes with the Polywrap CLI's codegen command. You will then be able to import the interface module in your wrap. To instantiate an interface module, you must provide a URI that resolves to a wrap that implements the interface. import { MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const instance = new MyInterface_Module(&quot;wrap://...&quot;); ... }  "},{"title":"Getting Interface Implementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#getting-interface-implementations","content":"To instantiate an interface agnostic to the implementation, you can use getImplementations to obtain a list of interface implementations registered in the Polywrap Client. "},{"title":"Declaring getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#declaring-getimplementations","content":"In addition to importing the interface module in the Wrap Schema, you must declare that getImplementations will be used for the interface with the use { getImplementations } keywords. #import { Module } into MyInterface from &quot;wrap://ens/interface.eth&quot; #use { getImplementations } for MyInterface  "},{"title":"Using getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#using-getimplementations","content":"Now you can import the interface namespace and call its getImplementations method. The getImplementations method returns an array of URI strings that can be used to instantiate the interface module. import { MyInterface, MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const impls = MyInterface.getImplementations(); if (impls.length &lt; 1) { throw new Error(&quot;...&quot;) } const instance = new MyInterface_Module(impls[0]); ... }  "},{"title":"Running Workflows","type":0,"sectionRef":"#","url":"/tutorials/advanced/workflows/running-workflows","content":"","keywords":""},{"title":"Writing workflows​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/advanced/workflows/running-workflows#writing-workflows","content":"A workflow consists of a tree of Jobs and Steps. A Job is an independent, named unit that can contain an array of Steps named steps and/or a set of sub-Jobs named jobs. Each Job runs asynchronously, and therefore Jobs may run in any order. Although all the sub-jobs are guaranteed to be executed after the parent job completes. Outputs of the parent jobs can be referenced as the input of any of its sub-jobs. By default, test will run all jobs in a workflow. A Job index can be provided to test to execute a specific job. A Step is a wrap invocation. An array of Steps runs synchronously--i.e. in the order defined in the workflow. The result of a Job or Step can be passed as an input argument to a Job or Step that is its child in the tree hierarchy. SchemaExample name: # name of the workflow jobs: # a set of one or more jobs case1: # a job, named by the user steps: # an array of steps - uri: fs/build # uri of invocation method: query # method to invoke args: # method arguments  "},{"title":"Workflow output​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/advanced/workflows/running-workflows#workflow-output","content":"The output of a workflow can be written as a file in the JSON or YAML format with the output-file option of the Polywrap CLI'stest command. Workflow output is printed to the console by default. Console output can be suppressed with the quiet option of the Polywrap CLI's test command. "},{"title":"Workflow Validation","type":0,"sectionRef":"#","url":"/tutorials/advanced/workflows/workflow-validation","content":"","keywords":""},{"title":"CUE​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/advanced/workflows/workflow-validation#cue","content":"Validation files are written in CUE, an open-source data validation language. It has a simple syntax and is easy to use. CUE provides flexible data validation, including: matching exact valuesmatching typesmatching bounds (e.g. result &gt; 2)matching regular expressions To validate a workflow, you must have CUE installed on your computer. "},{"title":"Writing a validation script​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/advanced/workflows/workflow-validation#writing-a-validation-script","content":"A validation script should match the structure of the workflow it seeks to validate. It is compared against the output of the workflow. tip To validate a particular job in a workflow, your validation file should be modified to match the output of that particular job. The json-rpc demo uses aworkflow andvalidator to replicate its full integration test suite. We've provided a sample workflow and validation script based on the json-rpc demo here: workflow.yamlvalidator.cue name: json-rpc jobs: case1: steps: - uri: fs/build method: query args: url: &quot;https://archival-rpc.testnet.near.org&quot; request: method: &quot;gas_price&quot; params: &quot;[93019381]&quot; id: &quot;1&quot;  "},{"title":"Deploy to IPFS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#polywrap-cli","content":"The polywrap CLI has a deploy command for publishing Wasm wraps to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wraps.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"Fleek​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#fleek","content":"Fleek makes it easy to build websites and apps on the new open web. &gt; Step-By-Step Guide "},{"title":"Pinata​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#pinata","content":"Pinata provides tools and infrastructure for all creators to easily create and manage content on IPFS. &gt; Step-By-Step Guide "},{"title":"Crust Network​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#crust-network","content":"Crust Network provides a Web3.0 decentralized storage network for the Metaverse. &gt; Step-By-Step Guide "},{"title":"Aleph​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#aleph","content":"Aleph allows your blockchain enabled app to securely access trusted off-chain data or computation within a couple lines of code. "},{"title":"Arweave​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#arweave","content":"Arweave enables you to store documents and applications forever. "},{"title":"Configure Polywrap deployment pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#declaration","content":"The location of the deployment manifest should be declared in your Polywrap Manifest polywrap.yaml with a field labeled deploy. deploy: ./polywrap.deploy.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#content","content":"The concents of a Deploy Manifest consists of one or more jobs with their steps, each of which has some common fields and a set of configuration options particular to the step's module. All jobs run in parallel, while steps of each job run in series. The result of a step can be passed as input to a later step using $$step_name. SchemaExample format: # The manifest format version primaryJobName: # Name of the job that runs the primary deployment sequence. jobs: # Each job describes series of events in the pipeline [name]: # Name of the job config: # configuration for all deployment modules, can be overridden within each step steps: # Each step describes an event in the pipeline - name: # The name of the step package: # Deployment module uri: # The wrap URI of source content depends_on: # (Optional) Use prior step's output config: # Configuration for the deployment module  "},{"title":"Deployment Modules​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#deployment-modules","content":"Polywrap currently supports three types of deployment modules: ipfs: pins a folder's contents to IPFS and returns the content hash (CID)ens: points an ENS domain to an IPFS content hashlocal-dev-ens: registers a domain on a local test environment and points the domain to an IPFS content hash "},{"title":"IPFS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#ipfs","content":"The IPFS module pins a folder's contents to IPFS and returns the content hash (CID). It can be used to deploy a wrap by pinning the contents of your project's build folder to the IPFS network. The IPFS module's custom configuration requires an IPFS gateway URI so the CLI knows where to send the files. Example: ipfs configuration config: gatewayUri: 'ipfs.wraps.io' # IPFS gateway URI  "},{"title":"ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#ens","content":"The ENS module accepts an IPFS content hash (CID) as input and points an ENS domain name to it. The ENS module's custom configuration requires three arguments and accepts an optional fourth: domainName: the ENS domain name owned by your Ethereum accountprovider: an Ethereum JSON RPC providerensRegistryAddress: the Ethereum address of the ENS Registry smart contractprivateKey: (optional) your Ethereum account's private key, used when the Ethereum provider cannot produce an account signer Example: ens configuration config: domainName: 'wrap.eth' # ENS domain name provider: 'http://localhost:4545' # an Ethereum JSON RPC provider URI ensRegistryAddress: '0x...' # The ENS Registry contract address privateKey: '' # a private key may be required to sign ethereum transactions  "},{"title":"Local Dev ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#local-dev-ens","content":"The Local Dev ENS module accepts an IPFS content hash (CID) as input, registers an ENS domain name, and points the domain name to the IPFS CID. The Local Dev ENS module was created with Polywrap's default test environment infrastructure in mind. tip Polywrap's default test environment can be started with the polywrap infra up eth-ens-ipfs CLI command and stopped with the polywrap infra down eth-ens-ipfs CLI command. The module assumes ENS infrastructure is set up on a local Ethereum network with the ENS smart contracts deployed at the following addresses: ENS Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbENS Resolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24ENS Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbENS Reverse Lookup: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C The Local Dev ENS module's custom configuration requires two arguments: domainName: the desired ENS domain name to be registeredports: contains the port of the local Ethereum test network Example: local-dev-ens configuration config: domainName: 'wrap.eth' # ENS domain name ports: ethereum: 4545  "},{"title":"Configure Polywrap build pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/build-pipeline","content":"","keywords":""},{"title":"Build pipeline​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#build-pipeline","content":"The build process begins by running the build command from the polywrap CLI. The command will first search for the Polywrap Manifest, find the wrap schema and implementation, and move these files into a Docker image. Within the docker image, the wrap schema is parsed and its contents are extracted into an ABI. The ABI is used to generate binding code for the wrap. The wrap is then compiled into a Wasm module. The ABI and the Polywrap Manifest are merged into a Wrap Manifest file called wrap.info. While the default build settings work well for many projects, the toolchain offers a highly configurable build pipeline for those who need more customization. "},{"title":"Build Manifest​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#build-manifest","content":"The Build Manifest polywrap.build.yaml file is the entry point to build pipeline configuration. "},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#declaration","content":"The location of the Build Manifest must be declared in your Polywrap Manifest with a field labeled build. If a custom build manifest is not declared, the default build configuration will be used. build: ./polywrap.build.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#content","content":"SchemaExampleDefault Configuration format: # Polywrap build manifest format version. Values: 0.3.0 strategies: # Custom build image configurations. image: # Docker image strategy configuration name: # Docker image name. dockerfile: # Docker image file name. buildx: # Configuration options for Docker Buildx, set to true for default value. removeImage: # Remove the image. local: # Local build strategy configuration scriptPath: # Custom script path for local build vm: # Docker VM strategy configuration baseImage: # Base image for the Docker VM defaultIncludes: # Files to include in build VM container, by default linked_packages: # Locally linked packages into docker build image. config: # General configurations.  "},{"title":"Customizing the Dockerfile​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#customizing-the-dockerfile","content":"Those who need to fully customize the Docker image build steps can customize the Dockerfile. The Dockerfile is a text file containing instructions for Docker to build images. You can learn more about it at Docker's Dockerfile documentation. To begin, either copy the default Dockerfile from the .polywrap/wasm/build/image folder or create your own. Then, in the polywrap.build.yaml file, add a key called dockerfile with the path of the newly created Dockerfile as the value. That's it! Now, you can customize the Dockerfile to your heart's content. format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile  "},{"title":"Mustache support​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#mustache-support","content":"Mustache is a logic-less template system that can be used for HTML, config files, and more. You can learn more about writing Mustache templates here. To enable Mustache capabilities for your Dockerfile, name your custom Dockerfile with a .mustache file extension: dockerfile: ./Dockerfile.mustache  With Mustache, your Dockerfile will be able to recognize variable tags set within the config field of the Build Manifest. For example, in your Build Manifest file, you could have a key such as foo with the value hey like so: format: 0.3.0 docker: name: build-env dockerfile: ./Dockerfile.mustache config: foo: hey strategies: image: name: build-env dockerfile: ./Dockerfile.mustache node_version: 16.13.0 include: - ./package.json buildx: keepBuilder: false  To use this variable in your Mustache-enabled Dockerfile, simply reference the variable with curly braces like so: {{ foo }}  "},{"title":"Deploying to CRUST Files","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/crust","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrap using the Crust Files. so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to Crust NetworkStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 👛 Metamask🥐 Crust Network🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  "},{"title":"Step 4. Upload the build folder to Crust Network​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-4-upload-the-build-folder-to-crust-network","content":"Make sure you signin using a wallet Metamask.  Click Public  Click Upload   Upload the build folder then Click Upload   Click Sign and Upload   Your wallet will ask for a signature request Click Sign  The page should look like this:   "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-5-verifying-the-package-on-ipfs","content":"You will get an IPFS hash! This will lead you to IPFS link: https://gw.crustapps.net/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq?filename=build  🎉 Congratulations 🎉 on deploying using the Crust Files! "},{"title":"Deploying to Fleek","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/fleek","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrap to Fleek so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to FleekStep 5. Verifying the package on IPFS  "},{"title":"What is Fleek?​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#what-is-fleek","content":"Fleek is the easiest way to build, deploy, and host websites &amp; apps on IPFSFleek provides one seamless workflow with everything you need to build fast, modern sites &amp; web apps hosted on IPFS. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js ⚡ Fleek🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Fleek​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-4--upload-the-build-folder-to-fleek","content":"Make sure you signup for a Fleek account. On the left-hand side menu of your Fleek. Account page, click on the &quot;Storage&quot; link.  Then, click &quot;Create Folder&quot; Example: Gm-Polywrap  Click Confirm to create the folder   Click the Folder After that, click &quot;Upload&quot;   Select the contents of your build folder onto Fleek.  Click Confirm.  tip Due to the current Filecoin deal size limitation, files are batched together across Fleek products and uploaded as one Filecoin So it might take 24-48 hours, depending on Fleek usage, for content to appear in ipfs "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-5--verifying-the-package-on-ipfs","content":"Click the &quot;Verify on IPFS&quot; button. You will get an IPFS hash! For an example of what you should see, visit this IPFS link. Now that you have the IPFS hash, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrap. You can also register an ENS domain and have it resolved to this IPFS content. 🎉 Congratulations 🎉 on deploying to Fleek! "},{"title":"Publish to ENS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/publish-to-ens","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wraps/publish-to-ens#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wraps to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wraps.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"The ENS App​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wraps/publish-to-ens#the-ens-app","content":"ENS App is a distributed, open, and extensible naming system based on the Ethereum blockchain. "},{"title":"Deploying to Pinata","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/pinata","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrap to Pinata so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to PinataStep 5. Verifying the package on IPFS  "},{"title":"What is Pinata?​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#what-is-pinata","content":"Pinata is building the largest pinning service on IPFS! Pinata gives users the ability to upload, manage, and share their content whenever, wherever and, with whomever they want. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🪅 Pinata🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Pinata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-4--upload-the-build-folder-to-pinata","content":"Make sure you signup for a Pinata account. Click &quot;Upload&quot;  Click &quot;Folder&quot;  Click Select for a folder to upload should be the build folder   Give your file or folder a name. Example: Gm-Polywrap  Click &quot;Upload&quot; from the alert message  "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-5--verifying-the-package-on-ipfs","content":"You will get an IPFS hash! Click the name of the folder   This will lead you to IPFS link:https://gateway.pinata.cloud/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq Now that you have the IPFS hash located in the CID column in the pinata manager, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrap. 🎉 Congratulations 🎉 on deploying to Pinata! "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/introduction","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Introduction","url":"/tutorials/create-wraps/introduction#prerequisites","content":"If you haven't already, you'll need to install the Polywrap CLI. We'll be using it throughout the tutorial. To build your wrap without installing additional dependencies, you will need Docker and Docker Compose. The Polywrap CLI uses Docker by default, and we will use it in this tutorial. You can learn how to build a wrap without Docker in Configure Polywrap build pipeline. "},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/tutorials/create-wraps/introduction#next-steps","content":"The next section will show you how to start a new wrap project. Project Setup ➔ "},{"title":"Deployment","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/deployment","content":"","keywords":""},{"title":"Add a Readme​","type":1,"pageTitle":"Deployment","url":"/tutorials/create-wraps/part-one/deployment#add-a-readme","content":"Users can add descriptive metadata to their wraps by adding a polywrap.docs.yaml documentation manifest. We won't discuss the full breadth of the documentation manifest here, but we'll use it to add a readme file that will be published with our wrap package. polywrap.docs.yaml format: 0.1.0 readme: ./README.md  README.md // Write a readme for your wrap here.  For the Polywrap CLI to recognize our documentation manifest, we need to add the extension to our polywrap.yaml file. polywrap.yaml format: 0.3.0 project: name: template-wasm-as type: wasm/assemblyscript source: module: ./src/index.ts schema: ./polywrap.graphql extensions: docs: ./polywrap.docs.yaml  "},{"title":"Deploy to IPFS​","type":1,"pageTitle":"Deployment","url":"/tutorials/create-wraps/part-one/deployment#deploy-to-ipfs","content":"Deploying a wrap to IPFS couldn't be easier. With the polywrap deploy command in the Polywrap CLI, the CLI will by default automatically upload and pin your wrap to https://ipfs.wrappers.io. This is a free service provided by Polywrap to make it easy to deploy and use wraps. polywrap deploy  "},{"title":"Final Thoughts​","type":1,"pageTitle":"Deployment","url":"/tutorials/create-wraps/part-one/deployment#final-thoughts","content":"You've come so far and learned so much. You've built a wrap, tested it, and deployed it to IPFS. We're excited to see what you build next! When you're ready, hop on over to Part 2 of the tutorial to learn how to customize various aspects of the wrap development process. Join us on discord to share your thoughts and ask questions. We'd love to hear from you! "},{"title":"Integration Testing","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/integration-testing","content":"","keywords":""},{"title":"Why integration tests?​","type":1,"pageTitle":"Integration Testing","url":"/tutorials/create-wraps/part-one/integration-testing#why-integration-tests","content":"Here we will define an &quot;integration test&quot; as an end-to-end tests that validates the functionality of your wrap by invoking it from a Polywrap Client. This is in contrast to a &quot;unit test&quot;, which you might use to test the functionality of specific wrap methods in isolation. We write integration tests because certain wrap functionalities depend on the Polywrap Client. The most obvious example is subinvocation. When a wrap invokes a method in another wrap, the method arguments are serialized, sent back to the Polywrap Client, and routed to the other wrap. The Polywrap Client is required to coordinate the interaction. A downside of integration testing is that we don't have Polywrap Client for every programming language for which we can write wraps. If you're writing your wrap in Go or AssemblyScript, we assume you'll be okay with testing using the TypeScript Polywrap client. We also support a language-agnostic approach to integration testing that we call Workflows. Workflows are a way to define a sequence of steps that can be executed by any Polywrap Client. The output of workflow jobs can be validated to ensure that the wrap is functioning as expected. We won't be using workflows in this tutorial. "},{"title":"App Codegen​","type":1,"pageTitle":"Integration Testing","url":"/tutorials/create-wraps/part-one/integration-testing#app-codegen","content":"Codegen will generate different bindings for different types of projects. For integration tests, we use the codegen targeting application developers because they make testing easier and more closely replicate the wrap's end user experience. App codegen is not required--a Polywrap Client can invoke any wrap without codegen--but it's recommended. To execute app codegen without changing our polywrap.yaml project manifest or wrap schema, we can simply create another manifest and schema for the purpose of testing and pass them into the codegen command. I changed the namespace of my wrap import in the test schema to &quot;Oracle&quot; so I can refer to it as Oracle in my tests. RustGoTypeScriptAssemblyScript polywrap codegen -m ./tests/types/polywrap.app.yaml -g ./tests/types/wrap  "},{"title":"Write Tests​","type":1,"pageTitle":"Integration Testing","url":"/tutorials/create-wraps/part-one/integration-testing#write-tests","content":"With app codegen, integration tests are easy to write. For Rust wraps, we'll write our integration tests in Rust using the Rust Polywrap Client. For wraps written in other languages, we'll write our tests in TypeScript. We'll invoke our wrap using a file-system Wrap URI. In your test file, you can import the module class generated with app codegen. We'll use the default Polywrap Client configuration, so we won't need to pass one in as an argument to the module constructor. The module instance can be used to invoke the methods defined in your wrap schema with type safety. info You can use my personal API key to test your wrap. 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 Please do not use it outside the context of this tutorial. If it's abused, I'll have to revoke it! RustTypeScript tests/it/module.rs use crate::types::wrap::types::{ Oracle, OracleArgsObscure, OracleArgsEnlighten }; use std::env; #[test] fn obscure() { let args = OracleArgsObscure { data: vec![String::from(&quot;Hello&quot;), String::from(&quot;World&quot;)], chaos_level: Some(3) }; let oracle: Oracle = Oracle::new(None); let result = oracle.obscure(&amp;args, None).unwrap(); assert_eq!(result.len(), 128); } #[test] fn enlighten() { let args = OracleArgsEnlighten { question: String::from(&quot;What is the meaning of life?&quot;), api_key: env::var(&quot;PPLX_API_KEY&quot;).expect(&quot;API_KEY must be set&quot;) }; let oracle: Oracle = Oracle::new(None); let result = oracle.enlighten(&amp;args, None).unwrap(); assert_ne!(result.len(), 0); }  "},{"title":"Next Steps​","type":1,"pageTitle":"Integration Testing","url":"/tutorials/create-wraps/part-one/integration-testing#next-steps","content":"In the final part of the tutorial, we'll learn how to publish a wrap. Deployment ➔ "},{"title":"Import and Subinvoke","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/import-and-subinvoke","content":"","keywords":""},{"title":"Wrap URIs​","type":1,"pageTitle":"Import and Subinvoke","url":"/tutorials/create-wraps/part-one/import-and-subinvoke#wrap-uris","content":"Wrap URIs are a simple, flexible URI format used by Polywrap to identify and import wraps. They allow wraps to be stored and retrieved from a variety of sources, including IPFS, HTTP, and the local filesystem. Wrap URIs have the benefit of decentralization: developers are not required to use a centralized registry to publish their wraps. Instead, they can publish their wraps to any storage network and resolve them using a Polywrap Client. A Wrap URI has three parts: Scheme (optional): wrap://Authority: e.g. http, ipfs, fsPath: e.g. ipfs/Qm..., http/https://..., fs/path/to/wrap You can learn more about the Wrap URI format in the Wrap URI specification. A wrap URI is valid so long as it follows the Wrap URI format and can be resolved by a Polywrap Client. The Polywrap Client resolves URIs using implementations of the UriResolver interface. The Polywrap Client's default configuration includes several resolvers for common URI authorities, including IPFS, HTTP, ENS, and the local filesystem. Users can also configure the Polywrap Client with custom resolvers to resolve URIs from other sources. "},{"title":"Import a Wrap​","type":1,"pageTitle":"Import and Subinvoke","url":"/tutorials/create-wraps/part-one/import-and-subinvoke#import-a-wrap","content":"We'll import our first dependency using a Wrap URI with the wrapscan.io authority. The URI points to Polywrap's own Wrapscan registry, which is still in construction as of the time of this writing. The syntax of an import statement is: #import { &lt;type1, type2, ...&gt; } into &lt;Namespace&gt; from &lt;WrapUri&gt;  Import statements are placed in the Wrap Schema. Let's add an import statement for the Sha3 wrap. polywrap.graphql #import { Module } into Sha3 from &quot;wrapscan.io/polywrap/sha3@1.0.0&quot; type Module { obscure(data: [String!]!, chaosLevel: Int): String! }  This import statement ensures a Module type will be available in the Sha3 namespace. Make sure to run codegen once more to update the bindings. "},{"title":"Subinvocations​","type":1,"pageTitle":"Import and Subinvoke","url":"/tutorials/create-wraps/part-one/import-and-subinvoke#subinvocations","content":"Once we've successfully updated our generated bindings for the Sha3 dependency, we can use them to invoke a hash function. But how do we know which hash functions are available in the Sha3 wrap? Once again, the Wrap Schema comes in clutch. Even without package documentation, we can always know a wrap's interface by looking at its schema. You can view the schema for the Sha3 wrap on Github or Wrapscan. The schemas of wraps pinned on IPFS to the https://ipfs.wrappers.io gateway can also be viewed on Wrappers.io. tip Great places to find wraps Awesome Polywrap Github RepoWrapscan Registry (under construction)Wrappers.io list of all wrappers pinned to https://ipfs.wrappers.io We'll use the keccak256 hash function for the tutorial. Import the Sha3 module and the Args type for the keccak256 method. The imported Sha3 module exposes its functions as static methods, so you can call them without creating an instance. RustGoTypeScriptAssemblyScript src/lib.rs pub mod wrap; pub use wrap::prelude::*; use crate::wrap::imported::ArgsKeccak256; impl ModuleTrait for Module { fn obscure(args: ArgsObscure) -&gt; Result&lt;String, String&gt; { // handle default values let chaos_level = args.chaos_level.unwrap_or(1).max(1); let mut obscured = String::new(); for data in &amp;args.data { let mut message = data.clone(); for _ in 0..chaos_level { message = Sha3Module::keccak_256(&amp;ArgsKeccak256 { message })?; } obscured += &amp;message; } Ok(obscured) } }  When one wrap invokes another, we call it a subinvocation. Subinvocations are a special feature of Polywrap that aren't available in ordinary WebAssembly modules. The wrap standard makes it possible to invoke the Sha3 wrap from any wrap or Polywrap Client without knowing its source language. Subinvocations never throw errors. The return type of a subinvocation is always the Result type, or a language-specific equivalent. The Result type wraps the return value and contains either the expected value or an error. "},{"title":"Next Steps​","type":1,"pageTitle":"Import and Subinvoke","url":"/tutorials/create-wraps/part-one/import-and-subinvoke#next-steps","content":"Next we'll talk about interfaces and plugins. Interfaces are a powerful feature that allows wraps to implement a standard API. Plugins are extensions of a Polywrap Client, written in the client's host language, that give wraps access to host capabilities like networking and the filesystem. Interfaces and Plugins ➔ "},{"title":"First Method","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/first-method","content":"","keywords":""},{"title":"Update the Schema​","type":1,"pageTitle":"First Method","url":"/tutorials/create-wraps/part-one/first-method#update-the-schema","content":"We'll let the obscure method take an array of strings so that we can obscure a lot of data at once, and an optional chaosLevel to indicate how strongly we want to obscure the data. We'll return the obscured data as a string. tip UInt8 Int8 String BigInt Map&lt;K,V&gt; UInt16 Int16 Boolean BigNumber UInt32 Int32 Bytes JSON The built-in schema types are detailed in the Wrap Schema reference. If we wanted to add more options, we could pass a custom type with more fields, but we'll keep it simple for now. Go ahead and update the schema with the new method: polywrap.graphql type Module { obscure(data: [String!]!, chaosLevel: Int): String! }  Before we start writing code, we'll want to run polywrap codegen in the terminal to update our bindings. If you installed the Polywrap CLI locally using the provided package.json, you can run yarn codegen to do this. If you'd like, feel free to take a look at the wrap directory and see how the bindings have changed. "},{"title":"Write the Method​","type":1,"pageTitle":"First Method","url":"/tutorials/create-wraps/part-one/first-method#write-the-method","content":"When you open the module entry file, you'll see that it still has the same Module implementation with sampleMethod, which no longer exists. Let's replace it with obscure and fix the imports: RustGoTypeScriptAssemblyScript src/lib.rs pub mod wrap; pub use wrap::prelude::*; impl ModuleTrait for Module { fn obscure(args: ArgsObscure) -&gt; Result&lt;String, String&gt; { Ok(String::from(&quot;&quot;)) } }  Now let's add a simple implementation of obscure that doesn't use any dependencies. For each string in the data array, we are going to shift each character by chaosLevel. Then we'll concatenate the strings (for extra chaos) and return the result. Don't worry too much about the implementation details. We're going to rewrite the method in the next section. RustGoTypeScriptAssemblyScript src/lib.rs pub mod wrap; pub use wrap::prelude::*; impl ModuleTrait for Module { fn obscure(args: ArgsObscure) -&gt; Result&lt;String, String&gt; { // handle default values let chaos_level = args.chaos_level.unwrap_or(1).max(1); let mut obscured = String::new(); for data in &amp;args.data { // shift each character by the chaos level for c in data.chars() { let char_code = c as u32 + chaos_level as u32; if let Some(new_char) = std::char::from_u32(char_code) { obscured.push(new_char); } } } Ok(obscured) } }  "},{"title":"Build the Project​","type":1,"pageTitle":"First Method","url":"/tutorials/create-wraps/part-one/first-method#build-the-project","content":"To make sure our code compiles, let's build the project with the polywrap build command. The Polywrap CLI typically uses Docker to build wraps. At first this may sound unnecessary, but it's actually very useful. Building Polywrap wraps involves several steps that require additional dependencies. Depending on the source language, the steps may include tasks such as configuring WebAssembly memory and ensuring the wrap will work outside a JavaScript environment. Native build tools, such as Rust's cargo build, don't perform all the pre- and post-processing steps that Polywrap wraps require. tip If you're writing your wrap in Rust, you can use cargo check to check your code for errors without building the entire project. The polywrap build command has three build &quot;strategies&quot; that you can use to build your wrap: &quot;vm&quot;: Downloads and runs a pre-built Docker image. This is the default.&quot;image&quot;: Builds and runs a Docker image.&quot;local&quot;: Runs the build script locally, without Docker. The script will attempt to install and use global dependencies. Assumes the host machine is unix-like (i.e. not Windows). We'll discuss build customization in the Build Manifest section in Part Two of this guide. "},{"title":"Next Steps​","type":1,"pageTitle":"First Method","url":"/tutorials/create-wraps/part-one/first-method#next-steps","content":"In the next section, we'll improve the obscure method by importing a hashing function from another wrap. Import and Subinvoke ➔ "},{"title":"Project Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/project-manifest","content":"","keywords":""},{"title":"Manifest Content​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#manifest-content","content":"Let's open the polywrap.yaml manifest, located in the root of our new project folder. The only item you need to change for now is the project name, but we'll briefly discuss each manifest property here since we'll make more changes later on. Project Manifest v0.6.0 format: 0.6.0 # The manifest format version project: name: # Name of wrap type: # Type/language of project source: schema: # Path to wrap schema module: # (Optional) Path to module entry file; absent for interface wraps import_abis: # (Optional) Array of URI redirects used to resolve imports in the schema - uri: # One of the schema's import URI abi: # Path to a local ABI or schema. Supported file formats: [*.graphql, *.info, *.json, *.yaml] extensions: build: # (Optional) Path to Build Manifest file docs: # (Optional) Path to Docs Manifest file resources: # (Optional) Path to Resources directory  "},{"title":"Project​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#project","content":"As previously suggested, let's name our project &quot;oracle-wrap&quot;. The project type is used to determine how to generate code and build the project. It follows the syntax: (wasm|app|plugin)/language. So a Rust wrap will have the type wasm/rust, and a Rust plugin would have the type plugin/rust. The languages that can be used for a wasm wrap project are different from the languages used in plugin and app projects. RustGoTypeScriptAssemblyScript format: 0.6.0 project: name: oracle-wrap type: wasm/rust  There is one additional type of project called an &quot;interface wrap&quot; (with type interface), which is used to define a wrap interface that can be implemented by other wraps or plugins. We'll discuss interface wraps in greater detail later on in the tutorial. "},{"title":"Source​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#source","content":"The project source tells the Polywrap CLI where to find: The project schema--i.e. the module and types the wrap exportsThe module entry file that implements the Wrap Schema in code and exports its moduleThe location of a locally-stored Wrap Schema or wrap.info ABI file, and an arbitrary URI you'd like to point to it RustGoTypeScriptAssemblyScript source: module: ./Cargo.toml schema: ./polywrap.graphql  tip The import_abis item is useful during wrap development. Let's say you need to import another wrap, &quot;interface wrap&quot;, or plugin. All the relevant information is captured in its schema or wrap.info ABI. You need the wrap.wasm web assembly module to invoke the wrap's methods at runtime, but not to import its module or types at build time. This means you can start building your new wrap without first deploying its dependency. For example, the import_abis feature can be used in a monorepo that contains one &quot;interface wrap&quot; and a set of Wasm wraps or plugins that implement the interface. Each Wasm wrap project might contain an import_abis entry with a temporary URI that points to the interface polywrap.graphql schema. The wrap projects would use the temporary URI to import the interface in their own polywrap.graphql schemas, as though the interface were already published. "},{"title":"Extensions​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#extensions","content":"There are two types of manifest extensions you can register in the project manifest: build and docs. The polywrap.build.yaml build manifest enables developers to customize the wrap build process. The polywrap.docs.yaml manifest allows you to provide metadata for package registries and include common documentation files such as a README.md. We will use the docs manifest extensions later on to include a README.md file in our package. We won't be using the build extension in Part One of this tutorial, but we'll dive into it in Part Two. "},{"title":"Resources​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#resources","content":"The resources attribute allows you to provide a path to a directory that contains arbitrary files you'd like included in the wrap package when deploying the wrap. "},{"title":"Next Steps​","type":1,"pageTitle":"Project Manifest","url":"/tutorials/create-wraps/part-one/project-manifest#next-steps","content":"Next we'll review the Wrap Schema, generate code bindings, and review what is generated. The generated code bindings are the key to what makes wraps different from ordinary WebAssembly modules, and you'll need to know how to use them. We'll also take a look at the sample module entry file, which imports the generated bindings and uses them to implement the Wrap Schema in code. Schema and Codegen ➔ "},{"title":"Project Setup","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/project-setup","content":"","keywords":""},{"title":"Create the Project​","type":1,"pageTitle":"Project Setup","url":"/tutorials/create-wraps/part-one/project-setup#create-the-project","content":"We will generate our project scaffolding using the Polywrap CLI. The create command of the Polywrap CLI uses the syntax polywrap create &lt;project type&gt; &lt;language&gt; &lt;name&gt; to download a project template. This tutorial is about building Wasm wraps, so let's create a wasm project and name it oracle-wrap RustGoTypeScriptAssemblyScript polywrap create wasm rust oracle-wrap  After running this command, you'll see a new folder appear with the project name. "},{"title":"Project Contents​","type":1,"pageTitle":"Project Setup","url":"/tutorials/create-wraps/part-one/project-setup#project-contents","content":"Let's take a look at the contents of the project we just created. Then, in the next section, we'll review the project manifest file and learn how to configure it. RustGoTypeScriptAssemblyScript project/ ├── polywrap.yaml # Project manifest File ├── polywrap.graphql # Wrap Schema ├── src/ │ └── lib.rs # Entry point; exports module defined in schema ├── tests/ # Integration tests ├── Cargo.toml # Dependency management ├── package.json # Build scripts └── tsconfig.json # TypeScript configuration (for integration tests) polywrap.yaml​ The polywrap.yaml project manifest is a high-level configuration file describing a Polywrap project. polywrap.graphql​ Each wrap project has a Wrap Schema. The schema defines the wrap's interface, including dependencies, methods, and custom types. Polywrap uses the schema to generate the wrap's serialization bindings and validate the wrap's implementation. The schema is compiled to a wrap.info ABI file at build time and stored in the wrap package. In this tutorial, we'll learn how to write a Wrap Schema. It's easy! src/lib.rs The entry point file differs by language, but in all cases it exports the wrap module implementation. tests/ The tests directory contains integration tests for the wrap. Integration tests are performed using a Polywrap Client to invoke the wrap, just as a developer would do when using your wrap in their application. Without a client, you wouldn't be able to test the parts of your code that invoke other wraps or plugins. The tests directory contains a `types` folder with configuration files used to generate bindings for the tests in the client language. Depending on your project's language, the test types will be generated in TypeScript or Rust. The bindings are based on your wrap's schema and allow you to call methods on your wrap with an experience similar to the native programming language of the tests (i.e. TypeScript or Rust). The bindings are optional, but we recommend using them. package.json​ We include a package.json file with pre-written build scripts and developer dependencies for testing, even if your wrap is not written in TypeScript or AssemblyScript. If you're building a Rust wrap, the package.json file is used only for build scripts and is not required for testing. Feel free to delete it or use it only as a reference. We understand that not every user wants to install NodeJS to build with Polywrap. Don't worry! In Part Two of the tutorial, we will learn how to write language-agnostic tests without any JavaScript dependencies. tsconfig.json​ Used to configure TypeScript for integration tests. "},{"title":"Next Steps​","type":1,"pageTitle":"Project Setup","url":"/tutorials/create-wraps/part-one/project-setup#next-steps","content":"In the next section we will set up the Project Manifest file, which contains metadata the Polywrap CLI needs to build your wrap. Project Manifest ➔ "},{"title":"Add Metadata","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-two/add-metadata","content":"Add Metadata Developers can add content, such as a README.md, to their wrap packages. The location of this content must be defined in the project manifest under the resources key. resources: &quot;./resources&quot; By convention, the resources directory should be located at the root of the project. polywrap.yaml # Project Manifest resources/ # Resources directory src/ # Source code ","keywords":""},{"title":"Schema and Codegen","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/schema-and-codegen","content":"","keywords":""},{"title":"Initial Schema​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#initial-schema","content":"First, let's take a look at the polywrap.graphql schema we generated when we initialized our project with the Polywrap CLI. It's located in the project root. polywrap.graphql type Module { sampleMethod(arg: String!): SampleResult! } type SampleResult { result: String! }  We have a Module and a custom type named SampleResult. Every wrap has exactly one declaration of type Module that defines the wrap's methods. Without a module, there would be nothing to invoke. If we want two or more modules, we can simply create more wraps and our wrap can invoke them. When one wrap invokes another, we call it a &quot;subinvocation&quot;. The sample module has one method, sampleMethod(arg: String!): SampleResult!, that accepts a single argument named arg of type String! and returns a SampleResult!. Following GraphQL syntax, a ! means a type cannot be null. The absence of a ! would mean a property or argument is optional, and it's okay for users to pass in null. Also, primitive types start with capital letters. We'll use this schema to generate code bindings and see how they are used. "},{"title":"Codegen​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#codegen","content":"To generate the code bindings, change your current working directory to the project root and run polywrap codegen using the Polywrap CLI. A new directory called wrap will be generated next to your module entry file. RustGoTypeScriptAssemblyScript src/ ├── lib.rs # Entry point; exports module defined in schema └── wrap # Generated types  By default, codegen is automatically run before you build your project with polywrap build. "},{"title":"Wrap Directory​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#wrap-directory","content":"The bindings contain generated types that we must use to implement the wrap module, as well as additional logic related to serialization and interaction with the Polywrap Client. RustGoTypeScriptAssemblyScript wrap/ ├── module/ │ ├── mod.rs │ ├── module.rs # Module Trait │ └── wrapped.rs # Args types and method wrappers ├── sample_result/ │ └── mod.rs # Custom type implementations ├── mod.rs ├── entry.rs # Wrap entry file └── prelude.rs  We're going to keep it simple and discuss only the code snippets you need to be aware of: Custom type implementationsArgument types generated for each module methodThe Module Base (an abstract class, interface, or trait) Once we've seen the generated wrap bindings, we won't need to look at them again. The wrap schema tells you everything you need to know about the wrap directory's contents. "},{"title":"Custom Type​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#custom-type","content":"RustGoTypeScriptAssemblyScript wrap/sample_result/mod.rs #[derive(Clone, Debug, Deserialize, Serialize)] pub struct SampleResult { pub result: String, } impl SampleResult { pub fn new() -&gt; SampleResult { SampleResult { result: String::new(), } } }  A class (or struct) has been generated for the SampleResult type, mirroring its schema definition. Codegen generates custom types that mirror the custom types defined in the schema. Although we won't review it, the Polywrap CLI also generates serialization logic for each custom type. "},{"title":"Args​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#args","content":"RustGoTypeScriptAssemblyScript wrap/module/wrapped.rs #[derive(Clone, Debug, Deserialize, Serialize)] pub struct ArgsSampleMethod { pub arg: String, }  Likewise, a class (or struct) named ArgsSampleMethod (or Args_sampleMethod) has been generated to hold the arguments of the sampleMethod method defined in the schema. Codegen generates argument types for each method defined in the schema. A method's &quot;Args&quot; type must be used to invoke the method. As with custom types, serialization logic is generated for each Args type. info Why do we use an Args type instead of passing method arguments directly? Recall that when a Polywrap Client user invokes your wrap, the user passes arguments from the Client's host language (e.g. JavaScript) to the Wasm module. The arguments are serialized before being passed into the Wasm module. The Args type simplifies deserialization within the Wasm module. And if the invoked method performs a subinvocation--i.e. invokes a different wrap--the Args type passed into the subinvocation is serialized and passed to the subinvoked wrap. "},{"title":"Module Base​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#module-base","content":"RustGoTypeScriptAssemblyScript wrap/module/module.rs pub struct Module; pub trait ModuleTrait { fn sample_method(args: ArgsSampleMethod) -&gt; Result&lt;SampleResult, String&gt;; }  The Module Base is an abstract class or interface that must be implemented in your module entry file. For each method defined in the schema, the module base contains an abstract method with a matching signature. The Module Base helps wrap developers ensure their module implementation is correct by validating the module implementation at compile time. It is used by the wrap bindings to call the module's methods when a Polywrap Client invokes the wrap. "},{"title":"Initial Module​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#initial-module","content":"From this point forward, we won't need to look at the generated code bindings again. We can instead focus on the schema and the module entry file, which is where we'll write our code. The module entry file already contains an implementation of the Module Base, which mirrors the Module defined in the schema. It imports the generated ArgsSampleMethod (or Args_sampleMethod) and SampleResult types, and uses them in to implement the sampleMethod method. RustGoTypeScriptAssemblyScript src/lib.rs pub mod wrap; pub use wrap::prelude::*; impl ModuleTrait for Module { fn sample_method(args: ArgsSampleMethod) -&gt; Result&lt;SampleResult, String&gt; { return Ok(SampleResult { result: format!(&quot;{} from sample_method&quot;, args.arg), }); } }  "},{"title":"Next Steps​","type":1,"pageTitle":"Schema and Codegen","url":"/tutorials/create-wraps/part-one/schema-and-codegen#next-steps","content":"In the next section, we'll finally get to write some code. We'll implement the first method of &quot;Oracle Wrap&quot; and build our project with the Polywrap CLI. First Method ➔ "},{"title":"Configure a Polywrap Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-two/polywrap-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Polywrap Manifest","url":"/tutorials/create-wraps/part-two/polywrap-manifest#content","content":"The Polywrap Manifest contains the name of the wrap, programming language used to write it, and the location of the wrap schema that declares the wrap's interface. It optionally includes a path to the wrap's entry file (e.g. src/index.ts, src/lib.rs) and paths to other manifests that can be used to configure the build and deploy process. It can also contain an array of URI Redirects. SchemaExample format: # The manifest format version project: # Project information name: # Name of wrap type: # Type/language of project source: # Source code information schema: # Path to wrap schema module: # (Optional) Path to entry file import_abis: # (Optional) Array of URI redirects used to resolve imports in the schema - uri: # One of the schema's import URI abi: # Path to a local ABI or schema. Supported file formats: [*.graphql, *.info, *.json, *.yaml] extensions: build: # (Optional) Path to Build Manifest file resources: # (Optional) Path to Resources directory  "},{"title":"Writing tests with workflows","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-two/writing-tests-with-workflows","content":"","keywords":""},{"title":"Testing​","type":1,"pageTitle":"Writing tests with workflows","url":"/tutorials/create-wraps/part-two/writing-tests-with-workflows#testing","content":"In order to test this new functionality, we'll update the existing ./workflows/e2e.yaml workflow file to include the new methods we've added (setIpfsData, and getIpfsData). Add the following case to the e2e.yaml workflow in the ./workflows folder. ./workflows/e2e.yaml case2: steps: - uri: fs/build method: setIpfsData args: options: address: &quot;$cases.0.data&quot; data: &quot;Hello from IPFS!&quot; ipfsProvider: &quot;http://localhost:5001&quot; - uri: fs/build method: getIpfsData args: address: &quot;$cases.0.data&quot; ipfsProvider: &quot;http://localhost:5001&quot;  Once our workflow has been defined, we may want to be able to validate our actual results against our expectations. Workflow validation uses CUE, a flexible and expressive data validation language. CUE must be installed to complete this step. If you don't want to install anything right now, don't worry! Our results will be easy to verify with manually. To continue with automated testing, let's add our expected output to a new file in the workflows folder. We will call the file validator.cue. ./workflows/validator.cue package e2e cases: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{40}$&quot;, error?: _|_, // Never fails } case1: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{64}$&quot;, error?: _|_, } $1: { data: uint, error?: _|_ } } case2: { $0: { data: { txReceipt: string, ipfsHash: &quot;QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis&quot; }, error?: _|_, } $1: { data: &quot;Hello from IPFS!&quot;, error?: _|_, } } }  With our workflow complete, we'll deploy and test our wrap locally in the next section! "},{"title":"Configure Polywrap infrastructure pipeline","type":0,"sectionRef":"#","url":"/tutorials/test-wraps/infra-pipeline","content":"","keywords":""},{"title":"Interfaces and Plugins","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins","content":"","keywords":""},{"title":"Interfaces​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#interfaces","content":"An interface wrap defines a schema without implementing a module. Other wraps and plugins can implement the interface instead. An interface doesn't have knowledge of its implementations. Instead, users of the Polywrap Client can choose which wraps or plugins to register as known implementations. We're going to use the HTTP interface, imported using the Wrap URI &quot;wrapscan.io/polywrap/http@1.0&quot;. It is considered a best practice for users to register a URI Redirect for each interface in their Polywrap Client configuration that redirects from the interface URI to the URI of their primary implementation. This allows wrap users to directly invoke the interface URI--as if it were a Wasm wrap--without needing to know the URI of the primary implementation. In Polywrap's default Polywrap Client configuration, each interface URI is redirected to the URI of its default implementation. What if it doesn't make sense to redirect to any one default implementation? What if the Polywrap Client user did not do so? Wraps can get a list of registered implementations at runtime and invoke one or more of them. You can learn how to do this in Interface Instances. info Polywrap's URI Resolution system uses the URI Resolver Extension wrap interface to resolve URIs. Let's talk about two cases where interfaces are useful. First, interfaces are useful when you want to allow for multiple, fungible implementations of an interface. For example, you might want to allow users to register multiple implementations of an interface that resolves URIs. This is the case with Polywrap's URI Resolution system. Users can register multiple implementations of the URI Resolver Extension interface, and the Polywrap Client will invoke all of them when trying to resolve a URI. Another case is when you want your wrap to play nicely with plugins. Plugins are ordinary, language-specific packages that cannot necessarily be resolved by immutable Wrap URIs. Users can install a plugin using a package manager (e.g. JavaScript's NPM or Python's PyPi) and register it in the Polywrap Client with an arbitrary URI. If a plugin implements an interface, users are expected to either redirect the interface URI to point to the registered plugin URI, or to register the plugin as an interface implementation that can be obtained at runtime. For example, the default Polywrap Client configuration uses the URI &quot;plugin/http@1.1.0&quot; to register the HTTP plugin and registers a redirect from the HTTP interface URI to the plugin URI. "},{"title":"Plugins​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#plugins","content":"Plugins extend the Polywrap Client to give wraps access to host capabilities while keeping users in control. Plugins are a more powerful and secure alternative to the Wasi standard used in many WebAssembly modules. Standard WebAssembly modules are securely sandboxed and cannot access host capabilities like a user's filesystem. This is a feature, not a bug, because it prevents malicious behaviors. However, many useful modules need to access host capabilities. For example, a database module needs to read and write to the filesystem. A module that implements a web server needs to listen on a port. These capabilities can be implemented in plugins. Users register plugins in the Polywrap Client, choosing which plugins they want to allow their wraps to use. Plugins are implemented as language-specific packages. For example, a plugin for the JavaScript Polywrap Client is just a JavaScript package. From the perspective of a wrap developer, a plugin behaves like a wrap. Plugins are imported into schemas from URIs--typically by importing an interface--and are subinvoked just like a Wasm wrap module. "},{"title":"Implementation​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#implementation","content":"Enough talk! Let's implement the enlighten method. "},{"title":"Update the schema​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#update-the-schema","content":"Let's add the enlighten method and an import statement for the HTTP interface to the schema. The method will take a question and a Perplexity API key as arguments, and will return a response. Remember to run codegen after updating the schema. You can view the HTTP interface wrap's schema on GitHub.; #import { Module } into Sha3 from &quot;wrapscan.io/polywrap/sha3@1.0.0&quot; #import { Module } into Http from &quot;wrapscan.io/polywrap/http@1.0&quot; type Module { obscure(data: [String!]!, chaosLevel: Int): String! enlighten(question: String!, apiKey: String!): String! }  "},{"title":"Implement the method​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#implement-the-method","content":"Now we can import the generated Http Module class to send HTTP requests. To call the HTTP post method, we need to use some custom types defined in the HTTP interface schema. Polywrap's codegen is smart enough to generate these types for us, even though we didn't list them in an import statement, because the Http Module class depends on them. In order to focus on learning Polywrap, we aren't going to parse the HTTP response. We'll just return the raw response body as a string. RustGoTypeScriptAssemblyScript src/lib.rs pub mod wrap; pub use wrap::prelude::*; use crate::wrap::imported::{ArgsKeccak256, ArgsPost}; use polywrap_wasm_rs::Map; impl ModuleTrait for Module { fn obscure(args: ArgsObscure) -&gt; Result&lt;String, String&gt; { // handle default values let chaos_level = args.chaos_level.unwrap_or(1).max(1); let mut obscured = String::new(); for data in &amp;args.data { let mut message = data.clone(); for _ in 0..chaos_level { message = Sha3Module::keccak_256(&amp;ArgsKeccak256 { message })?; } obscured += &amp;message; } Ok(obscured) } fn enlighten(args: ArgsEnlighten) -&gt; Result&lt;String, String&gt; { let mut headers = Map::new(); headers.insert(&quot;accept&quot;.to_string(), &quot;application/json&quot;.to_string()); headers.insert(&quot;content-type&quot;.to_string(), &quot;application/json&quot;.to_string()); headers.insert(&quot;Authorization&quot;.to_string(), format!(&quot;Bearer {}&quot;, args.api_key)); let body = format!(r#&quot;{{ &quot;model&quot;: &quot;mistral-7b-instruct&quot;, &quot;messages&quot;: [ {{&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;Be precise and concise.&quot;}}, {{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;{}&quot;}} ] }}&quot;#, args.question); let response = HttpModule::post(&amp;ArgsPost { url: &quot;https://api.perplexity.ai/chat/completions&quot;.to_string(), request: Some(HttpRequest { headers: Some(headers), response_type: HttpResponseType::TEXT, body: Some(body), url_params: None, form_data: None, timeout: None, }), })?.ok_or(&quot;request failed with null body&quot;.to_string())?; if response.status != 200 { return Err(format!(&quot;request failed with status {}&quot;, response.status)); } response.body.ok_or(&quot;request failed with null body&quot;.to_string()) } }  "},{"title":"Next Steps​","type":1,"pageTitle":"Interfaces and Plugins","url":"/tutorials/create-wraps/part-one/interfaces-and-plugins#next-steps","content":"Our Oracle Wrap is now complete! But we're not quite done yet. We still need to test our wrap and publish it so others can use it. We'll test our wrap in the next section. Make sure to build your wrap and fix any compilation errors before moving on. Integration Testing ➔ "},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#declaration","content":"Unlike some manifests, the Infra Manifest does not need to be declared in your Polywrap manifest. "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#content","content":"The Infra Manifest consists of environmental variable declarations and one or more infrastructure modules. Each module points to a local, remote, or default docker-compose file. SchemaExample format: # The manifest format version env: # Declare environmental variables here modules: myRemote: # A remote package with a docker-compose file package: # Package name version: # Package version registry: # Package registry name dockerComposePath: # (Optional) Path to docker-compose file in the package directory myLocal: # A local package with a docker-compose file path: # Path to the package eth-ens-ipfs: default # A module available by default  "},{"title":"Infrastructure Modules​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#infrastructure-modules","content":"An Infra Manifest can declare any number of infrastructure modules. Polywrap currently supports three types of infrastructure modules: A local module exists on your local filesystem.A remote module is a package hosted by a package registry.The default module is included with the CLI. "},{"title":"Local​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#local","content":"A local infrastructure module is a path from the Infra Manifest to a local folder with a docker-compose file. Example: local module configuration format: 0.1.0 modules: myLocal: path: ../local-packages/myLocal  "},{"title":"Remote​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#remote","content":"A remote infrastructure module is a package hosted at a package registry. The package must contain a docker-compose file. The path to the docker-compose file must be declared in the Infra Manifest if the file is not located in the package root. Remote packages can be shared. Users can add remote packages to their manifest to replicate the infrastructure modules defined by other users or projects. Example: remote module configuration format: 0.1.0 modules: myIpfsNode: package: &quot;@namestys/ipfs-node&quot; version: &quot;1.0.2&quot; registry: npm dockerComposePath: ./config/docker-compose.yaml  "},{"title":"Default​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#default","content":"A default infrastructure module is included with the polywrap CLI. It is declared in the Infra Manifest as a module named eth-ens-ipfs and the value default. If an Infra Manifest is not found, the Polywrap CLI infra command can still use this module. To use the default module without an Infra Manifest, pass eth-ens-ipfs as an argument to the infra command's modules option: npx polywrap infra up --modules=eth-ens-ipfs  The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wraps and deploy them to an ENS registry on your locally hosted testnet. The Ethereum address of the ENS registry is 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab. Example: local module configuration format: 0.1.0 modules: eth-ens-ipfs: default  "},{"title":"Test Wraps In TypeScript","type":0,"sectionRef":"#","url":"/tutorials/test-wraps/in-typescript","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#introduction","content":"In this tutorial we'll learn how to develop custom end to end (e2e) tests for your wrap in TypeScript. These tests will be make calls into your wrap using the JavaScript / TypeScript Polywrap Client. "},{"title":"Prerequisites​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#prerequisites","content":"You'll need the following NPM packages installed before testing your wrap: @polywrap/client-js@polywrap/cli-jsjest "},{"title":"Project Setup​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#project-setup","content":"The tests we'll be developing will live next to your wrap's source-code. Polywrap has published pre-configured projects for both wasm/rust and wasm/assemblyscript wraps. You can use &amp; reference these when configuring your own project. In this tutorial we'll assume a fresh wasm/assemblyscript project has been created via the polywrap create wasm assemblyscript ... CLI command. "},{"title":"Build The Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#build-the-wrap","content":"Before any tests can be run, we must ensure the wrap has been freshly built. This will ensure we test against the latest version of the wrap's source-code. When using jest, we leverage the beforeAll function to do this. Additionally, the @polywrap/cli-js package makes it easy to invoke the polywrap build CLI command to build your wrap. import { Commands } from &quot;@polywrap/cli-js&quot;; describe(&quot;e2e Wrap Tests&quot;, () =&gt; { beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); });  This should result in a wrap package being emitted to the build/ directory. "},{"title":"Configure a Polywrap Client​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#configure-a-polywrap-client","content":"Before we create a new Polywrap client, we must create a configuration for it to use. This can be done through use of the ClientConfigBuilder. In the case of this example we'll be using the default configuration bundle. If your wrap requires any custom integration dependencies like plugins or environment variables, then now would be the time to configure this. import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; describe(&quot;e2e Wrap Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); ... });  "},{"title":"Load The Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#load-the-wrap","content":"We'll be loading our wrap directly from the build/ directory in the file-system. This can be accomplished in 1 of 2 ways: Package Embedding import { WasmPackage } from &quot;@polywrap/wasm-js&quot;; import fs from &quot;fs&quot;; ... const buildDir = `${__dirname}/../../build`; const embedPackage = WasmPackage.from( fs.readFileSync(`${buildDir}/wrap.info`), fs.readFileSync(`${buildDir}/wrap.wasm`) ); const uri = &quot;wrap://embed/test-wrapper&quot;; const config = new ClientConfigBuilder() .addPackage(uri, embedPackage) .build();  File-System URIs const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`;  In both cases, you end up with a uri which can be used to invoke your wrap through the client. "},{"title":"Test Your Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#test-your-wrap","content":"Now that we have a client invoke wraps, and a uri to reference our wrap, we're ready to write some tests.  test(&quot;Test Case&quot;, async () =&gt; { const result = await client.invoke({ uri, method: &quot;sampleMethod&quot;, args: { arg: &quot;foo bar baz&quot; } }); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value).toMatchObject({ result: &quot;foo bar baz&quot; }); });  "},{"title":"Type Safety​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#type-safety","content":"In the example above, it shows the use of the client.invoke(...) In the example above, it shows the use of the client.invoke(...)` method, which is generic. This means that if your wrap's schema changes, and (for example) the method being called no longer exists or its types change, the test will fail. In order to help ensure this can be caught sooner, and easier to debug, we suggest generating TypeScript types for your wrap's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  And an import schema like so: #import * into Wrapper from &quot;wrap://file/build&quot;  We suggest putting these files in a folder next to your tests, for example src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way.  test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  debug, we suggest generating TypeScript types for your wrap's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  We suggesting putting this polywrap.yaml manifest in a folder next to your tests like src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way. import { Wrapper_Module } from &quot;./types/wrap&quot;; ... test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  "},{"title":"Conclusion​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#conclusion","content":"And that's a wrap! import { Commands } from &quot;@polywrap/cli-js&quot;; import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { Wrapper_Module } from &quot;./types/wrap&quot;; jest.setTimeout(50000); describe(&quot;e2e Wrapper Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`; beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); }); });  If you'd like to see an in-production wrap w/ tests in TypeScript, checkout the ethereum wrap's tests here. "},{"title":"Default plugins","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/part-two/default-plugins","content":"","keywords":""},{"title":"Import to schema​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#import-to-schema","content":"We'll use one of the default plugins, HTTP, to show how you can import its modules into your wrap's schema (schema.graphql file). We typically import plugins into a schema by importing the interface they implement and letting users of the wrap decide which plugin to use. #import { Module, Request } into Http from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; Below, we explain what each part of this code means. #import Imports specific modules from a deployed or local plugin { Module, Request } These are specific modules that we're unpacking from the one of Polywrap's default plugins, HTTP. into Http This is a namespace, enabling you to use the modules in your schema e.g. Http_Module or Http_Request from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; wrap:// is the Polywrap URI schema.ens is the URI authority. It tells the Polywrap client what kind of URI it needs to resolve. See URIs for more information.wraps.eth:http@1.1.0 is the URI path, which in this case is an ENS address. "},{"title":"Use in Wrap​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#use-in-wrap","content":"Once types have been imported, the functionality of these imported modules can be used in wrap development. Upon yarn build, the imported types and modules will be made available to you in the src/wrap folder. To use them, you simply need to import the specific modules that you'd like to use. If you're building an AssemblyScript-based wrap, the import might look like this: import { Http_Module, Http_Request } from './wrap';  The Http_Module will contain the methods shown here, under the Module type. Once imported, you can access methods like so: Http_Module.get({ ... }) "},{"title":"Commonly used default plugins​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#commonly-used-default-plugins","content":"This section contains brief guides on the default plugins: EthereumProvider, FileSystem, HTTP, Logger, Concurrent. "},{"title":"Ethereum Provider​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#ethereum-provider","content":"The Ethereum Provider plugin can send RPC requests to Ethereum-compatible (EVM) blockchains. Schema: Link Importing the Ethereum Provider plugin into your wrap's schema: #import { Module } into Provider from &quot;plugin/ethereum-provider@2.0.0&quot;  Example: Link pub fn request_sync&lt;T: Serialize + Send + Sync, R: DeserializeOwned&gt;( &amp;self, method: &amp;str, params: T, ) -&gt; Result&lt;R, ProviderError&gt; { let params_v = JSON::to_value(&amp;params).unwrap(); let res = ProviderModule::request(&amp;ArgsRequest { method: method.to_string(), params: Some(params_v), connection: self.connection.clone(), }).map_err(|err| ClientError::Error(err))?; let res = JSON::from_value(res).map_err(|err| ClientError::SerdeJson { err, text: &quot;from str failed&quot;.to_string(), })?; Ok(res) }  "},{"title":"FileSystem​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#filesystem","content":"The FileSystem plugin can interact with the host filesystem. Schema: Link Importing the FileSystem plugin into your wrap's schema: #import { Module } into FileSystem from &quot;ens/wraps.eth:file-system@1.0.0&quot;  Example: Link pub fn get_file(args: ArgsGetFile, _env: Option&lt;Env&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; { let res = FileSystemModule::read_file(&amp;ArgsReadFile { path: args.path }); res.ok() }  "},{"title":"HTTP​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#http","content":"The HTTP plugin can send HTTP requests. Schema: Link Example Implementation​ In this example, we will implement a simple Ping method which pings CoinGecko to see their server status using an HTTP Get request from your wrap. In our ./src/schema.graphql file, we’ll write the schema for our wrap. At the top of this file, import the HTTP module into your wrap: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot;  Then, define the types and fields on the Ping method. First, add a new Ping type at the bottom of the schema. type Ping { gecko_says: String! }  Then, add an argument-less method called ping that returns a non-nullable Ping to the Module type. Our completed schema looks like this: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; type Module { ping: Ping! } type Ping { gecko_says: String! }  Now, we'll implement the ping method in ./src/index.ts At the top of the file, we'll import the HTTP/Ping methods and types. import { HTTP_Module, HTTP_ResponseType, Ping, } from './wrap';  Then, implement Ping function: export function ping(): Ping { // Writing the HTTP request / response const response = HTTP_Module.get({ url: 'https://api.coingecko.com/api/v3/ping', request: { headers: [], urlParams: [], body: '', responseType: HTTP_ResponseType.TEXT, }, }).unwrap(); // Error handling for the response if (!response || response.status !== 200 || !response.body) { const errorMsg = response &amp;&amp; response.statusText ? (response.statusText as string) : 'An error occurred while fetching data from Coingecko API'; throw new Error(errorMsg); } const json = &lt;JSON.Obj&gt;JSON.parse(response.body); // Response from Coingecko with field `geckoSays` const geckoSays = json.getString('gecko_says'); if (geckoSays) { return { gecko_says: geckoSays.valueOf(), }; } throw new Error('Invalid response body!'); }  "},{"title":"Logger​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#logger","content":"The Logger plugin enables logging in a wrap, which can be useful for debugging. In our ./src/schema.graphql file, import the Logger module into your wrap: #import { Module } into Logger from &quot;ens/wraps.eth:logger@1.0.0&quot;  Then in your implementation file ./src/index.ts, import the Logger function: import { Logger_Module, Logger_Logger_LogLevel, } from './wrap';  And use it like so:  Logger_Module.log({ level: Logger_Logger_LogLevel.INFO, message: `Insert useful log message here`, });  When you run your test e.g. yarn test:e2e, you will see the logged message in the console. "},{"title":"Concurrent​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/part-two/default-plugins#concurrent","content":"The Concurrent plugin enables concurrent execution of wrap sub-invocations. The meaning of &quot;concurrent&quot; depends on the plugin implementation, which varies by language. Schema: Link Importing the Concurrent plugin into your wrap's schema: #import { Module } into Concurrent from &quot;ens/wraps.eth:concurrent@1.0.0&quot;  Example: Link pub fn cat_task(ipfs_provider: &amp;str, cid: &amp;str, timeout: u32, client_uri: &amp;str) -&gt; ConcurrentTask { ConcurrentTask { uri: client_uri.to_string(), method: String::from(&quot;cat&quot;), args: serialize_cat_args(&amp;ClientArgsCat { cid: cid.to_string(), ipfs_provider: ipfs_provider.to_string(), timeout: Some(timeout), cat_options: None, }).unwrap() } } pub fn cat_task_result(task_result: &amp;ConcurrentTaskResult) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { if matches!(task_result.status, ConcurrentTaskStatus::COMPLETED) { return match &amp;task_result.result { Some(result) =&gt; Ok(deserialize_cat_result(result.as_ref()).unwrap()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } return match &amp;task_result.error { Some(error) =&gt; Err(error.to_string()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } pub fn exec_parallel( providers: &amp;Vec&lt;&amp;str&gt;, cid: &amp;str, timeout: u32, ) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { // get ipfs http client uri let client_uri: String = get_ipfs_http_client_uri()?; // get Concurrent implementation let impls = Concurrent::get_implementations(); if impls.len() &lt; 1 { println!(&quot;Parallel execution is not available. Executing sequentially instead. \\ Parallel execution requires an implementation of the Concurrent interface. \\ You can declare an interface implementation in your Polywrap Client configuration.&quot;); return exec_sequential(providers, cid, timeout); } let concurrent_module = ConcurrentModule::new(impls[0].clone()); // schedule tasks let mut tasks: Vec&lt;ConcurrentTask&gt; = Vec::new(); for &amp;provider in providers { tasks.push(cat_task(provider, cid, timeout, &amp;client_uri)); } let task_ids: Vec&lt;i32&gt; = concurrent_module.schedule(&amp;ArgsSchedule { tasks })?; // request task results let return_when = ConcurrentReturnWhen::ANY_COMPLETED; let result_args = &amp;ArgsResult { task_ids: task_ids.clone(), return_when }; let results: Vec&lt;ConcurrentTaskResult&gt; = concurrent_module.result(result_args)?; // return completed result value or panic let mut errors: Vec&lt;String&gt; = Vec::new(); for i in 0..results.len() { let result = cat_task_result(&amp;results[i]); if result.is_ok() { return result; } let error = build_exec_error(providers[i], timeout, result.unwrap_err().as_str()); errors.push(error); } return Err(errors.join(&quot;\\n&quot;)); }  "},{"title":"Configuring the Polywrap Client","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/configure-client","content":"","keywords":""},{"title":"The ClientConfigBuilder​","type":1,"pageTitle":"Configuring the Polywrap Client","url":"/tutorials/use-wraps/configure-client#the-clientconfigbuilder","content":"You can use the ClientConfigBuilder class to easily build the ClientConfig object: const config = new ClientConfigBuilder() .addDefaults() // add or remove configs here using ClientConfigBuilder methods... .build(); const client = new PolywrapClient(config);  "},{"title":"Creating the Polywrap client instance","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/create-client-instance","content":"Creating the Polywrap client instance Once the Polywrap JS client has been installed, the next step is to create a PolywrapClient instance: import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient(); At this point, you can already invoke wraps. In the simple example below, we send one to the &quot;hello world&quot; wrap. client.invoke({ uri: &quot;wrapscan.io/polywrap/logging@1.0&quot;, method: &quot;info&quot;, args: { message: &quot;Hello World!&quot; } }); ","keywords":""},{"title":"Installing the Polywrap JS client","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/install-client","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#introduction","content":"If you're a JavaScript developer building Browser, Node.js, or React based apps, this guide is for you. tip In the future, JavaScript will be one of many supported languages. Our goal is to enable the use of Polywrap in every major programming language. By the end of this document, you'll gain the following skills: How to instantiate the Polywrap client in your JavaScript AppInvoke any wrap using the Polywrap clientConfigure the Polywrap clientBuild React apps with ease If you get stuck during this guide, send us a message on our Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#prerequisites","content":"As prerequisites for this guide, we recommend having familiarity with TypeScript. React will also be used in the latter sections. "},{"title":"Installation​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#installation","content":"To use wraps in your app, all you need is the Polywrap Client! npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js, and browser applications. "},{"title":"Examples​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#examples","content":"Some example projects that integrate the JS client can be found here. The next section assumes that you're integrating Polywrap into an existing app project. If you want a quick start with our template project, simply run: npx polywrap create app typescript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-app. This command will create a new project folder with a &quot;Hello World&quot; app that lets you interact with two simple Wasm wraps at wrap://wrapscan.io/polywrap/logger@1.0 and wrap://wrapscan.io/polywrap/ethereum@1.0. "},{"title":"AI","type":0,"sectionRef":"#","url":"/use-cases/ai","content":"AI Coming soon... ✨","keywords":""},{"title":"Generate types for your app","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/types-for-app","content":"","keywords":""},{"title":"App Manifest content​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/use-wraps/types-for-app#app-manifest-content","content":"The App Manifest contains the name of the project, the programming language used to write it, and the location of the wrap schema that states which code to generate. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of project language: # App programming language schema: # Path to wrap schema import_abis: # (Optional) Array of URI redirects for schema imports - uri: # Source URI to be redirected abi: # Path to a local ABI (or schema). Supported file formats: [*.graphql, *.info, *.json, *.yaml]  "},{"title":"Wrap Schema for apps​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/use-wraps/types-for-app#wrap-schema-for-apps","content":"To automatically generate types for an application or test suite, we must tell the Polywrap CLI which types to generate. This is done using a Wrap Schema. In your wrap schema, you can add an import statement for each wrap you're using in your project. You can use the * syntax to import a wrap's module and all of its types, or you can list the types you'd like to use. Wrap schema for the Hello World app #import * into Logging from &quot;ens/wraps.eth:logging@1.0.0&quot;  Learn more about schema imports at Wrap Schema. "},{"title":"Use case: Web3","type":0,"sectionRef":"#","url":"/use-cases/web3","content":"","keywords":""},{"title":"Web3's Problem​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#web3s-problem","content":"We see traditional SDKs as a fundamental bottleneck for web3's adoption, let us explain... In web3, any application should be able to interact with smart contract protocols such as Uniswap or Aave. To do this, application developers utilize software development kits (SDKs) to simplify this process. However, traditional SDKs come with a number of issues: "},{"title":"Difficult to compose.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#difficult-to-compose","content":"A lack of standards makes traditional SDKs difficult to mix-and-match.  Today, protocol SDKs like Uniswap, Safe and Ethers aren't standardized. This means that a lot of complex, custom code needs to be written to compose them in dApps. "},{"title":"Not portable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#not-portable","content":"SDKs are language-specific, but the modern landscape of applications is more varied than ever: web, mobile, server, games, etc.  "},{"title":"Not upgradable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#not-upgradable","content":"When traditional SDKs undergo patch updates, the entire application needs to be rebuilt and redeployed, which doesn't scale to large web3 ecosystems.  "},{"title":"Polywrap's Solution ✨​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#polywraps-solution-","content":"Wraps offer a much better strategy for code reuse and composability than traditional SDKs. Wraps are: "},{"title":"Composable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#composable","content":"Wraps are developed in a standardized way. Standardization means Wraps can be easily composed, resulting in even more sophisticated Wraps.  "},{"title":"Portable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#portable","content":"Wraps can run on any platform that has the Polywrap client installed. Now, web3 dev teams can build their SDKs as Wraps, and application developers can integrate these Wraps across all platforms.  "},{"title":"Updatable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#updatable","content":"Wraps do not have to be bundled into applications. Instead they can be safely fetched and run at runtime. This allows applications to stay in-sync with web3 protocol upgrades. "},{"title":"Web3 Hosting​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#web3-hosting","content":"Wraps can be easily deployed to the InterPlanetary File System (IPFS), and published to a decentralized domain like the Ethereum Name Service (ENS). "},{"title":"React integration","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/react-integration","content":"","keywords":""},{"title":"PolywrapProvider​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () =&gt; { return ( &lt;PolywrapProvider&gt; &lt;HelloWorld /&gt; &lt;/PolywrapProvider&gt; ); };  PolywrapProvider Props​ The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: &lt;PolywrapProvider redirects={ [] }/&gt;  Multiple PolywrapProviders​ If you need to use multiple providers, you can do so using the createPolywrapProvider(&quot;...&quot;) method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) =&gt; { return ( &lt;CustomPolywrapProvider&gt; {children} &lt;/CustomPolywrapProvider&gt; ); };  "},{"title":"usePolywrapClient​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient();  "},{"title":"usePolywrapInvoke​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wraps! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, error, loading } = usePolywrapInvoke({ provider: &quot;custom&quot;, uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  "}]