[{"title":"Client","type":0,"sectionRef":"#","url":"/concepts/client","content":"Client A Client is any library that supports to the WRAP Standard. Essentially, any library that can resolve and invoke Wraps is a Client. The Polywrap Foundation maintains a number of WRAP-compatible clients, most notably: Polywrap JS ClientPolywrap Python ClientPolywrap Rust Client Other WRAP-compatible clients: Polywrap Go Client More clients are in development, such as a Polywrap Swift Client (more soon).","keywords":""},{"title":"ABI","type":0,"sectionRef":"#","url":"/concepts/abi","content":"ABI In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user. In the context of Polywrap, an ABI refers to the interface a Wrap provides. It defines invokable methods and types found within the Wrap. The Wrap Manifest file (wrap.info) contains, among other things, the Wrap's ABI, which comes as a msgpack-encoded schema of the Wrap.","keywords":""},{"title":"Envs","type":0,"sectionRef":"#","url":"/concepts/envs","content":"Envs Envs or &quot;Environment Variables&quot; are WRAP URI-mapped objects containing settings that are passed into a Wrap with the corresponding URI. For example, if we have the following Env: { &quot;wrap://ens/hello.world.eth&quot;: { foo: &quot;bar&quot; } } If we were to invoke the Wrap under wrap://ens/hello.world.eth, it would have a globally-available Env object, whose value would be { foo: &quot;bar&quot; }. It is up to the Wrap developer to decide on how to use the available Env object. The Wrap developer can also declare an Env type as part of their Schema, thus communicating to outside developers the structure of the object used for configuring of their Wraps.","keywords":""},{"title":"Interface Wraps","type":0,"sectionRef":"#","url":"/concepts/interface-wraps","content":"Interface Wraps An Interface Wrap (or Wrap Interface), unlike a WASM Wrap, consists only of an ABI. Wrap Interfaces are still Wraps in the sense that they have are identified by a URI. Consisting only of an ABI, an Interface Wrap cannot be invoked. Instead, it is used as an interface that can be implemented by multiple different Wraps. These Wraps can then be registered within the Client as Interface Implementations. During Invocation, you can invoke the method of an Interface, and if there is an Interface Implementation for the URI, the Wrap implementing the interface will be resolved during URI resolution and the implementing Wrap's method will be invoked. This is mostly used to ensure that, accross different Clients, their Plugin Wraps adhere to the same Interface Wraps. For example, all http Plugins need to have get and post methods with specific signatures and clearly defined Request and Response type structures.","keywords":""},{"title":"Plugin Wraps","type":0,"sectionRef":"#","url":"/concepts/plugin-wraps","content":"Plugin Wraps Polywrap Plugins, or &quot;Plugin Wraps&quot;, enable existing SDKs implemented in the client's language (e.g. JavaScript) to be queried as if they were WASM Wraps. Plugins can be used to enable any native client functionality that cannot be implemented in WebAssembly, such as sending HTTP requests, or signing blockchain transactions with a private key. If you want to build your own Plugins, you can follow the Plugin an existing SDK guide.","keywords":""},{"title":"Invoke","type":0,"sectionRef":"#","url":"/concepts/invoke","content":"Invoke The term &quot;invoke&quot; (or &quot;invocation&quot;) refers to the act of executing a method exposed by a Wrap. This can be done by using a client library that supports the WRAP Standard. Essentially, &quot;Invoke&quot; refers to any call to a method exposed by a Wrap, be it a WASM Wrap, a Plugin Wrap or an Interface Wrap, by a WRAP-compliant client such as the Polywrap Client. Any WRAP-compatible client can perform an Invocation with the following information: the WRAP URI of the Wrap being invokedthe name of the method being invokedthe method arguments For more information, refer to the Invocation standard.","keywords":""},{"title":"URIs","type":0,"sectionRef":"#","url":"/concepts/uris","content":"URIs Deployed wrappers are identified using custom URIs (Uniform Resource Identifier) called WRAP URIs. For example: wrap://ens/api.helloworld.polywrap.eth WRAP URIs follow the WRAP URI Standard. WRAP URIs have 3 parts: a protocol, an authority, and a path. Scheme​ WRAP URIs use the wrap scheme. Including wrap:// in your URI is optional in practice. Authority​ The Authority is used to denote which underlying protocol/standard the URI is part of. Usually, during URI resolution, the Polywrap Client will have at least one URI Resolver for each Authority used. For example: ens/ for resolving ENS domainsipfs/ for resolving IPFS contentfs/ for resolving content on the local filesystemhttp/ for resolving content via HTTP Path​ This is simply everything that comes after the Authority, and defines the unique resource we are trying to resolve. For example: api.domain.eth for an ENS domainQmaLbZnnnHbcRRo3wNBQ2MhugmBGL9R2YYeBvj6Nk2QumP for an IPFS file/directory./build for a local directoryexample.com/my-wrapper.wasm for a Wrap downloadable over HTTP tip ens/ and ipfs/ URI resolution is supported in all Polywrap clients by default. Adding custom URI resolvers is possible. More documentation on how to do this will be released soon.","keywords":""},{"title":"WASM Wraps","type":0,"sectionRef":"#","url":"/concepts/wasm-wraps","content":"WASM Wraps WASM Wraps are at the core of Polywrap - they are the portable, executable modules that can be called by any client that implements the WRAP Standard. They are WASM modules accompanied by a manifest file which describes said module. A Polywrap Wasm &quot;Wrap&quot; consists of at least the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions) - wrap.wasmA Wrap Manifest file that orchestrates the wrapper, and provides types and parameters for the module functions (it's ABI) - wrap.info Additional files can be present in a Wrap (e.g. metadata files), but these are not required for a Wrap to be valid.","keywords":""},{"title":"WASM","type":0,"sectionRef":"#","url":"/concepts/wasm","content":"WASM WASM (WebAssembly) is a binary instruction format designed to provide a portable and efficient target for the compilation of high-level programming languages such as C, C++, Rust, and others. It is a low-level, virtual machine-based format that is designed to be executed in web browsers, but can also be used in other contexts. WASM allows web developers to write web applications in languages other than JavaScript, while still being able to execute them in the browser. This provides a number of benefits, including better performance, improved security, and the ability to reuse existing code. In the context of Polywrap, WASM is used as the underlying technology to provide a secure, portable and efficient way to run Wraps. Polywrap loads and executs Wraps written in WASM, providing a sandboxed environment that ensures that the Wraps cannot interfere with the host application or other Wraps.","keywords":""},{"title":"Wraps","type":0,"sectionRef":"#","url":"/concepts/wraps","content":"Wraps Wraps, in a broad sense, are modules uniquely identifiable by a WRAP URI. Using a WRAP-compatible Client, a user can invoke any method a Wrap exposes. Wraps come in three forms: WASM WrapsInterface WrapsPlugin Wraps","keywords":""},{"title":"WRAP Standard","type":0,"sectionRef":"#","url":"/concepts/wrap-standard","content":"WRAP Standard The Polywrap Foundation has created and actively maintains a series of standards that all WRAP-compatible clients must adhere to. With Polywrap being an early-stage project, these standards are subject to change, but any change should be non-breaking and purely additive in nature. Read more about the WRAP Standard on its Github repository.","keywords":""},{"title":"Uniswap v3 Polywrap Documentation","type":0,"sectionRef":"#","url":"/demos/uniswapv3/intro","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#overview","content":"Welcome to the Uniswap v3 Polywrap documentation! The Uniswap Wasm wrapper is written in AssemblyScript, and like the official Uniswap SDK, it has a robust test suite and performs arbitrary precision arithmetic. The Uniswap Polywrap wrapper business logic will be deployed on a decentralized endpoint, like IPFS. Our first Polywrap client is for JavaScript(@polywrap/client-js) and it can run in any environment that can execute JavaScript. We also have a working Rust implementation. In the future, we'll have Polywrap clients for other environments (Python, Go, and more). Developers integrating the Uniswap Wasm wrapper into their app would use client invocations to execute functions provided by the Uniswap wrapper. This documentation shows you which functions are made available by the Uniswap wrapper and how to use them. "},{"title":"Uniswap wrapper vs. Existing SDK​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#uniswap-wrapper-vs-existing-sdk","content":"The Uniswap wrapper aims to be a substantial improvement over Uniswap v3’s existing SDK. While the official SDK bundles all classes (e.g. Trade), necessary data fields, and helper functions into the application, the Uniswap wrapper does not. Instead, all business logic is deployed on a decentralized endpoint, like IPFS, and is downloaded at runtime when the client application launches. You can learn more about the benefits of using Polywrap here. "},{"title":"Usage​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#usage","content":"We've created an interactive tutorial that can help you get started using the Uniswap wrapper here. In general, to use any Polywrap in your application, all you need is the Polywrap Client. npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js and browser applications. Then, initialize the client. import { Web3ApiClient } from '@polywrap/client-js'; const client = new Web3ApiClient();  Now, you're able to send queries to the Uniswap v3 wrapper! // You can use the familiar GraphQL Query syntax const tokenEqualsQuery: QueryApiResult = client.query(&lt;{ tokenEquals: boolean }&gt;{ uri: 'ens/v3.uniswap.web3api.eth', query: `{ tokenEquals( tokenA: ${tokenA} tokenB: ${tokenB} ) }`, }); const tokenEquals: boolean | undefined = tokenEqualsQuery.data?.tokenEquals; // Or the alternative Invoke syntax const routerQuery: InvokeApiResult&lt;MethodParameters&gt; = await client.invoke&lt;MethodParameters&gt;({ uri: ensUri, module: &quot;query&quot;, method: &quot;swapCallParameters&quot;, input: { trades: bestTrades, options: { slippageTolerance: &quot;0.01&quot;, recipient: recipient, deadline: &quot;123&quot;, } } }); const swapCallParameters: MethodParameters | undefined = routerQuery.data;  Take a look at more sophisticated tooling, such as our useWeb3ApiQuery hook, in our Create a JS App guide. "},{"title":"Code​","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"/demos/uniswapv3/intro#code","content":"The Pre-alpha source code is available on GitHub. "},{"title":"Call","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/call","content":"","keywords":""},{"title":"approve​","type":1,"pageTitle":"Call","url":"/demos/uniswapv3/mutations/call#approve","content":"Call the approve(...) function of an ERC20 token contract on-chain, allowing the Uniswap router contract to transfer tokens approve( token: Token! # Token for which to approve the Uniswap router contract to transfer amount: BigInt # The amount to approve for transfer; defaults to maximum amount if null gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"execCall​","type":1,"pageTitle":"Call","url":"/demos/uniswapv3/mutations/call#execcall","content":"Send an Ethereum transaction to the given address execCall( parameters: MethodParameters! # Transaction calldata and Ether value address: String! # Address of the target Ethereum contract chainId: ChainId! # Id of the chain on which to execute the transaction gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Deploy Pool","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/deploy","content":"","keywords":""},{"title":"deployPool​","type":1,"pageTitle":"Deploy Pool","url":"/demos/uniswapv3/mutations/deploy#deploypool","content":"Deploy a pool contract on-chain deployPool( pool: Pool! # A representation of the pool to deploy gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"deployPoolFromTokens​","type":1,"pageTitle":"Deploy Pool","url":"/demos/uniswapv3/mutations/deploy#deploypoolfromtokens","content":"Deploy a pool contract on chain for the given tokens and fee amount deployPoolFromTokens( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Constants","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/constants","content":"","keywords":""},{"title":"FACTORY_ADDRESS​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#factory_address","content":"The address of Uniswap's pool factory contract FACTORY_ADDRESS: String!  "},{"title":"POOL_INIT_CODE_HASH​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash","content":"POOL_INIT_CODE_HASH: String!  "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash_optimism","content":"POOL_INIT_CODE_HASH_OPTIMISM: String!  "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM_KOVAN​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#pool_init_code_hash_optimism_kovan","content":"A historical artifact due to small compiler mismatch POOL_INIT_CODE_HASH_OPTIMISM_KOVAN: String!  "},{"title":"MIN_TICK​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#min_tick","content":"Smallest valid tick index in a pool MIN_TICK: Int32!  "},{"title":"MAX_TICK​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#max_tick","content":"Largest valid tick index in a pool MAX_TICK: Int32!  "},{"title":"MIN_SQRT_RATIO​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#min_sqrt_ratio","content":"Smallest valid sqrtRatioX96 in a pool MIN_SQRT_RATIO: BigInt!  "},{"title":"MAX_SQRT_RATIO​","type":1,"pageTitle":"Constants","url":"/demos/uniswapv3/queries/constants#max_sqrt_ratio","content":"Largest valid sqrtRatioX96 in a pool MAX_SQRT_RATIO: BigInt!  "},{"title":"Swap","type":0,"sectionRef":"#","url":"/demos/uniswapv3/mutations/swap","content":"","keywords":""},{"title":"execSwap​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#execswap","content":"Perform an on-chain swap with one or more trades in a single transaction execSwap( trades: Trade[]! # Trades to encode into calldata swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"swap​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#swap","content":"Perform an on-chain swap within a single pool by using token and fee amount information to find the correct pool swap( inToken: Token! # Input token of the pool outToken: Token! # Output token of the pool fee: FeeAmount! # Fee amount of the pool being used for the swap amount: BigInt! # Amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"swapWithPool​","type":1,"pageTitle":"Swap","url":"/demos/uniswapv3/mutations/swap#swapwithpool","content":"Perform an on-chain swap using a single pool at provided address; requires ERC20-compliant input and output (i.e. no Ether) swapWithPool( address: String! # Ethereum address of the pool used for the swap amount: TokenAmount! # Token amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse!  "},{"title":"Encode Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/encodeUtils","content":"","keywords":""},{"title":"toHex​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#tohex","content":"Converts a big int to a hex string toHex( value: BigInt! ): String!  "},{"title":"encodeRouteToPath​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encoderoutetopath","content":"Converts a route to a hex encoded path encodeRouteToPath( route: Route! # The v3 path to convert to an encoded path exactOutput: Boolean! # Whether the route should be encoded in reverse, for making exact output swaps ): String!  "},{"title":"encodePermit​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodepermit","content":"Encodes arguments and returns transaction calldata to call selfPermit or selfPermitAllowed on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodePermit( token: Token! options: PermitOptions! ): String!  "},{"title":"encodeUnwrapWETH9​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodeunwrapweth9","content":"Encodes arguments and returns transaction calldata to call unwrapWETH9 or unwrapWETH9WithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeUnwrapWETH9( amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String!  "},{"title":"encodeSweepToken​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodesweeptoken","content":"Encodes arguments and returns transaction calldata to call sweepToken or sweepTokenWithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeSweepToken( token: Token! amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String!  "},{"title":"encodeRefundETH​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encoderefundeth","content":"Encodes arguments and returns transaction calldata to call refundEth on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeRefundETH: String!  "},{"title":"encodeMulticall​","type":1,"pageTitle":"Encode Utilities","url":"/demos/uniswapv3/queries/encodeUtils#encodemulticall","content":"Encodes multiple calldatas into a single calldata for making multiple calls in one transaction using a contract implementing the necessary interface, such as an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeMulticall( calldatas: String[]! ): String!  "},{"title":"Enum Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/enumUtils","content":"","keywords":""},{"title":"feeAmountToTickSpacing​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#feeamounttotickspacing","content":"Returns the tick spacing associated with a FeeAmount enum value feeAmountToTickSpacing( feeAmount: FeeAmount! ): Int32!  "},{"title":"getFeeAmount​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#getfeeamount","content":"Returns the fee (in one-hundred-thousandths of a percent) associated with a FeeAmount enum value getFeeAmount( feeAmount: FeeAmount! ): UInt32!  "},{"title":"getPermitV​","type":1,"pageTitle":"Enum Utilities","url":"/demos/uniswapv3/queries/enumUtils#getpermitv","content":"Returns v value associated with a PermitV enum value getPermitV( permitV: PermitV! ): Int32!  "},{"title":"Fetch","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/fetch","content":"","keywords":""},{"title":"fetchToken​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchtoken","content":"Returns token object constructed from the on-chain token contract at the given address fetchToken( address: String! # The Ethereum address of token's ERC20 contract chainId: ChainId! # The id of the chain to be queried ): Token!  "},{"title":"fetchPoolFromTokens​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchpoolfromtokens","content":"Returns pool object constructed from the on-chain pool contract associated with the tokens and fee amount fetchPoolFromTokens( tokenA: Token! # A token in the pool tokenB: Token! # The other token in the pool fee: FeeAmount! # The pool's fee amount fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool!  "},{"title":"fetchPoolFromAddress​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchpoolfromaddress","content":"Returns pool object constructed from the on-chain pool contract at the given address fetchPoolFromAddress( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool!  "},{"title":"fetchTickList​","type":1,"pageTitle":"Fetch","url":"/demos/uniswapv3/queries/fetch#fetchticklist","content":"Returns array of ticks from the on-chain pool contract at the given address fetchTickList( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried ): Tick[]!  "},{"title":"Nonfungible Position Manager","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/nfpm","content":"","keywords":""},{"title":"createCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#createcallparameters","content":"Returns calldata for creating a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol createCallParameters( pool: Pool! # An off-chain representation of the pool to create on-chain ): MethodParameters!  "},{"title":"addCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#addcallparameters","content":"Returns calldata for minting or adding liquidity to a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol. Optionally creates the pool if it doesn't exist. addCallParameters( position: Position! # Liquidity position to add to pool options: AddLiquidityOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"collectCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#collectcallparameters","content":"Returns calldata for collecting liquidity provider rewards using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol collectCallParameters( options: CollectOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"removeCallParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#removecallparameters","content":"Returns calldata for completely or partially exiting a liquidity position using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol removeCallParameters( position: Position! # The position to exit options: RemoveLiquidityOptions! # Additional information necessary for generating the calldata ): MethodParameters!  "},{"title":"safeTransferFromParameters​","type":1,"pageTitle":"Nonfungible Position Manager","url":"/demos/uniswapv3/queries/nfpm#safetransferfromparameters","content":"Returns calldata for safely transferring an NFT using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol safeTransferFromParameters( options: SafeTransferOptions! # Required transaction configuration ): MethodParameters!  "},{"title":"Math Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/mathUtils","content":"","keywords":""},{"title":"mostSignificantBit​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#mostsignificantbit","content":"Returns the most significant bit of a positive integer, starting with first bit = 0 mostSignificantBit( x: BigInt! ): UInt32!  "},{"title":"encodeSqrtRatioX96​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#encodesqrtratiox96","content":"Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0 encodeSqrtRatioX96( amount1: BigInt! # The numerator amount i.e., the amount of token1 amount0: BigInt! # The denominator amount i.e., the amount of token0 ): BigInt!  "},{"title":"mulDivRoundingUp​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#muldivroundingup","content":"Returns (a * b) / denominator mulDivRoundingUp( a: BigInt! b: BigInt! denominator: BigInt! ): BigInt!  "},{"title":"addDelta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#adddelta","content":"Returns x + y addDelta( x: BigInt! y: BigInt! ): BigInt!  "},{"title":"getAmount0Delta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getamount0delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount0Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt!  "},{"title":"getAmount1Delta​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getamount1delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount1Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt!  "},{"title":"getNextSqrtPriceFromInput​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getnextsqrtpricefrominput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromInput( sqrtPX96: BigInt! liquidity: BigInt! amountIn: BigInt! zeroForOne: Boolean! ): BigInt!  "},{"title":"getNextSqrtPriceFromOutput​","type":1,"pageTitle":"Math Utilities","url":"/demos/uniswapv3/queries/mathUtils#getnextsqrtpricefromoutput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromOutput( sqrtPX96: BigInt! liquidity: BigInt! amountOut: BigInt! zeroForOne: Boolean! ): BigInt!  "},{"title":"Pool Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/poolUtils","content":"","keywords":""},{"title":"computePoolAddress​","type":1,"pageTitle":"Pool Utilities","url":"/demos/uniswapv3/queries/poolUtils#computepooladdress","content":"Computes a pool address computePoolAddress( factoryAddress: String! # The Uniswap V3 factory address tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String!  "},{"title":"Pool","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/pool","content":"","keywords":""},{"title":"createPool​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#createpool","content":"Constructs and validates a Pool createPool( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # Fee amount for swaps through the pool sqrtRatioX96: BigInt! # Encoded representation of current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # Current pool tick ticks: Tick[] # A validated list of all ticks in the pool ): Pool!  "},{"title":"getPoolAddress​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooladdress","content":"Returns the Ethereum address of the Pool contract getPoolAddress( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String!  "},{"title":"poolInvolvesToken​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolinvolvestoken","content":"Returns true if the token is in the Pool (i.e. pool.token0 or pool.token1) poolInvolvesToken( pool: Pool! token: Token! ): Boolean!  "},{"title":"poolToken0Price​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#pooltoken0price","content":"Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 poolToken0Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price!  "},{"title":"poolToken1Price​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#pooltoken1price","content":"Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 poolToken1Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price!  "},{"title":"poolPriceOf​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolpriceof","content":"Returns the price of the given token in terms of the other token in the pool poolPriceOf( pool: Pool! # Pool that involves the token token: Token! # The token to return the price of ): Price!  "},{"title":"poolChainId​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#poolchainid","content":"Returns the chain ID of the tokens in the pool poolChainId( pool: Pool! ): ChainId!  "},{"title":"getPoolOutputAmount​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooloutputamount","content":"Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade getPoolOutputAmount( pool: Pool! # Pool that involves input and output tokens inputAmount: TokenAmount! # The input amount for which to quote the output amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit ): PoolChangeResult!  "},{"title":"getPoolInputAmount​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpoolinputamount","content":"Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade getPoolInputAmount( pool: Pool! # Pool that involves input and output tokens outputAmount: TokenAmount! # The output amount for which to quote the input amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap. ): PoolChangeResult!  "},{"title":"getPoolTickSpacing​","type":1,"pageTitle":"Pool","url":"/demos/uniswapv3/queries/pool#getpooltickspacing","content":"Returns the tick spacing of ticks in the pool getPoolTickSpacing( pool: Pool! ): Int32!  "},{"title":"Position Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/positionUtils","content":"","keywords":""},{"title":"maxLiquidityForAmounts​","type":1,"pageTitle":"Position Utilities","url":"/demos/uniswapv3/queries/positionUtils#maxliquidityforamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries. maxLiquidityForAmounts( sqrtRatioCurrentX96: BigInt! # Encoded representation of the current price sqrtRatioAX96: BigInt! # Encoded representation of the price at lower tick boundary sqrtRatioBX96: BigInt! # Encoded representation of the price at upper tick boundary amount0: BigInt! # Amount for the first token of the pool amount1: BigInt! # Amount for the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): BigInt!  "},{"title":"Quoter","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/quoter","content":"","keywords":""},{"title":"quoteCallParameters​","type":1,"pageTitle":"Quoter","url":"/demos/uniswapv3/queries/quoter#quotecallparameters","content":"Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters. quoteCallParameters( route: Route! # The swap route, a list of pools through which a swap can occur amount: TokenAmount! # The amount of the quote, either an amount in, or an amount out tradeType: TradeType! # The trade type, either exact input or exact output options: QuoteOptions # Optional configuration ): MethodParameters!  "},{"title":"Route","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/route","content":"","keywords":""},{"title":"createRoute​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#createroute","content":"Constructs and validates a Route createRoute( pools: Pool[]! # The ordered list of pools from which to construct the route inToken: Token! # The input token outToken: Token! # The output token ): Route!  "},{"title":"routeChainId​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#routechainid","content":"Returns the chain id of the tokens in the route routeChainId( route: Route! ): ChainId!  "},{"title":"routeMidPrice​","type":1,"pageTitle":"Route","url":"/demos/uniswapv3/queries/route#routemidprice","content":"Returns the mid price of the route routeMidPrice( pools: Pool[]! # The ordered list of pools from which to calculate the mid price inToken: Token! # The input token outToken: Token! # The output token ): Price!  "},{"title":"Router","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/router","content":"","keywords":""},{"title":"swapCallParameters​","type":1,"pageTitle":"Router","url":"/demos/uniswapv3/queries/router#swapcallparameters","content":"Encodes arguments and returns transaction calldata to make a swap on an Uniswap's V3 Router contract swapCallParameters( trades: Trade[]! # Trades for which to produce call parameters options: SwapOptions! # Configuration options for the swap call ): MethodParameters!  "},{"title":"Position","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/position","content":"","keywords":""},{"title":"createPosition​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createposition","content":"Constructs and validates a liquidity Position for a given Pool with the given liquidity createPosition( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): Position!  "},{"title":"createPositionFromAmounts​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries createPositionFromAmounts( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The amount of the first token of the pool amount1: BigInt! # The amount of the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position!  "},{"title":"createPositionFromAmount0​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamount0","content":"Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1 createPositionFromAmount0( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The desired amount of token0 useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position!  "},{"title":"createPositionFromAmount1​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#createpositionfromamount1","content":"Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0. Always uses full precision. createPositionFromAmount1( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount1: BigInt! # The desired amount of token1 ): Position!  "},{"title":"positionToken0PriceLower​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positiontoken0pricelower","content":"Returns the price of token0 at the lower tick positionToken0PriceLower( pool: Pool! # The pool for which the liquidity is assigned tickLower: Int32! # The lower tick of the position ): Price!  "},{"title":"positionToken0PriceUpper​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positiontoken0priceupper","content":"Returns the price of token0 at the upper tick positionToken0PriceUpper( pool: Pool! # The pool for which the liquidity is assigned tickUpper: Int32! # The upper tick of the position ): Price!  "},{"title":"positionAmount0​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positionamount0","content":"Returns the amount of token0 that this position's liquidity could be burned for at the current pool price positionAmount0( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount!  "},{"title":"positionAmount1​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#positionamount1","content":"Returns the amount of token1 that this position's liquidity could be burned for at the current pool price positionAmount1( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount!  "},{"title":"mintAmounts​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#mintamounts","content":"Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool mintAmounts( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): MintAmounts!  "},{"title":"mintAmountsWithSlippage​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#mintamountswithslippage","content":"Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance mintAmountsWithSlippage( position: Position! # Position for which to calculate mint amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts!  "},{"title":"burnAmountsWithSlippage​","type":1,"pageTitle":"Position","url":"/demos/uniswapv3/queries/position#burnamountswithslippage","content":"Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance burnAmountsWithSlippage( position: Position! # Position for which to calculate burn amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts!  "},{"title":"Staker","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/staker","content":"","keywords":""},{"title":"TickList Data Provider","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/tickProvider","content":"","keywords":""},{"title":"validateTickList​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#validateticklist","content":"Validates a tick list, returning true of the tick list is valid. Throws an exception if the tick list is not valid. validateTickList( ticks: Tick[]! # A list of ticks to validate tickSpacing: Int32! # The tick spacing of the list ): Boolean!  "},{"title":"getTick​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#gettick","content":"Returns the tick at the requested index getTick( tickDataProvider: Tick[]! # A list of ticks to search tickIndex: Int32! # The tick index of the requested tick ): Tick!  "},{"title":"nextInitializedTickWithinOneWord​","type":1,"pageTitle":"TickList Data Provider","url":"/demos/uniswapv3/queries/tickProvider#nextinitializedtickwithinoneword","content":"Returns next initialized tick, or max or min tick. Returns true if a tick is found at index. nextInitializedTickWithinOneWord( tickDataProvider: Tick[]! # Tick list to search tick: Int32! # Current tick index lte: Boolean! # True of returned tick index should be less than or equal to current tick index tickSpacing: Int32! # Tick spacing of tick list ): NextTickResult!  "},{"title":"collectRewards​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#collectrewards","content":"Returns transaction calldata for calling 'unstakeToken', 'claimReward', and 'stakeToken' in a single transaction on Uniswap's Staker contract. Note: A tokenId can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake. collectRewards( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys that `tokenId` is staked in; claims rewards for each program. options: ClaimOptions! # ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once. ): MethodParameters!  "},{"title":"withdrawToken​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#withdrawtoken","content":"Returns transaction calldata for unstaking, claiming, and withdrawing in a single transaction on Uniswap's Staker contract. withdrawToken( incentiveKeys: IncentiveKey[]! # A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in. options: FullWithdrawOptions! # Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`. ): MethodParameters!  "},{"title":"encodeDeposit​","type":1,"pageTitle":"Staker","url":"/demos/uniswapv3/queries/staker#encodedeposit","content":"Returns an encoded IncentiveKey as a string encodeDeposit( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom` ): String!  "},{"title":"Token","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/token","content":"","keywords":""},{"title":"currencyEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#currencyequals","content":"Returns true if the currencies are equivalent, false otherwise currencyEquals( currencyA: Currency! currencyB: Currency! ): Boolean!  "},{"title":"tokenEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokenequals","content":"Returns true if the tokens are equivalent, false otherwise tokenEquals( tokenA: Token! tokenB: Token! ): Boolean!  "},{"title":"tokenAmountEquals​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokenamountequals","content":"Returns true if the token amounts are equivalent, false otherwise tokenAmountEquals( tokenAmountA: TokenAmount! tokenAmountB: TokenAmount! ): Boolean!  "},{"title":"tokenSortsBefore​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#tokensortsbefore","content":"Returns true if the address of tokenA would precede the address of token B when sorted alphabetically tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean!  "},{"title":"getEther​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#getether","content":"Returns a native token (e.g. Ether) on the specified chain getNative( chainId: ChainId! ): Token!  "},{"title":"getWETH​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#getweth","content":"Returns a Wrapped Ether token on the specified chain getWETH( chainId: ChainId! ): Token!  "},{"title":"isNative​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#isnative","content":"Returns true if the token is native (e.g. Ether), false otherwise. A token representing Ether must have an empty string in its address field. isNative( token: Token! ): Boolean!  "},{"title":"wrapToken​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#wraptoken","content":"If the input token is Ether, the return value is Wrapped Ether; otherwise, the return value is the same as the input value. wrapToken( token: Token! ): Token!  "},{"title":"wrapAmount​","type":1,"pageTitle":"Token","url":"/demos/uniswapv3/queries/token#wrapamount","content":"If the input token amount represents an amount of Ether, the return value represents the same amount in Wrapped Ether; otherwise, the return value is the same as the input value. wrapAmount( amount: TokenAmount! ): TokenAmount!  "},{"title":"Trade","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/trade","content":"","keywords":""},{"title":"createTradeExactIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradeexactin","content":"Constructs an exact in trade with the given amount in and route createTradeExactIn( tradeRoute: TradeRoute! # The route of the exact in trade and the amount being passed in ): Trade!  "},{"title":"createTradeExactOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradeexactout","content":"Constructs an exact out trade with the given amount out and route createTradeExactOut( tradeRoute: TradeRoute! # The route of the exact out trade and the amount returned ): Trade!  "},{"title":"createTradeFromRoute​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradefromroute","content":"Constructs a trade by simulating swaps through the given route createTradeFromRoute( tradeRoute: TradeRoute! # The route to swap through and the amount specified, either input or output, depending on the trade type tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade!  "},{"title":"createTradeFromRoutes​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createtradefromroutes","content":"Constructs a trade by simulating swaps through the given routes createTradeFromRoutes( tradeRoutes: TradeRoute[]! # The routes to swap through and how much of the amount should be routed through each tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade!  "},{"title":"createUncheckedTrade​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createuncheckedtrade","content":"Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTrade( swap: TradeSwap! # The route to swap through, the amount being passed in, and the amount returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade!  "},{"title":"createUncheckedTradeWithMultipleRoutes​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#createuncheckedtradewithmultipleroutes","content":"Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTradeWithMultipleRoutes( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade!  "},{"title":"tradeInputAmount​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeinputamount","content":"The input amount for the trade assuming no slippage tradeInputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount!  "},{"title":"tradeOutputAmount​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeoutputamount","content":"The output amount for the trade assuming no slippage tradeOutputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount!  "},{"title":"tradeExecutionPrice​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeexecutionprice","content":"The price expressed in terms of output amount/input amount tradeExecutionPrice( inputAmount: TokenAmount! # The trade input amount, e.g. from Trade object or tradeInputAmount(...) outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Price!  "},{"title":"tradePriceImpact​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradepriceimpact","content":"Returns the percent difference between the route's mid price and the price impact tradePriceImpact( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Fraction!  "},{"title":"tradeMinimumAmountOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#trademinimumamountout","content":"Get the minimum amount that must be received from the trade for the given slippage tolerance tradeMinimumAmountOut( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountOut: TokenAmount! # The output amount of the trade, before slippage, e.g. from Trade object or tradeOutputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount!  "},{"title":"tradeMaximumAmountIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#trademaximumamountin","content":"Get the maximum amount in that can be spent via the trade for the given slippage tolerance tradeMaximumAmountIn( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountIn: TokenAmount! # The input amount of the trade, before slippage, e.g. from Trade object or tradeInputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount!  "},{"title":"tradeWorstExecutionPrice​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#tradeworstexecutionprice","content":"Return the execution price after accounting for slippage tolerance tradeWorstExecutionPrice( trade: Trade! # Trade for which to calculate execution price slippageTolerance: String! # The allowed tolerated slippage ): Price!  "},{"title":"bestTradeExactIn​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#besttradeexactin","content":"Given a list of pools, and a fixed amount in, returns the top maxNumResults trades that go from an input token amount to an output token, making at most maxHops hops. Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactIn( pools: Pool[]! # The pools to consider in finding the best trade amountIn: TokenAmount! # Exact amount of input currency to spend tokenOut: Token! # The desired currency out options: BestTradeOptions # Options used when determining the best trade ): Trade[]!  "},{"title":"bestTradeExactOut​","type":1,"pageTitle":"Trade","url":"/demos/uniswapv3/queries/trade#besttradeexactout","content":"similar to bestTradeExactIn(...) but instead targets a fixed output amount given a list of pools, and a fixed amount out, returns the top maxNumResults trades that go from an input token to an output token amount, making at most maxHops hops note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactOut( pools: Pool[]! # The pools to consider in finding the best trade tokenIn: Token! # The currency to spend amountOut: TokenAmount! # The desired currency amount out options: BestTradeOptions # Options used when determining the best trade ): Trade[]!  "},{"title":"Tick Utilities","type":0,"sectionRef":"#","url":"/demos/uniswapv3/queries/tickUtils","content":"","keywords":""},{"title":"nearestUsableTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#nearestusabletick","content":"Returns the closest tick that is nearest a given tick and usable for the given tick spacing nearestUsableTick( tick: Int32! # The target tick tickSpacing: Int32! # The spacing of the pool ): Int32!  "},{"title":"tickToPrice​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#ticktoprice","content":"Returns a price object corresponding to the input tick and the base/quote token. Inputs must be tokens because the address order is used to interpret the price represented by the tick. tickToPrice( baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price tick: Int32! # The tick for which to return the price ): Price!  "},{"title":"priceToClosestTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#pricetoclosesttick","content":"Returns the first tick for which the given price is greater than or equal to the tick price. priceToClosestTick( price: Price! # Price for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price. Note that a string price is not used as input here, so the 'price' property of the Price type can have any value without affecting the results. ): Int32!  "},{"title":"tickIsBelowSmallest​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#tickisbelowsmallest","content":"Returns true if the tick index is smaller than all tick indices in the list tickIsBelowSmallest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean!  "},{"title":"tickIsAtOrAboveLargest​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#tickisatorabovelargest","content":"Returns true if the tick index is greater than or equal to all tick indices in the list tickIsAtOrAboveLargest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean!  "},{"title":"nextInitializedTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#nextinitializedtick","content":"Returns next initialized tick following the input tick nextInitializedTick( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index lte: Boolean! # If true, searches list for next initialized tick that has index less than or equal to the input tick index ): Tick!  "},{"title":"tickListIsSorted​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#ticklistissorted","content":"Returns true if a tick list is sorted by tick index tickListIsSorted( ticks: Tick[]! # The tick list ): Boolean!  "},{"title":"getSqrtRatioAtTick​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#getsqrtratioattick","content":"Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick getSqrtRatioAtTick( tick: Int32! # The tick for which to compute the sqrt ratio ): BigInt!  "},{"title":"getTickAtSqrtRatio​","type":1,"pageTitle":"Tick Utilities","url":"/demos/uniswapv3/queries/tickUtils#gettickatsqrtratio","content":"Returns the tick corresponding to a given sqrt ratio, such that getSqrtRatioAtTick(tick) &lt;= sqrtRatioX96 and getSqrtRatioAtTick(tick + 1) &gt; sqrtRatioX96 getTickAtSqrtRatio( sqrtRatioX96: BigInt! # The sqrt ratio as a Q64.96 for which to compute the tick ): Int32!  "},{"title":"Common Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/common-types","content":"","keywords":""},{"title":"BestTradeOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#besttradeoptions","content":"Options used when determining the best trade in bestTradeExactIn(...) and bestTradeExactOut(...) type BestTradeOptions { maxNumResults: UInt32 # Maximum number of results to return maxHops: UInt32 # Maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool }  "},{"title":"Currency​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#currency","content":"Describes a token type Currency { decimals: UInt8! # Token decimals symbol: String # Token symbol name: String # Token name }  "},{"title":"FeeOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#feeoptions","content":"Fee configuration for encodeUnwrapWETH9(...) and encodeSweepToken(...) type FeeOptions { fee: String! # The percent of the output that will be taken as a fee. recipient: String! # The recipient of the fee. }  "},{"title":"Fraction​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#fraction","content":"Represents fraction, typically a percent. type Fraction { numerator: BigInt! # Numerator of fraction denominator: BigInt! # Denominator of fraction quotient: String! # A decimal string representation of the fraction }  "},{"title":"MethodParameters​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#methodparameters","content":"Transaction calldata and an ether value to be sent with the transaction type MethodParameters { calldata: String! # The hex encoded calldata to perform the given operation value: String! # The amount of ether (wei) to send in hex. }  "},{"title":"MintAmounts​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#mintamounts","content":"The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool type MintAmounts { amount0: BigInt! # Amount of the first token in the pool amount1: BigInt! # Amount of the second token in the pool }  "},{"title":"PermitOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#permitoptions","content":"Parameters for a permit allowing the transfer of tokens. Either amount and deadline OR nonce and expiry are required. type PermitOptions { v: PermitV! r: String! s: String! amount: BigInt deadline: BigInt nonce: BigInt expiry: BigInt }  "},{"title":"Pool​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#pool","content":"A liquidity pool involving two tokens which can be exchanged for a price determined by a price curve and market dynamics type Pool { token0: Token! # The first token of the pool token1: Token! # The second token of the pool fee: FeeAmount! # The fee amount liquidity providers receive as a share of swaps made in the pool sqrtRatioX96: BigInt! # An encoded representation of the current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # The current tick tickDataProvider: Tick[]! # A list of all ticks in the pool token0Price: Price! # The current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 token1Price: Price! # The current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 }  "},{"title":"Position​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#position","content":"A liquidity position between two ticks in a pool type Position { pool: Pool! # The pool on which the position is held tickLower: Int32! # The lower tick, marking the lower boundary of the position tickUpper: Int32! # The upper tick, marking the upper boundary of the position liquidity: BigInt! # The maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries token0Amount: TokenAmount! # The amount in this position of the first token of the pool token1Amount: TokenAmount! # The amount in this position of the second token of the pool mintAmounts: MintAmounts! # The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool token0PriceLower: Price! # The price of token0 at the lower tick token0PriceUpper: Price! # The price of token0 at the upper tick }  "},{"title":"Price​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#price","content":"Represents price of a token in terms of another token. When used as a function argument, the 'price' property is ignored. type Price { baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price denominator: BigInt! # Amount of base token used to calculate price numerator: BigInt! # Amount of quote token used to calculate price price: String! # A decimal string representation of the price }  "},{"title":"Route​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#route","content":"An ordered path of pools through which a swap can occur type Route { pools: Pool[]! # A list of pools, wherein each pool in the list has a token in common with its adjacent pool(s) path: Token[]! # The path of tokens that are swapped through the pools input: Token! # The input token, where the route begins output: Token! # The output token, where the route ends midPrice: Price! # The mid price of the output token, in terms of the input token, for this route }  "},{"title":"SwapOptions​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#swapoptions","content":"Configuration for creating swap transaction calldata using swapCallParameters(...) type SwapOptions { slippageTolerance: String! # How much the execution price is allowed to move unfavorably from the trade execution price. recipient: String! # The account that should receive the output. deadline: BigInt! # When the transaction expires, in epoch seconds. inputTokenPermit: PermitOptions # The optional permit parameters for spending the input. sqrtPriceLimitX96: BigInt # The optional price limit for the trade. fee: FeeOptions # Optional information for taking a fee on output. }  "},{"title":"Tick​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tick","content":"A pool tick marks a section of the price curve. A liquidity provider may hold a position on a tick, rather than the full curve. type Tick { index: Int32! # Tick index liquidityGross: BigInt! # Gross liquidity in Pool at tick position liquidityNet: BigInt! # Net liquidity in Pool at tick position }  "},{"title":"Token​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#token","content":"ERC20-compliant token or Ether type Token { chainId: ChainId! # Id of chain where token exists address: String! # Address of token's ERC20 contract currency: Currency! # Token description }  "},{"title":"TokenAmount​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tokenamount","content":"An amount of a token type TokenAmount { token: Token! # Token amount: BigInt! # Raw amount of the token, not adjusted for the token's decimals }  "},{"title":"Trade​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#trade","content":"A trade contains the information necessary to create an on-chain exchange of tokens type Trade { swaps: TradeSwap[]! # A list of swaps to be executed atomically, all of which must have the same input and output tokens tradeType: TradeType! # Type of trade, either exact input or exact output inputAmount: TokenAmount! # The total input amount (sum of input amounts in swaps) outputAmount: TokenAmount! # The total output amount (sum of output amounts in swaps) executionPrice: Price! # The price of the trade, in terms of the input token priceImpact: Fraction! # The percent difference between the route's mid price and the price impact }  "},{"title":"TradeSwap​","type":1,"pageTitle":"Common Types","url":"/demos/uniswapv3/types/common-types#tradeswap","content":"A route, input, and output amount that compose the core elements of a trade type TradeSwap { route: Route! # The route of the trade inputAmount: TokenAmount! # The amount being passed in outputAmount: TokenAmount! # The amount returned by the trade when executed }  "},{"title":"Enum Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/enum-types","content":"","keywords":""},{"title":"ChainId​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#chainid","content":"Ethereum chain supported by the wrapper enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN OPTIMISM OPTIMISTIC_KOVAN ARBITRUM_ONE ARBITRUM_RINKEBY POLYGON POLYGON_MUMBAI }  "},{"title":"FeeAmount​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#feeamount","content":"Pool swap fee amount enum FeeAmount { LOWEST LOW MEDIUM HIGH }  "},{"title":"PermitV​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#permitv","content":"Valid v value of Permit enum PermitV { v_0 v_1 v_27 v_28 }  "},{"title":"TradeType​","type":1,"pageTitle":"Enum Types","url":"/demos/uniswapv3/types/enum-types#tradetype","content":"Type of trade, either exact input or exact output enum TradeType { EXACT_INPUT EXACT_OUTPUT }  "},{"title":"Mutation Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/mutation-types","content":"","keywords":""},{"title":"GasOptions​","type":1,"pageTitle":"Mutation Types","url":"/demos/uniswapv3/types/mutation-types#gasoptions","content":"Transaction gas configuration type GasOptions { gasPrice: BigInt # The gas price to set for the transaction gasLimit: BigInt # The gas limit to set for the transaction }  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/introduction","content":"","keywords":""},{"title":"The problem with current Web3 SDKs​","type":1,"pageTitle":"Introduction","url":"/introduction#the-problem-with-current-web3-sdks","content":"We see traditional SDKs as the primary bottleneck to web3's potential for composable, cross-platform dApps. Web3 promises a new depth of composability in software development. Any application can interact with smart contract protocols like Uniswap or Aave. For web3 developers, software development kits (SDKs) simplify this integration process. However, traditional SDKs come with a number of issues for web3 developers, namely they are: difficult to compose. Due to the lack of SDK standards, the SDK for one web3 protocol may be difficult to mix-and-match with that of another.  not portable. SDKs are language-specific. Today's deployment platforms are more varied than ever (web, mobile, server, etc.). Thus, SDK codebases need to be duplicated and translated for each of these environments, leading to more chances for bugs to appear and higher maintenance costs.  not upgradable. When traditional SDKs undergo a patch update, the entire application needs to be rebuilt and redeployed. "},{"title":"Polywrap: Composable web3 Wrappers​","type":1,"pageTitle":"Introduction","url":"/introduction#polywrap-composable-web3-wrappers","content":"Presenting Polywrap - a framework for building “wrappers”: composable, portable, and dynamically upgradeable SDKs.✨ Polywrap's wrappers offer a much better strategy for code reuse and composability than traditional SDKs. Wrappers are: easily composable. Wrappers are developed in a standardized way, and all dApps powered by the Polywrap client library can communicate with wrappers with a familiar graphQL-esque querying. Standardization means wrappers can be easily composed, resulting in even more sophisticated wrappers.  portable. Wrappers can execute in any host environment that has the Polywrap client installed (web, mobile, IoT, servers, and more). Instead of maintaining multiple language-specific SDKs, web3 dev teams can write their wrappers in one language that works seamlessly across all deployment platforms.  updatable on the fly. Wrappers aren't bundled into applications. Instead, they're fetched at runtime and any patch updates are done on the fly, without the need to rebuild the entire app. "},{"title":"What's inside a Polywrap Wasm Wrap?​","type":1,"pageTitle":"Introduction","url":"/introduction#whats-inside-a-polywrap-wasm-wrap","content":"A Polywrap Wasm &quot;Wrap&quot; consists of the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions)Wrap Manifest file that orchestrates the Wrap, and provides types and parameters for the module functions "},{"title":"Where is it deployed?​","type":1,"pageTitle":"Introduction","url":"/introduction#where-is-it-deployed","content":"We currently support deploying Wraps to decentralized endpoints, Ethereum Name Service (ENS), a decentralized Ethereum-based naming system and InterPlanetary File System (IPFS), a distributed P2P file system. You can see a list of all deployed Wraps here: https://wrappers.io/all "},{"title":"How can apps integrate this deployed Wrap?​","type":1,"pageTitle":"Introduction","url":"/introduction#how-can-apps-integrate-this-deployed-wrap","content":"In a JavaScript application, a developer would first install the Polywrap JavaScript client. At that point, a Polywrap-enabled app will be able to download and use the protocol's functions. These functions are exported from WebAssembly (Wasm) modules, and can be used in any environment that can execute Wasm functions (like your web browser!). tip The Polywrap JavaScript client allows the app to use any deployed Wrap. After instantiating the client, the app can call queries to the Wrap using familiar GraphQL or our streamlined invocation syntax. All that is needed is: The URI specifying the ENS or IPFS resolving to content containing the WrapSpecifying the function and arguments provided by that Wrap For detailed information on how to integrate in apps, take a look at our Quick Start guide. For a guide on how to build your own Polywrap and deploy it for other developers to integrate into their own app, see our Creating a Wasm Wrap guide. "},{"title":"Query Types","type":0,"sectionRef":"#","url":"/demos/uniswapv3/types/query-types","content":"","keywords":""},{"title":"AddLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#addliquidityoptions","content":"Union of MintOptions and IncreaseOptions; one of either recipient or tokenId is required. type AddLiquidityOptions { recipient: String # The account that should receive the minted NFT. createPool: Boolean # Creates pool if not initialized before mint. Ignored if recipient is not null. tokenId: BigInt # Indicates the ID of the position to increase liquidity for. Ignored if recipient is not null. slippageTolerance: String! deadline: BigInt! useNative: Token token0Permit: PermitOptions token1Permit: PermitOptions }  "},{"title":"ClaimOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#claimoptions","content":"Options to specify when claiming rewards. type ClaimOptions { tokenId: BigInt! # The id of the NFT recipient: String! # Address to send rewards to. amount: BigInt # The amount of `rewardToken` to claim. 0 claims all. }  "},{"title":"CollectOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#collectoptions","content":"Options to specify when calling collectCallParameters(...) to collect liquidity provider rewards or removeCallParameters(...) to exit a liquidity position. type CollectOptions { tokenId: BigInt! # Indicates the ID of the position to collect for. Ignored when CollectOptions is as property of RemoveLiquidityOptions for use in removeCallParameters(...). expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned recipient: String! # The account that should receive the tokens. }  "},{"title":"CommonAddLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#commonaddliquidityoptions","content":"Options for producing the calldata to add liquidity. type CommonAddLiquidityOptions { slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false token0Permit: PermitOptions # The optional permit parameters for spending token0 token1Permit: PermitOptions # The optional permit parameters for spending token1 }  "},{"title":"FullWithdrawOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#fullwithdrawoptions","content":"Options to specify when withdrawing tokens type FullWithdrawOptions { owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw. data: String # Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner. tokenId: BigInt! recipient: String! amount: BigInt }  "},{"title":"IncentiveKey​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#incentivekey","content":"Represents a unique staking program. type IncentiveKey { rewardToken: Token! # The token rewarded for participating in the staking program. pool: Pool! # The pool that the staked positions must provide in. startTime: BigInt! # The time when the incentive program begins. endTime: BigInt! # The time that the incentive program ends. refundee: String! # The address which receives any remaining reward tokens at `endTime`. }  "},{"title":"NextTickResult​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#nexttickresult","content":"Return value of nextInitializedTickWithinOneWord(...) type NextTickResult { index: Int32! # Tick index of returned next tick found: Boolean! # True if the returned tick index represents an initialized tick, or false if max or min tick are returned instead }  "},{"title":"NFTPermitOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#nftpermitoptions","content":"Permission parameters for NFT transfers, in case the transaction is being sent by an account that does not own the NFT type NFTPermitOptions { v: PermitV! r: String! s: String! deadline: BigInt! spender: String! }  "},{"title":"PoolChangeResult​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#poolchangeresult","content":"Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...) type PoolChangeResult { amount: TokenAmount! # input or output amount resulting from simulated swap nextPool: Pool! # Pool state after simulated swap }  "},{"title":"QuoteOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#quoteoptions","content":"Optional arguments to send to the quoter. type QuoteOptions { sqrtPriceLimitX96: BigInt # The optional price limit for the trade. }  "},{"title":"RemoveLiquidityOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#removeliquidityoptions","content":"Options for producing the calldata to exit a position. type RemoveLiquidityOptions { tokenId: BigInt! # The ID of the token to exit liquidityPercentage: String! # The percentage of position liquidity to exit. slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false. permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT collectOptions: CollectOptions! # Parameters to be passed on to collect; tokenId is ignored. }  "},{"title":"SafeTransferOptions​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#safetransferoptions","content":"Options to specify when calling safeTransferFrom(...) to transfer an NFT type SafeTransferOptions { sender: String! # The account sending the NFT. recipient: String! # The account that should receive the NFT. tokenId: BigInt! # The id of the token being sent. data: String # The optional parameter that passes data to the `onERC721Received` call for the staker }  "},{"title":"TradeRoute​","type":1,"pageTitle":"Query Types","url":"/demos/uniswapv3/types/query-types#traderoute","content":"Input used to create a trade type TradeRoute { route: Route! # The route of the trade amount: TokenAmount! # The amount being passed in or out, depending on the trade type }  "},{"title":"Polywrap Client","type":0,"sectionRef":"#","url":"/quick-start/polywrap-client","content":"","keywords":""},{"title":"NodeJS application boilerplate​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#nodejs-application-boilerplate","content":"We'll be using a simple NodeJS application boilerplate for this guide. Using npm init or yarn init within a directory initialize an empty NodeJS project. Within package.json, change the type of the project to &quot;module&quot;. This is not required as you can also use require, but we prefer using import statements. package.json { &quot;name&quot;: &quot;my-app-name&quot;, //... &quot;type&quot;: &quot;module&quot;, //... }  Add an index.js file with the following code: index.js async function main() { // your code goes here... } main() .then(() =&gt; { process.exit(0); }) .catch((error) =&gt; { console.error(error); process.exit(1); });  And that's it! Use this boilerplate to try out code within this guide. "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#install-the-polywrap-client","content":"Using NPM: npm install --save @polywrap/client-js  Using yarn: yarn add @polywrap/client-js  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#invoking-your-first-wrap","content":"tip The term &quot;Wrap&quot; and &quot;Wrapper&quot; are interchangeable. &quot;Wrapper&quot; is the old way in which we used to call Wraps, so don't get confused if you happen to come accross this term! In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your index.js file, import the PolywrapClient and instantiate it: index.js import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  At this point, you can already invoke Wraps! In the simple example below, we will invoke the Logger Wrap within our main function: const result = await client.invoke({ uri: &quot;ens/logger.polytest.eth&quot;, method: &quot;info&quot;, args: { message: &quot;Hello Polywrap!&quot;, }, }); console.log(result);  Running the application using node index.js, you should now see two lines appear in your console: Hello Polywrap! { ok: true, value: true }  The first line is printed by the Logger Wrap, while the second line shows the structure of the InvokeResult object. "},{"title":"What's going on here?​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#whats-going-on-here","content":"Using the Polywrap Client, we are invoking the info method of a Wrap found under the WRAP URI ens/logger.polytest.eth called the Logger Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. "},{"title":"The InvokeResult object​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#the-invokeresult-object","content":"The InvokeResult object can have one of two structures: A successful Wrap invocation returns { ok: true, value: ... } with value being the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation returns { ok: false, error: ... } with error describing the reason for invocation failure. Although not particularly useful in our last example, our next example leverages the fact that Wrap invocations return a value. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true use-case: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V2 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the DAI token, and check the total market supply. We are also checking each result for errors. const daiResult = await client.invoke({ uri: &quot;ens/goerli/v2.uniswap.wrappers.eth&quot;, method: &quot;fetchTokenData&quot;, args: { address: &quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if(!daiResult.ok) { console.log(daiResult.error) return; } console.log(daiResult.value); const totalSupplyResult = await client.invoke({ uri: &quot;ens/goerli/v2.uniswap.wrappers.eth&quot;, method: &quot;fetchTotalSupply&quot;, args: { token: daiResult.value, }, }); if(!totalSupplyResult.ok) { console.log(totalSupplyResult.error); return; } console.log(totalSupplyResult.value);  "},{"title":"Compose everything​","type":1,"pageTitle":"Polywrap Client","url":"/quick-start/polywrap-client#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. In this chapter's last example, we will use two separate SDKs to figure out the IPFS hash behind the Logger Wrap's ENS domain record, then fetch that Wrap's schema (more about that in the next chapter). First, we will use the Ens Resolver Wrap to resolve the ENS domain to an IPFS Wrap URI. const client = new PolywrapClient(); // We first want to resolve the ENS address into an IPFS WRAP URI const resolutionResult = await client.invoke({ uri: &quot;ens/ens-resolver.polywrap.eth&quot;, method: &quot;tryResolveUri&quot;, args: { authority: &quot;ens&quot;, path: &quot;ens/logger.polytest.eth&quot;, }, }); if (!resolutionResult.ok) { console.log(resolutionResult.error); return; } console.log(resolutionResult.value);  Now, if we look at the uri property of resolutionResult.value, we will see a WRAP URI Once we have the IPFS hash, we will use the IPFS Wrap to fetch the contents of the Wrap's schema file, and print them out. // Extract the IPFS CID from the resolution result's URI const cid = resolutionResult.value.uri.replace(&quot;ipfs/&quot;, &quot;&quot;); // Since the CID is a directory, we need to add a path to the Wrap's schema file const catResult = await client.invoke({ uri: &quot;ens/ipfs.polywrap.eth&quot;, method: &quot;cat&quot;, args: { cid: cid + &quot;/schema.graphql&quot;, }, }); console.log(catResult); if (!catResult.ok) { console.log(catResult.error); return; } // Turn the returned buffer into a string and log it const schema = catResult.value.toString(); console.log(schema);  In this example, we printed out a Wrap's Schema file. This is the definition of what types and methods are present within a Wrap, and we'll talk more about it in the next section. "},{"title":"Polywrap CLI","type":0,"sectionRef":"#","url":"/quick-start/polywrap-cli","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#installation","content":"To install the Polywrap CLI, add the polywrap package as a dev dependency to your project: NPM: npm i --save-dev polywrap  Yarn: yarn add --dev polywrap  You can also install the Polywrap CLI globally: NPM: npm i -g polywrap  Yarn: yarn global add polywrap  "},{"title":"Overview​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#overview","content":"The Polywrap CLI allows us not only to build, test, and deploy Wraps, but also generate types for our applications which use the Polywrap Client. This tutorial assumes that you installed polywrap globally, but you can always prefix the commands with npx or yarn run to run the locally installed version of your Polywrap CLI. You can see all available commands by running: polywrap help  "},{"title":"Create a Polywrap-powered application​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#create-a-polywrap-powered-application","content":"tip If you already have an application you want to add Polywrap to, it is advised that you still follow this guide and transfer/modify the polywrap.yaml and src/schema.graphql files once you're done with this tutorial. The Polywrap CLI can be used to quickly set up a template application. For this tutorial, we will create a sample Node application written in Typescript and use the Polywrap Client to invoke multiple Wraps. To set up a Polywrap-powered application, run: polywrap create app typescript-node my-application  This uses the create command to set up a template Node application written in Typescript called my-application inside the my-application/ directory. Now we want to navigate into the application folder and install its dependencies. cd my-application yarn  If you take a look at package.json, you'll find the app depends on @polywrap/client-js and has a dev dependency on polywrap, with the addition of minimal dev dependencies that allow us to develop the app using Typescript. Now let's take a look at some of the files Polywrap works with. "},{"title":"The Polywrap Manifest (polywrap.yaml)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#the-polywrap-manifest-polywrapyaml","content":"In order for the Polywrap CLI to know what it's working with, it needs a Polywrap Manifest file to obtain some basic information about your project. This is the polywrap.yaml file. It has a structure similar to this: polywrap.yaml format: 0.2.0 project: name: Sample type: app/typescript source: schema: ./schema.graphql  The format property denotes the version of the Polywrap Manifest format. Under project, you can set the name field to the name of your application, while the type field describes the project type, thus letting the CLI know how to interact with the application code. Under the source section, we have a schema field with a path that leads to a Schema file. In the context of a Polywrap-powered application project, this file defines which Wraps our application imports/uses. This will come in handy later when we'll use the CLI to generate types and code which your app will use. "},{"title":"The Schema File (schema.graphql)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#the-schema-file-schemagraphql","content":"Every Polywrap project has a Schema file - it defines the types found within the project, what Wraps the project imports, and, in the case of a WASM Wrap, the methods that Wrap exposes. In the context of an application project, the Schema file defines which Wraps our application imports and is used by the CLI to generate code with which we can invoke our Wraps in a type-safe manner. Taking a look at the file, we can see two import statements: schema.graphql #import * into HelloWorld from &quot;ens/helloworld.polytest.eth&quot; #import * into Ethereum from &quot;ens/ethereum.polywrap.eth&quot;  An import statement defines which Wraps we are importing, therefore using within our application. Imports are namespaced - the Wrap found under the WRAP URI ens/helloworld.polytest.eth is going to be found within the HelloWorld_ namespace. "},{"title":"Generating types (codegen)​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#generating-types-codegen","content":"caution While we used Javascript in previous samples, Polywrap is native to Typescript, and all future examples will be written in Typescript. Now that we know how we can &quot;import&quot; Wraps into our application, we can use the codegen command inside the Polywrap CLI to generate types that represent our Wraps which we can use within our application. To generate types, all we need to do is run the codegen command: polywrap codegen  This will generate types inside the src/wrap directory which you will use within your application. "},{"title":"IntelliSense your way to Victory!​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#intellisense-your-way-to-victory","content":"Now that we have our types generated, we can take a look at our sample application's src/index.ts file. Let's first take a look at some of the imports: import { HelloWorld_Module, Ethereum_Module } from &quot;./wrap&quot;;  Here we can see that we've imported Module types that represent our Wraps, according to their specified namespace. Using these types, we can invoke our Wraps in a type-safe manner, without having to repeatedly specify the Wrap URI: const client = new PolywrapClient(); await HelloWorld_Module.logMessage({ message: &quot;Hello there&quot; }, client);  This allows us to write all of our code in a type-safe manner, and allows for IDEs like VS Code to give us autocompletion suggestions via IntelliSense. Now we can explore our Wraps by simply importing them and trying them out! "},{"title":"A real-world exmaple, revisited​","type":1,"pageTitle":"Polywrap CLI","url":"/quick-start/polywrap-cli#a-real-world-exmaple-revisited","content":"Let's revisit our Uniswap V2 Wrap example from the Quick Start tutorial. If we wanted to invoke the Uniswap V2 Wrap without codegen, we had to write the following code: const daiResult = await client.invoke({ uri: &quot;ens/goerli/v2.uniswap.wrappers.eth&quot;, method: &quot;fetchTokenData&quot;, args: { address: &quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot;, chainId: &quot;MAINNET&quot;, }, });  Instead, we can now add an import statement for the Uniswap V2 Wrap to our schema.graphql file: schema.graphql #import * into UniswapV2 from &quot;ens/goerli/v2.uniswap.wrappers.eth&quot;  Running codegen now will add all types defined inside the Uniswap V2 Wrap to our wrap folder: polywrap codegen  We can now import the UniswapV2_Module and supporting types into our index.ts file: import { UniswapV2_ChainIdEnum, UniswapV2_Module } from &quot;./wrap&quot;;  We can now invoke the Uniswap V2 Wrap by writing: const fetchTokenDataResult = await UniswapV2_Module.fetchTokenData( { address: &quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot;, chainId: UniswapV2_ChainIdEnum.MAINNET, }, client );  Already inside the invocation, we can see that the chainId is an enum type, with all supported networks already listed. Polywrap also takes care of required and optional arguments, and if you play around, you will find that we omitted the name and symbol optional invocation arguments. If fetchTokenDataResult.ok is true, its value will now have a type of UniswapV2_Token: if(!fetchTokenDataResult.ok) { console.error(fetchTokenDataResult.error); return; } // token is now of type UniswapV2_Token found in &quot;./wrap&quot; const token = fetchTokenDataResult.value; console.log(token);  As you can see, Polywrap allows us to invoke any SDK or other piece of executable logic packaged as a Wrap in a type-safe manner, accross a multitude of platforms and languages! Of course, by using the Polywrap CLI you can build your own Wraps which you will be able to run anywhere where there's a Polywrap Client. Make sure to check out our list of supported (and coming) clients, and proceed to the next section to see what Wraps are readily available! "},{"title":"What Wraps are available?","type":0,"sectionRef":"#","url":"/quick-start/what-wraps-are-available","content":"","keywords":""},{"title":"Awesome-Polywrap (WIP)​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#awesome-polywrap-wip","content":"A curated collection of interesting Polywrap-related projects (including WASM and Plugin Wraps) can be found on our awesome-polywrap github repo. This list is a work-in-progress, and as such will be updated regularly with new Projects. If you have a Polywrap-related project, feel free to submit a pull request or get in touch so that we can add your project to the repo! "},{"title":"Wrappers.io​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#wrappersio","content":"Most wraps reside on our service, wrappers.io. On wrappers.io, you can see all available Wraps, whether they have an associated ENS record or not. You can also You can also see Wraps registered on wrappers.io that have an associated ENS record, or you can even filter them by the Controller of the ENS doman. caution Make sure that you connect your wallet in order to be able to browse Wraps! "},{"title":"Polywrap Integrations repo​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#polywrap-integrations-repo","content":"The Polywrap Integrations repo is a repository of integrations built by various developers on top of Polywrap. It also contains live demos for some of the developed Wraps "},{"title":"Do it yourself​","type":1,"pageTitle":"What Wraps are available?","url":"/quick-start/what-wraps-are-available#do-it-yourself","content":"If you can't find a Wrap that suits you, maybe it's time to build your own WASM Wrap or maybe even build a Plugin Wrap! "},{"title":"Codegen","type":0,"sectionRef":"#","url":"/reference/cli/commands/codegen","content":"Codegen Usage: polywrap codegen|g [options] Generate Code For Polywrap Projects Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap manifest file (default: polywrap.yaml | polywrap.yml) -g, --codegen-dir &lt;path&gt; Output directory for the generated code (default: ./src/wrap) -p, --publish-dir &lt;path&gt; Output path for the built schema and manifest (default: ./build) -s, --script &lt;path&gt; Path to a custom generation script (JavaScript | TypeScript) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -h, --help display help for command ","keywords":""},{"title":"Build","type":0,"sectionRef":"#","url":"/reference/cli/commands/build","content":"Build Usage: polywrap build|b [options] Build Polywrap Projects (type: interface, wasm) Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Build manifest file (default: polywrap.yaml | polywrap.yml) -o, --output-dir &lt;path&gt; Output directory for build results (default: ./build) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient -n, --no-codegen Skip code generation -s, --strategy &lt;strategy&gt; Strategy to use for building the wrapper (default: &quot;vm&quot;) -w, --watch Automatically rebuild when changes are made (default: false) -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -h, --help display help for command ","keywords":""},{"title":"Create","type":0,"sectionRef":"#","url":"/reference/cli/commands/create","content":"Create Usage: polywrap create|c [options] [command] Create New Projects Options: -h, --help display help for command Commands: wasm [options] &lt;language&gt; &lt;name&gt; Create a Polywrap wasm wrapper langs: assemblyscript, rust, interface app [options] &lt;language&gt; &lt;name&gt; Create a Polywrap application langs: typescript-node, typescript-react plugin [options] &lt;language&gt; &lt;name&gt; Create a Polywrap plugin langs: typescript help [command] display help for command ","keywords":""},{"title":"Deploy","type":0,"sectionRef":"#","url":"/reference/cli/commands/deploy","content":"Deploy Usage: polywrap deploy|d [options] Deploys Polywrap Projects Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Deploy manifest file (default: polywrap.yaml | polywrap.yml) -o, --output-file &lt;path&gt; Output file path for the deploy result -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -h, --help display help for command ","keywords":""},{"title":"Infra","type":0,"sectionRef":"#","url":"/reference/cli/commands/infra","content":"Infra Usage: polywrap infra|i &lt;action&gt; [options] Modular Infrastructure-As-Code Orchestrator Arguments: action Infra allows you to execute the following commands: up Start Polywrap infrastructure down Stop Polywrap infrastructure config Validate and display Polywrap infrastructure's bundled docker-compose manifest vars Show Polywrap infrastructure's required .env variables (choices: &quot;up&quot;, &quot;down&quot;, &quot;vars&quot;, &quot;config&quot;) Options: -m, --manifest-file &lt;path&gt; Path to the Polywrap Infra manifest file (default: polywrap.infra.yaml | polywrap.infra.yml) -o, --modules &lt;module,module&gt; Use only specified modules -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -h, --help display help for command ","keywords":""},{"title":"Docgen","type":0,"sectionRef":"#","url":"/reference/cli/commands/docgen","content":"Docgen Usage: polywrap docgen|o &lt;action&gt; [options] Generate wrapper documentation Arguments: action schema Generate GraphQL schema docusaurus Generate Docusaurus markdown jsdoc Generate JSDoc markdown (choices: &quot;schema&quot;, &quot;docusaurus&quot;, &quot;jsdoc&quot;) Options: -m, --manifest-file &lt;path&gt; Path to the project manifest file (default: polywrap.yaml | polywrap.yml) -g, --docgen-dir &lt;path&gt; Output directory for generated docs (default: ./docs) -c, --client-config &lt;config-path&gt; Add custom configuration to the PolywrapClient -i, --imports Also generate docs for dependencies -v, --verbose Verbose output (default: false) -q, --quiet Suppress output (default: false) -h, --help display help for command ","keywords":""},{"title":"Test","type":0,"sectionRef":"#","url":"/reference/cli/commands/test","content":"Test Usage: polywrap [options] [command] Options: -h, --help display help for command Commands: build|b [options] Build Polywrap Projects (type: interface, wasm) codegen|g [options] Generate Code For Polywrap Projects create|c Create New Projects deploy|d [options] Deploys Polywrap Projects infra|i [options] &lt;action&gt; Modular Infrastructure-As-Code Orchestrator run|r [options] Runs Workflows docgen|o [options] &lt;action&gt; Generate wrapper documentation manifest|m Inspect &amp; Migrade Polywrap Manifests help [command] display help for command ","keywords":""},{"title":"Manifest","type":0,"sectionRef":"#","url":"/reference/cli/commands/manifest","content":"Manifest Usage: polywrap manifest|m [options] [command] Inspect &amp; Migrade Polywrap Manifests Options: -h, --help display help for command Commands: schema|s [options] [type] Prints out the schema for the current manifest format. migrate|m [options] [type] Migrates the polywrap project manifest to the latest version. help [command] display help for command ","keywords":""},{"title":"The Polywrap CLI (polywrap)","type":0,"sectionRef":"#","url":"/reference/cli/polywrap-cli","content":"","keywords":""},{"title":"Documentation​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#documentation","content":"https://docs.polywrap.io/reference/cli/polywrap-cli "},{"title":"Examples​","type":1,"pageTitle":"The Polywrap CLI (polywrap)","url":"/reference/cli/polywrap-cli#examples","content":"Demos: https://github.com/polywrap/demos Integrations: https://github.com/polywrap/integrations "},{"title":"Client Config","type":0,"sectionRef":"#","url":"/reference/clients/js/client-config","content":"","keywords":""},{"title":"Redirects​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#redirects","content":"The redirects property can be used to redirect queries from one URI to another. This redirection occurs in all queries to the URI, even in cases where one wrapper calls another during its execution. interface UriRedirect&lt;TUri = string&gt; { from: TUri; // uri to redirect from to: TUri; // uri to redirct to }  "},{"title":"Plugins​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#plugins","content":"Polywrap plugin wrappers are written in a Client’s native language. They offer a user experience similar to that of wrappers, but with different benefits. Plugins are declared and constructed in the Client config by providing an array of PluginRegistration. Each PluginRegistration contains the URI at which the plugin will be queried and a PluginPackage. A PluginPackage is a factory function the PolywrapClient uses to create new instances of the plugin. Each plugin can have its own configuration. interface PluginRegistration&lt;TUri = string&gt; { uri: TUri; // URI that will be redirected to plugin plugin: PluginPackage&lt;unknown&gt;; // plugin factory }  "},{"title":"Interfaces​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#interfaces","content":"Users can declare custom implementations for an interface by providing the interface URI and one or more URIs that resolve to implementations. interface InterfaceImplementations&lt;TUri = string&gt; { interface: TUri; // interface URI implementations: TUri[]; // URIs of wrappers implementing interface }  "},{"title":"Envs​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#envs","content":"Because wrapper calls are sandboxed and stateless, they cannot access the global state that persists outside the call. Users can instead provide wrapper-specific environmental variables in the Client configuration. Wrapper developers are expected to inform users which environmental variables should be set for their API. interface Env&lt;TUri = string&gt; { uri: TUri; // URI of wrapper env: Record&lt;string, unknown&gt;; // environmental variables used by the module }  "},{"title":"Uri Resolvers​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#uri-resolvers","content":"Users can extend the Client's URI resolution capabilities by providing new implementations of UriResolver. A UriResolver takes a URI as input and resolves it to a wrapper or plugin. By default, the Client includes an ExtendableUriResolver that can accept ENS, IPFS, and filesystem URIs as input and fetch wrappers from those sources. It is &quot;extendable&quot; in the sense that it works with any plugin or wrapper that implements the UriResolverInterface. The Client's default resolvers can also resolve URI's that point to redirects, plugins, and cached wrappers. abstract class UriResolver { public abstract get name(): string; public abstract resolveUri( uri: Uri, client: Client, cache: ApiCache, resolutionPath: UriResolutionStack ): Promise&lt;UriResolutionResult&gt;; }  "},{"title":"Default Configuration​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#default-configuration","content":"The current default ClientConfig for the JavaScript implementation of the PolywrapClient can be viewed on Github. When a user provides a ClientConfig to the Client, the default configuration is still applied. The default configuration is modified by the user's configuration. "},{"title":"Sanitization​","type":1,"pageTitle":"Client Config","url":"/reference/clients/js/client-config#sanitization","content":"The Client's configuration is sanitized when the Client is constructed. During the sanitization process, URI strings are validated and transformed into instances of the Uri class. "},{"title":"PolywrapClient Config Builder","type":0,"sectionRef":"#","url":"/reference/clients/js/client-config-builder-js","content":"","keywords":""},{"title":"Methods​","type":1,"pageTitle":"PolywrapClient Config Builder","url":"/reference/clients/js/client-config-builder-js#methods","content":"The config builder currently supports 3 methods: add(config: Partial&lt;ClientConfig&gt;)​ Appends each property of the supplied config object to the corresponding array of the builder's config. addDefaults()​ Adds the defaultClientConfig object. build()​ Returns a sanitized config object from the builder's config. "},{"title":"@polywrap/asyncify-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/asyncify-js","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/asyncify-js","url":"/reference/clients/js/libraries/asyncify-js#usage","content":"import { AsyncWasmInstance } from &quot;@polywrap/asyncify-js&quot;; // module.wasm must be asyncify enabled const module: ArrayBuffer = getModule(&quot;./module.wasm&quot;); const memory = new WebAssembly.Memory({ initial: 1 }); const instance = await AsyncWasmInstance.createInstance({ module, imports: { my: { custom_import: async (arg: number): Promise&lt;number&gt; =&gt; { return await someAsyncCall(arg); } }, env: { memory } } }); await instance.exports.main();  "},{"title":"@polywrap/core-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/core-js","content":"@polywrap/core-js A TypeScript / JavaScript implementation of the WRAP standard, including all fundamental types &amp; algorithms.","keywords":""},{"title":"@polywrap/msgpack-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/msgpack-js","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/msgpack-js","url":"/reference/clients/js/libraries/msgpack-js#usage","content":"import { msgpackEncode, msgpackDecode } from &quot;@polywrap/msgpack-js&quot;; const test = { foo: 5, bar: [true, false], baz: { prop: &quot;value&quot; } }; const encoded: Uint8Array = msgpackEncode(test); const decoded = msgpackDecode(encoded); expect(decoded).toEqual(test);  "},{"title":"@polywrap/os-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/os-js","content":"@polywrap/os-js Utility functions for interacting with files and directories.","keywords":""},{"title":"@polywrap/package-validation","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/package-validation","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/package-validation","url":"/reference/clients/js/libraries/package-validation#description","content":"Utilities for the validation of WRAP packages. Allows to implement custom constraints to check if a WRAP package is valid The main two entities here are WasmPackageValidator and FileSystemPackageReader "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/package-validation","url":"/reference/clients/js/libraries/package-validation#usage","content":"import { WasmPackageValidator, FileSystemPackageReader } from &quot;@polywrap/package-validation&quot; // Size unit is KB const validator = new WasmPackageValidator({ maxSize: 1_000_000, maxFileSize: 1_000_000, maxModuleSize: 1_000_000, maxNumberOfFiles: 10, }); const reader = new FileSystemPackageReader(&quot;absolute/path/to/package/folder&quot;) const result = await validator.validate(result)  "},{"title":"@polywrap/polywrap-manifest-types-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/polywrap-manifest-types-js","content":"@polywrap/polywrap-manifest-types-js TypeScript typings for the @polywrap/polywrap-manifest-schemas package.","keywords":""},{"title":"@polywrap/client-js","type":0,"sectionRef":"#","url":"/reference/clients/js/client-js","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#installation","content":"npm install --save @polywrap/client-js  "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#usage","content":""},{"title":"Instantiate the client​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#instantiate-the-client","content":"import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  "},{"title":"Invoke a wrapper​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#invoke-a-wrapper","content":"await client.invoke({ uri: &quot;ens/rinkeby/helloworld.dev.polywrap.eth&quot;, method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot; } });  "},{"title":"Configure the client​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#configure-the-client","content":"const config = { // redirect queries from one uri to another redirects: [ { from: &quot;wrap://ens/from.eth&quot;, to: &quot;wrap://ens/to.eth&quot;, } ], // declare and configure plugin wrappers plugins: [ { uri: &quot;wrap://ens/ipfs.polywrap.eth&quot;, plugin: ipfsPlugin({}), }, ], // declare interface implementations interfaces: [ { interface: &quot;wrap://ens/uri-resolver.core.polywrap.eth&quot;, implementations: [ &quot;wrap://ens/ipfs-resolver.polywrap.eth&quot;, ], }, ], // set environmental variables for a wrapper envs: [ { uri: &quot;wrap://ens/ipfs.polywrap.eth&quot;, env: { provider: &quot;https://ipfs.wrappers.io&quot;, }, }, ], // ADVANCED USAGE: // customize URI resolution resolver: new RecursiveResolver( new PackageToWrapperCacheResolver(wrapperCache, [ new LegacyRedirectsResolver(), new LegacyPluginsResolver(), new ExtendableUriResolver(), ]) ), // custom wrapper cache wrapperCache: new WrapperCache(), // tracer configuration - see @polywrap/tracing-js package tracerConfig: { ... }, };  // create a client by modifying the default configuration bundle const client = new PolywrapClient(config); // or remove and replace the default configuration const altClient = new PolywrapClient(config, { noDefaults: true });  "},{"title":"Reference​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#reference","content":""},{"title":"Constructor​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#constructor","content":"/** * Instantiate a PolywrapClient * * @param config - a whole or partial client configuration * @param options - { noDefaults?: boolean } */ constructor(config?: Partial&lt;PolywrapClientConfig&lt;string | Uri&gt;&gt;, options?: { noDefaults?: boolean; });  "},{"title":"getConfig​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getconfig","content":"/** * Returns the configuration used to instantiate the client * * @returns an immutable Polywrap client config */ getConfig(): PolywrapClientConfig&lt;Uri&gt;;  "},{"title":"setTracingEnabled​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#settracingenabled","content":"/** * Enable tracing for intricate debugging * * @remarks * Tracing uses the @polywrap/tracing-js package * * @param tracerConfig - configure options such as the tracing level * @returns void */ setTracingEnabled(tracerConfig?: Partial&lt;TracerConfig&gt;): void;  "},{"title":"getRedirects​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getredirects","content":"/** * returns all uri redirects from the configuration used to instantiate the client * * @returns an array of uri redirects */ getRedirects(): readonly UriRedirect&lt;Uri&gt;[];  "},{"title":"getPlugins​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getplugins","content":"/** * returns all plugin registrations from the configuration used to instantiate the client * * @returns an array of plugin registrations */ getPlugins(): readonly PluginRegistration&lt;Uri&gt;[];  "},{"title":"getPluginByUri​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getpluginbyuri","content":"/** * returns a plugin package from the configuration used to instantiate the client * * @param uri - the uri used to register the plugin * @returns a plugin package, or undefined if a plugin is not found at the given uri */ getPluginByUri&lt;TUri extends Uri | string&gt;(uri: TUri): PluginPackage&lt;unknown&gt; | undefined;  "},{"title":"getInterfaces​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getinterfaces","content":"/** * returns all interfaces from the configuration used to instantiate the client * * @returns an array of interfaces and their registered implementations */ getInterfaces(): readonly InterfaceImplementations&lt;Uri&gt;[];  "},{"title":"getEnvs​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getenvs","content":"/** * returns all env registrations from the configuration used to instantiate the client * * @returns an array of env objects containing wrapper environmental variables */ getEnvs(): readonly Env&lt;Uri&gt;[];  "},{"title":"getUriResolver​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#geturiresolver","content":"/** * returns the URI resolver from the configuration used to instantiate the client * * @returns an object that implements the IUriResolver interface */ getUriResolver(): IUriResolver&lt;unknown&gt;;  "},{"title":"getEnvByUri​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getenvbyuri","content":"/** * returns an env (a set of environmental variables) from the configuration used to instantiate the client * * @param uri - the URI used to register the env * @returns an env, or undefined if an env is not found at the given URI */ getEnvByUri&lt;TUri extends Uri | string&gt;(uri: TUri): Env&lt;Uri&gt; | undefined;  "},{"title":"getManifest​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getmanifest","content":"/** * returns a package's wrap manifest * * @param uri - a wrap URI * @param options - { noValidate?: boolean } * @returns a Result containing the WrapManifest if the request was successful */ getManifest&lt;TUri extends Uri | string&gt;(uri: TUri, options?: GetManifestOptions): Promise&lt;Result&lt;WrapManifest, Error&gt;&gt;;  "},{"title":"getFile​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getfile","content":"/** * returns a file contained in a wrap package * * @param uri - a wrap URI * @param options - { path: string; encoding?: &quot;utf-8&quot; | string } * @returns a Promise of a Result containing a file if the request was successful */ getFile&lt;TUri extends Uri | string&gt;(uri: TUri, options: GetFileOptions): Promise&lt;Result&lt;string | Uint8Array, Error&gt;&gt;;  "},{"title":"getImplementations​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#getimplementations","content":"/** * returns the interface implementations associated with an interface URI * from the configuration used to instantiate the client * * @param uri - a wrap URI * @param options - { applyRedirects?: boolean } * @returns a Result containing URI array if the request was successful */ getImplementations&lt;TUri extends Uri | string&gt;(uri: TUri, options?: GetImplementationsOptions): Result&lt;TUri[], Error&gt;;  "},{"title":"query​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#query","content":"/** * Invoke a wrapper using GraphQL query syntax * * @remarks * This method behaves similar to the invoke method and allows parallel requests, * but the syntax is more verbose. If the query is successful, data will be returned * and the `error` value of the returned object will be undefined. If the query fails, * the data property will be undefined and the error property will be populated. * * @param options - { * // The Wrapper's URI * uri: TUri; * * // The GraphQL query to parse and execute, leading to one or more Wrapper invocations. * query: string | QueryDocument; * * // Variables referenced within the query string via GraphQL's '$variable' syntax. * variables?: TVariables; * } * * @returns A Promise containing an object with either the data or an error */ query&lt;TData extends Record&lt;string, unknown&gt; = Record&lt;string, unknown&gt;, TVariables extends Record&lt;string, unknown&gt; = Record&lt;string, unknown&gt;, TUri extends Uri | string = string&gt;(options: QueryOptions&lt;TVariables, TUri&gt;): Promise&lt;QueryResult&lt;TData&gt;&gt;;  "},{"title":"invokeWrapper​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#invokewrapper","content":"/** * Invoke a wrapper using standard syntax and an instance of the wrapper * * @param options - { * // The Wrapper's URI * uri: TUri; * * // Method to be executed. * method: string; * * //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments. * args?: Record&lt;string, unknown&gt; | Uint8Array; * * // Env variables for the wrapper invocation. * env?: Record&lt;string, unknown&gt;; * * resolutionContext?: IUriResolutionContext; * * // if true, return value is a msgpack-encoded byte array * encodeResult?: boolean; * } * * @returns A Promise with a Result containing the return value or an error */ invokeWrapper&lt;TData = unknown, TUri extends Uri | string = string&gt;(options: InvokerOptions&lt;TUri&gt; &amp; { wrapper: Wrapper; }): Promise&lt;InvokeResult&lt;TData&gt;&gt;;  "},{"title":"invoke​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#invoke","content":"/** * Invoke a wrapper using standard syntax. * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper. * * @param options - { * // The Wrapper's URI * uri: TUri; * * // Method to be executed. * method: string; * * //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments. * args?: Record&lt;string, unknown&gt; | Uint8Array; * * // Env variables for the wrapper invocation. * env?: Record&lt;string, unknown&gt;; * * resolutionContext?: IUriResolutionContext; * * // if true, return value is a msgpack-encoded byte array * encodeResult?: boolean; * } * * @returns A Promise with a Result containing the return value or an error */ invoke&lt;TData = unknown, TUri extends Uri | string = string&gt;(options: InvokerOptions&lt;TUri&gt;): Promise&lt;InvokeResult&lt;TData&gt;&gt;;  "},{"title":"subscribe​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#subscribe","content":"/** * Invoke a wrapper at a regular frequency (within ~16ms) * * @param options - { * // The Wrapper's URI * uri: TUri; * * // Method to be executed. * method: string; * * //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments. * args?: Record&lt;string, unknown&gt; | Uint8Array; * * // Env variables for the wrapper invocation. * env?: Record&lt;string, unknown&gt;; * * resolutionContext?: IUriResolutionContext; * * // if true, return value is a msgpack-encoded byte array * encodeResult?: boolean; * * // the frequency at which to perform the invocation * frequency?: { * ms?: number; * sec?: number; * min?: number; * hours?: number; * } * } * * @returns A Promise with a Result containing the return value or an error */ subscribe&lt;TData = unknown, TUri extends Uri | string = string&gt;(options: SubscribeOptions&lt;TUri&gt;): Subscription&lt;TData&gt;;  "},{"title":"tryResolveUri​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#tryresolveuri","content":"/** * Resolve a URI to a wrap package, a wrapper, or a uri * * @param options - { uri: TUri; resolutionContext?: IUriResolutionContext } * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful */ tryResolveUri&lt;TUri extends Uri | string&gt;(options: TryResolveUriOptions&lt;TUri&gt;): Promise&lt;Result&lt;UriPackageOrWrapper, unknown&gt;&gt;;  "},{"title":"loadWrapper​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#loadwrapper","content":"/** * Resolve a URI to a wrap package or wrapper. * If the URI resolves to wrap package, load the wrapper. * * @remarks * Unlike other methods, `loadWrapper` does not accept a string URI. * You can create a Uri (from the `@polywrap/core-js` package) using `Uri.from(&quot;wrap://...&quot;)` * * @param uri: the Uri to resolve * @param resolutionContext? a resolution context * @param options - { noValidate?: boolean } * @returns A Promise with a Result containing either a wrapper if successful */ loadWrapper(uri: Uri, resolutionContext?: IUriResolutionContext, options?: DeserializeManifestOptions): Promise&lt;Result&lt;Wrapper, Error&gt;&gt;;  "},{"title":"Development​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#development","content":"The Polywrap JavaScript client is open-source. It lives within the Polywrap toolchain monorepo. Contributions from the community are welcomed! "},{"title":"Build​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#build","content":"nvm use &amp;&amp; yarn install &amp;&amp; yarn build  "},{"title":"Test​","type":1,"pageTitle":"@polywrap/client-js","url":"/reference/clients/js/client-js#test","content":"yarn test  "},{"title":"@polywrap/react","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/react","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#installation","content":"npm install @polywrap/react  "},{"title":"Usage​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#usage","content":""},{"title":"PolywrapProvider​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () =&gt; { return ( &lt;PolywrapProvider&gt; &lt;HelloWorld /&gt; &lt;/PolywrapProvider&gt; ); };  PolywrapProvider Props​ The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: &lt;PolywrapProvider redirects={ [] }/&gt;  Multiple PolywrapProviders​ If you need to use multiple providers, you can do so using the createPolywrapProvider(&quot;...&quot;) method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) =&gt; { return ( &lt;CustomPolywrapProvider&gt; {children} &lt;/CustomPolywrapProvider&gt; ); };  "},{"title":"usePolywrapClient​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient();  "},{"title":"usePolywrapInvoke​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wrappers! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/helloworld.polytest.eth', method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot;, }, });  tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, error, loading } = usePolywrapInvoke({ provider: &quot;custom&quot;, uri: 'ens/helloworld.polytest.eth', method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot;, }, });  "},{"title":"usePolywrapQuery​","type":1,"pageTitle":"@polywrap/react","url":"/reference/clients/js/libraries/react#usepolywrapquery","content":"The usePolywrapQuery hook works the same as the usePolywrapInvoke hook, but uses the client's query syntax instead. const { execute, data, errors, loading } = usePolywrapQuery({ uri: 'ens/helloworld.polytest.eth', query: `{ logMessage(message: &quot;Hello World!&quot;) }`, });  "},{"title":"@polywrap/result","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/result","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/result","url":"/reference/clients/js/libraries/result#description","content":"Result helpers to enable the &quot;Result&quot; pattern. Enables compile-time error checking. "},{"title":"@polywrap/tracing-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/tracing-js","content":"","keywords":""},{"title":"Steps to use tracing​","type":1,"pageTitle":"@polywrap/tracing-js","url":"/reference/clients/js/libraries/tracing-js#steps-to-use-tracing","content":"Run the zipkin client using docker docker run -d -p 9411:9411 openzipkin/zipkin Enable tracing when creating the PolywrapClient const client = new PolywrapClient({ ..., tracingEnabled: true }) Or you can turn on tracing while running the PolywrapClient by calling the tracingEnabled method of PolywrapClient. // Turn tracing off client.tracingEnabled(false); Once you run the app and started producing logs, go to zipkin client which is running on http://localhost:9411. There you can click RUN QUERY button without any filters to show all the logs. "},{"title":"@polywrap/test-env-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/test-env-js","content":"@polywrap/test-env-js Provides functions to setup a test environment with Polywrap CLI and Docker. Description It allows user to initiate the test environment through a javascript function (it's the infra command in the CLI). It also exports the providers and ens addresses expected in the deployments (They are hard coded, because the initiation of the environment is deterministic) Usage Initialization with the simple-storage wrapper. import path from &quot;path&quot;; import { PolywrapClient } from &quot;@polywrap/client-js&quot;; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers, ensAddresses } from &quot;@polywrap/test-env-js&quot;; import * as App from &quot;../types/wrap&quot;; // test wrapper in a test environment export async function foo({ // spin up docker containers for Ganache and IPFS. await initTestEnvironment(); const CONNECTION = { networkNameOrChainId: &quot;testnet&quot; }; // get path to the wrapper in testing const wrapperPath: string = path.join(path.resolve(__dirname), &quot;..&quot;); // build current wrapper with CLI await buildWrapper(wrapperPath); // get URI to the local wrapper build const wrapperUri = `fs/${wrapperPath}/build`; // invoke the wrapper to deploy a contract to the test env const deployContractResponse = await App.SimpleStorage_Module.deployContract( { connection: CONNECTION }, client, wrapperUri ); const contractAddress = deployContractResponse.data as string; // invoke the wrapper to query a contract in the test env const response = await App.SimpleStorage_Module.getData( { address: contractAddr, connection: CONNECTION, }, client, wrapperUri ); }); API ensAddresses, providers - constant addresses and urlsrunCLI - run arbitrary Polywrap CLI commandsinitTestEnvironment - spin up Ganache and IPFS Docker instances stopTestEnvironment - stop DockerbuildWrapper - compile wasm and bindingsbuildAndDeployWrapper - deploy wrapper to the testnet ENS","keywords":""},{"title":"@polywrap/uri-resolvers-extensions-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/uri-resolver-extensions-js","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/uri-resolvers-extensions-js","url":"/reference/clients/js/libraries/uri-resolver-extensions-js#description","content":"Polywrap URI resolver extensions to customize resolution inside of the Polywrap Client. "},{"title":"@polywrap/uri-resolvers","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/uri-resolvers-js","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/uri-resolvers","url":"/reference/clients/js/libraries/uri-resolvers-js#description","content":"URI resolvers to customize URI resolution inside of the Polywrap Client. "},{"title":"@polywrap/wasm-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/wasm-js","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"@polywrap/wasm-js","url":"/reference/clients/js/libraries/wasm-js#description","content":"Wasm wrappers "},{"title":"@polywrap/wrap-manifest-types-js","type":0,"sectionRef":"#","url":"/reference/clients/js/libraries/wrap-manifest-types-js","content":"@polywrap/wrap-manifest-types-js TypeScript typings for the @polywrap/wrap-manifest-schemas package.","keywords":""},{"title":"Reference Documentation","type":0,"sectionRef":"#","url":"/reference/glossary","content":"","keywords":""},{"title":"Command-line Interface (CLI)​","type":1,"pageTitle":"Reference Documentation","url":"/reference/glossary#command-line-interface-cli","content":"CLI\tDescriptionPolywrap CLI\tThe main CLI for Polywrap "},{"title":"Clients​","type":1,"pageTitle":"Reference Documentation","url":"/reference/glossary#clients","content":"Client\tDescriptionTypeScript / JavaScript\tUsable in node.js and the browser. Rust\tComing soon... "},{"title":"Manifests​","type":1,"pageTitle":"Reference Documentation","url":"/reference/glossary#manifests","content":"Coming soon... "},{"title":"Specifications​","type":1,"pageTitle":"Reference Documentation","url":"/reference/glossary#specifications","content":"Coming soon... "},{"title":"Polywrap Schema Compose (@polywrap/schema-compose)","type":0,"sectionRef":"#","url":"/reference/schema/schema-compose","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Polywrap Schema Compose (@polywrap/schema-compose)","url":"/reference/schema/schema-compose#usage","content":"import path from &quot;path&quot;; import { readFileSync } from &quot;fs&quot;; import { ComposerOptions, ComposeFilter, composeSchema } from &quot;@polywrap/schema-compose&quot;; import { TypeInfo } from &quot;@polywrap/schema-parse&quot;; const schemaPath = &quot;input/module.graphql&quot; const schema = readFileSync(schemaPath); const resolveExternal = (uri: string): Promise&lt;string&gt; =&gt; { return Promise.resolve(readFileSync(`imports-ext/${uri}/schema.graphql`) || &quot;&quot;); }; const resolveLocal = (path: string): Promise&lt;string&gt; =&gt; { return Promise.resolve(readFileSync(path) || &quot;&quot;); }; const input: ComposerOptions = { schemas: [{ schema, absolutePath, }], resolvers: { external: resolveExternal, local: resolveLocal, }, output: ComposerFilter.All }; const output: ComposerOutput = composeSchema(input); const { schema: string, typeInfo: TypeInfo } = output;  "},{"title":"@polywrap/schema-bind","type":0,"sectionRef":"#","url":"/reference/schema/schema-bind","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#usage","content":"import { BindOptions, BindOutput, bindSchema } from &quot;@polywrap/schema-bind&quot;; import { parseSchema } from &quot;@polywrap/schema-parse&quot;; const schema = fetch(&quot;schema.graphql&quot;); const abi = parseSchema(schema); const input: BindOptions = { projectName: &quot;Test&quot;, bindLanguage: &quot;wasm-as&quot;, abi, schema, outputDirAbs: &quot;/path/to/output/dir&quot; }; const output: BindOutput = bindSchema(input);  "},{"title":"Details​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#details","content":"Polywrap uses MessagePack as a common data interchange format between languages. This allows Polywrap WASM modules, authored in different languages, to be run within a single host language (JS, Rust, Python, Go, C#, C++). MessagePack encoded data is sent between module boundaries. Decoding of the message will happen in the destination environment, using generated binding code, created by this package. "},{"title":"Supported Schema Types​","type":1,"pageTitle":"@polywrap/schema-bind","url":"/reference/schema/schema-bind#supported-schema-types","content":"GraphQL Schema Type\tMessagePack Type\tDescriptionUInt\tuint 32\t32-bit unsigned integer. UInt8\tuint 8\t8-bit unsigned integer. UInt16\tuint 16\t16-bit unsigned integer. UInt32\tuint 32\t32-bit unsigned integer. Int\tint 32\t32-bit signed integer. Int8\tint 8\t8-bit signed integer. Int16\tint 16\t16-bit signed integer. Int32\tint 32\t32-bit signed integer. String\tfixstr or str 8/16/32\tUTF-8 string. Boolean\tbool\ttrue or false stored as 1 byte. Bytes\tbin 8/16/32\tarray of 8-bit unsigned integer. BigInt\tfixstr or str 8/16/32\tUTF-8 string. BigNumber\tfixstr or str 8/16/32\tUTF-8 string. JSON\tfixstr or str 8/16/32\tUTF-8 string. [Type]\tfixarray or array 16/32\tArray of elements. Map\tMsgpack extention type\tMap of key-value pairs. type CustomObject { prop: Type }\tfixmap or map 16/32\tStructured object. "},{"title":"@polywrap/schema-parse","type":0,"sectionRef":"#","url":"/reference/schema/schema-parse","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#usage","content":"import { Abi, parseSchema, ParserOptions } from &quot;@polywrap/schema-parse&quot;; const schema = readFileSync(&quot;module.graphql&quot;, &quot;utf-8&quot;); const options: ParserOptions = { }; const abi: Abi = parseSchema(schema, options);  "},{"title":"Options​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#options","content":"interface ParserOptions { // Disable schema validation noValidate?: boolean; // Use custom validators validators?: SchemaValidatorBuilder[]; // Use custom extractors extractors?: SchemaExtractorBuilder[]; // Use custom transformations transforms?: AbiTransforms[]; }  "},{"title":"ABI Transforms​","type":1,"pageTitle":"@polywrap/schema-parse","url":"/reference/schema/schema-parse#abi-transforms","content":"ABI transformations can be used to modify the ABI structure. A variety of pre-defined transformations can be found in the https://github.com/polywrap/toolchain/tree/origin/packages/schema/parse/src/transform/ directory. Example: import { Abi, AbiTransforms, GenericDefinition, parseSchema } from &quot;@polywrap/schema-parse&quot;; function extendType(extension: any): AbiTransforms { return { enter: { Abi: (abi: Abi) =&gt; ({ ...abi, extension, }), GenericDefinition: (def: GenericDefinition) =&gt; ({ ...def, ...extension, }), }, }; }  Usage: parseSchema(schema, { transforms: [ extendType({ newProp: &quot;foo&quot; }) ] });  "},{"title":"Developer Tools","type":0,"sectionRef":"#","url":"/resources/developer-tooling","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Developer Tools","url":"/resources/developer-tooling#introduction","content":"We offer an extensive set of developer tools to build wrappers. If the platform or language you need to use isn't listed here, send us a note on Discord! "},{"title":"Developer Tools​","type":1,"pageTitle":"Developer Tools","url":"/resources/developer-tooling#developer-tools","content":"Developer Tool\tDescriptionpolywrap\tCommand line interface @polywrap/client-js\tJavaScript client @polywrap/core-js\tStandard JavaScript implementation @polywrap/react\tReact wrapper @polywrap/schema-parse\tSchema parser @polywrap/schema-compose\tSchema Composer @polywrap/schema-bind\tSchema binding @polywrap/wasm-as\tAssemblyScript runtime "},{"title":"Ecosystem Tooling","type":0,"sectionRef":"#","url":"/resources/ecosystem-tooling","content":"Ecosystem Tooling Check out the amazing projects Polywrap DAO contributors have made: Ethereum ABI -&gt; Wrapper Generator: is a node.js console app that can read an Ethereum smart contract abi file and generate Polywrap wrapper code for schema and AssemblyScript modules..Defiwrapper is a collection of different DeFi related wrappers like defi-sdk, coingecko, etc. With Defiwrapper, the ambition is to create a cross-chain multi-platform suite of DeFi related wrappers.","keywords":""},{"title":"The Polywrap Technical Standard","type":0,"sectionRef":"#","url":"/resources/the-polywrap-technical-standard","content":"","keywords":""},{"title":"Polywrap Architecture​","type":1,"pageTitle":"The Polywrap Technical Standard","url":"/resources/the-polywrap-technical-standard#polywrap-architecture","content":" "},{"title":"Talks, Podcasts, and Videos","type":0,"sectionRef":"#","url":"/resources/talks-podcasts-and-videos","content":"","keywords":""},{"title":"Introduction to Polywrap​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#introduction-to-polywrap","content":" "},{"title":"EthCC Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethcc-presentation","content":" "},{"title":"ETHDenver Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethdenver-presentation","content":" "},{"title":"ETHGlobal Presentation​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#ethglobal-presentation","content":" "},{"title":"Dev Podcasts​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#dev-podcasts","content":""},{"title":"Episode 1 The Polywrap WASM Runtime​","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"/resources/talks-podcasts-and-videos#episode-1-the-polywrap-wasm-runtime","content":" "},{"title":"Configure Polywrap build pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline","content":"","keywords":""},{"title":"Build pipeline​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#build-pipeline","content":"The build process begins by running the build command from the polywrap CLI. The command will first search for the Polywrap Manifest, find the wrapper schema and implementation, and move these files into a Docker image. Within the docker image, the wrapper schema is parsed and its contents are extracted into an ABI. The ABI is used to generate binding code for the wrapper. The wrapper is then compiled into a Wasm module. The ABI and the Polywrap Manifest are merged into a Wrap Manifest file called wrap.info. While the default build settings work well for many projects, the toolchain offers a highly configurable build pipeline for those who need more customization. "},{"title":"Build Manifest​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#build-manifest","content":"The Build Manifest polywrap.build.yaml file is the entry point to build pipeline configuration. "},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#declaration","content":"The location of the Build Manifest must be declared in your Polywrap Manifest with a field labeled build. If a custom build manifest is not declared, the default build configuration will be used. build: ./polywrap.build.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#content","content":"SchemaExampleDefault Configuration format: # Polywrap YAML Format version docker: # (Optional) Custom Docker configuration name: # (Optional) Docker image name dockerfile: # (Optional) Docker image file name buildx: # (Optional) Configuration options for Docker Buildx, set to true for default value. cache: # (Optional) Path to cache directory, set to true for default value, set to false to disable caching remove builder: # (Optional) Remove the builder instance removeImage: # (Optional) Remove the image config: # (Optional) Custom build image configurations node_version: # (Optional) Node version include: # (Optional) Files to include in build linked_packages: # (Optional) Array of locally linked packages into docker build image - name: # Package name path: # Path to linked package directory filter: # (Optional) Ignore files matching this regex in linked package directory  "},{"title":"Customizing the Dockerfile​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#customizing-the-dockerfile","content":"Those who need to fully customize the Docker image build steps can customize the Dockerfile. The Dockerfile is a text file containing instructions for Docker to build images. You can learn more about it at Docker's Dockerfile documentation. To begin, either copy the default Dockerfile from the .polywrap/wasm/build/image folder or create your own. Then, in the polywrap.build.yaml file, add a key called dockerfile with the path of the newly created Dockerfile as the value. That's it! Now, you can customize the Dockerfile to your heart's content. format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile  "},{"title":"Mustache support​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/build-pipeline#mustache-support","content":"Mustache is a logic-less template system that can be used for HTML, config files, and more. You can learn more about writing Mustache templates here. To enable Mustache capabilities for your Dockerfile, name your custom Dockerfile with a .mustache file extension: dockerfile: ./Dockerfile.mustache  With Mustache, your Dockerfile will be able to recognize variable tags set within the config field of the Build Manifest. For example, in your Build Manifest file, you could have a key such as foo with the value hey like so: format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile.mustache config: foo: hey  To use this variable in your Mustache-enabled Dockerfile, simply reference the variable with curly braces like so: {{ foo }}  "},{"title":"Configure Polywrap deployment pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#declaration","content":"The location of the deployment manifest should be declared in your Polywrap Manifest polywrap.yaml with a field labeled deploy. deploy: ./polywrap.deploy.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#content","content":"The concents of a Deploy Manifest consists of one or more jobs with their steps, each of which has some common fields and a set of configuration options particular to the step's module. All jobs run in parallel, while steps of each job run in series. The result of a step can be passed as input to a later step using $$step_name. SchemaExample format: # The manifest format version jobs: # Each job describes series of events in the pipeline [name]: # Name of the job config: # configuration for all deployment modules, can be overridden within each step steps: # Each step describes an event in the pipeline - name: # The name of the step package: # Deployment module uri: # The wrap URI of source content depends_on: # (Optional) Use prior step's output config: # Configuration for the deployment module  "},{"title":"Deployment Modules​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#deployment-modules","content":"Polywrap currently supports three types of deployment modules: ipfs: pins a folder's contents to IPFS and returns the content hash (CID)ens: points an ENS domain to an IPFS content hashlocal-dev-ens: registers a domain on a local test environment and points the domain to an IPFS content hash "},{"title":"IPFS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#ipfs","content":"The IPFS module pins a folder's contents to IPFS and returns the content hash (CID). It can be used to deploy a wrapper by pinning the contents of your project's build folder to the IPFS network. The IPFS module's custom configuration requires an IPFS gateway URI so the CLI knows where to send the files. Example: ipfs configuration config: gatewayUri: 'ipfs.wrappers.io' # IPFS gateway URI  "},{"title":"ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#ens","content":"The ENS module accepts an IPFS content hash (CID) as input and points an ENS domain name to it. The ENS module's custom configuration requires three arguments and accepts an optional fourth: domainName: the ENS domain name owned by your Ethereum accountprovider: an Ethereum JSON RPC providerensRegistryAddress: the Ethereum address of the ENS Registry smart contractprivateKey: (optional) your Ethereum account's private key, used when the Ethereum provider cannot produce an account signer Example: ens configuration config: domainName: 'wrapper.eth' # ENS domain name provider: 'http://localhost:4545' # an Ethereum JSON RPC provider URI ensRegistryAddress: '0x...' # The ENS Registry contract address privateKey: '' # a private key may be required to sign ethereum transactions  "},{"title":"Local Dev ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-pipeline#local-dev-ens","content":"The Local Dev ENS module accepts an IPFS content hash (CID) as input, registers an ENS domain name, and points the domain name to the IPFS CID. The Local Dev ENS module was created with Polywrap's default test environment infrastructure in mind. tip Polywrap's default test environment can be started with the polywrap infra up CLI command and stopped with the polywrap infra down CLI command. The module assumes ENS infrastructure is set up on a local Ethereum network with the ENS smart contracts deployed at the following addresses: ENS Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbENS Resolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24ENS Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbENS Reverse Lookup: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C The Local Dev ENS module's custom configuration requires two arguments: domainName: the desired ENS domain name to be registeredports: contains the port of the local Ethereum test network Example: local-dev-ens configuration config: domainName: 'wrapper.eth' # ENS domain name ports: ethereum: 4545  "},{"title":"Deploy to IPFS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"Fleek​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#fleek","content":"Fleek makes it easy to build websites and apps on the new open web. &gt; Step-By-Step Guide "},{"title":"Pinata​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#pinata","content":"Pinata provides tools and infrastructure for all creators to easily create and manage content on IPFS. &gt; Step-By-Step Guide "},{"title":"Crust Network​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#crust-network","content":"Crust Network provides a Web3.0 decentralized storage network for the Metaverse. &gt; Step-By-Step Guide "},{"title":"Aleph​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#aleph","content":"Aleph allows your blockchain enabled app to securely access trusted off-chain data or computation within a couple lines of code. "},{"title":"Arweave​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wasm-wrappers/deploy-to-ipfs#arweave","content":"Arweave enables you to store documents and applications forever. "},{"title":"Deploying to Fleek","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Fleek so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to FleekStep 5. Verifying the package on IPFS  "},{"title":"What is Fleek?​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#what-is-fleek","content":"Fleek is the easiest way to build, deploy, and host websites &amp; apps on IPFSFleek provides one seamless workflow with everything you need to build fast, modern sites &amp; web apps hosted on IPFS. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js ⚡ Fleek🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Fleek​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-4--upload-the-build-folder-to-fleek","content":"Make sure you signup for a Fleek account. On the left-hand side menu of your Fleek. Account page, click on the &quot;Storage&quot; link.  Then, click &quot;Create Folder&quot; Example: Gm-Polywrap  Click Confirm to create the folder   Click the Folder After that, click &quot;Upload&quot;   Select the contents of your build folder onto Fleek.  Click Confirm.  tip Due to the current Filecoin deal size limitation, files are batched together across Fleek products and uploaded as one Filecoin So it might take 24-48 hours, depending on Fleek usage, for content to appear in ipfs "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/fleek#step-5--verifying-the-package-on-ipfs","content":"Click the &quot;Verify on IPFS&quot; button. You will get an IPFS hash! For an example of what you should see, visit this IPFS link. Now that you have the IPFS hash, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. You can also register an ENS domain and have it resolved to this IPFS content. 🎉 Congratulations 🎉 on deploying to Fleek! "},{"title":"Deploying to Pinata","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Pinata so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to PinataStep 5. Verifying the package on IPFS  "},{"title":"What is Pinata?​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#what-is-pinata","content":"Pinata is building the largest pinning service on IPFS! Pinata gives users the ability to upload, manage, and share their content whenever, wherever and, with whomever they want. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🪅 Pinata🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Pinata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-4--upload-the-build-folder-to-pinata","content":"Make sure you signup for a Pinata account. Click &quot;Upload&quot;  Click &quot;Folder&quot;  Click Select for a folder to upload should be the build folder   Give your file or folder a name. Example: Gm-Polywrap  Click &quot;Upload&quot; from the alert message  "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/pinata#step-5--verifying-the-package-on-ipfs","content":"You will get an IPFS hash! Click the name of the folder   This will lead you to IPFS link:https://gateway.pinata.cloud/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq Now that you have the IPFS hash located in the CID column in the pinata manager, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. 🎉 Congratulations 🎉 on deploying to Pinata! "},{"title":"Deploying to CRUST Files","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrapper using the Crust Files. so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to Crust NetworkStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 👛 Metamask🥐 Crust Network🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrapper​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build  "},{"title":"Step 4. Upload the build folder to Crust Network​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-4-upload-the-build-folder-to-crust-network","content":"Make sure you signin using a wallet Metamask.  Click Public  Click Upload   Upload the build folder then Click Upload   Click Sign and Upload   Your wallet will ask for a signature request Click Sign  The page should look like this:   "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wasm-wrappers/deployment/crust#step-5-verifying-the-package-on-ipfs","content":"You will get an IPFS hash! This will lead you to IPFS link: https://gw.crustapps.net/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq?filename=build  🎉 Congratulations 🎉 on deploying using the Crust Files! "},{"title":"Publish to ENS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"The ENS App​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wasm-wrappers/publish-to-ens#the-ens-app","content":"ENS App is a distributed, open, and extensible naming system based on the Ethereum blockchain. "},{"title":"Plugin an existing JS SDK","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/create-js-plugin","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#introduction","content":"In this guide, we'll walk you through creating your own JavaScript-based plugin wrapper that can be added to the JavaScript Polywrap Client. caution Plugins do not retain all of Polywrap's benefits. We recommend re-writing your existing JavaScript SDKs as Wasm wrappers if possible. As always, if you need any help, message us on Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#prerequisites","content":"You'll need the following installed before building your plugin: nvmyarn You'll be using TypeScript to implement your Polywrap plugin. tip In the future, TypeScript will be one of many supported languages for implementing plugins. As more Polywrap Clients are released in various languages, implementing plugins in those languages will be supported as well. "},{"title":"Getting started​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#getting-started","content":"To get started, use the following command to spin up a project folder for your plugin. npx polywrap create plugin typescript &lt;project-name&gt;  Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-plugin. Once complete, you'll see a new folder appear, named after the custom name you've chosen. Please navigate into this new directory (using cd for example). "},{"title":"Installation​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#installation","content":"Let's ensure all of your project's dependencies are installed. From inside your project's directory, simply run: nvm install &amp;&amp; nvm useyarn "},{"title":"Overview of project files​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#overview-of-project-files","content":"Your project should look something like this: polywrap.plugin.yaml # Plugin Manifest src/ | index.ts # Entry File │ schema.graphql # Schema  "},{"title":"polywrap.plugin.yaml​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#polywrappluginyaml","content":"The Plugin Manifest describes the layout of a plugin. "},{"title":"schema.graphql​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the plugin's logic. Learn more about the plugin's code architecture by reading Plugin Architecture "},{"title":"Building the plugin​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#building-the-plugin","content":"To build your plugin, all you need is the following command: yarn build # alias for &quot;npx polywrap build&quot;  "},{"title":"Example Plugins​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/create-plugin-wrappers/create-js-plugin#example-plugins","content":"For inspiration, please refer to these existing JavaScript plugins: Sample PluginToolchain PluginsDemo PluginsIntegration Plugins "},{"title":"Configure a Plugin Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/plugin-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Plugin Manifest","url":"/tutorials/create-plugin-wrappers/plugin-manifest#content","content":"The Plugin Manifest contains the name of the plugin, programming language used to write the plugin, the location of the plugin's entry file (i.e. the file that exports the plugin contents), and the GraphQl schema that declares the plugin's interface. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # (Optional) Name of plugin language: # Plugin programming language module: # Entry file schema: # Wrapper schema import_redirects: # Array of URI redirects - uri: # Source URI to be redirected schema: # Path to schema of the module to which URI will be redirected  "},{"title":"Plugin Architecture","type":0,"sectionRef":"#","url":"/tutorials/create-plugin-wrappers/plugin-architecture","content":"","keywords":""},{"title":"Required Exports​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#required-exports","content":"A plugin must export a PluginFactory to be used by the Polywrap Client. A PluginFactory is a function that returns a PluginPackageManifest and a factory method that generates an instance of the plugin. "},{"title":"TypeScript Support​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#typescript-support","content":"The Polywrap CLI's codegen and build commands will generate a wrap folder containing useful types. The generated types will save you time and energy. You won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs. You can forget about boilerplate code and focus on your plugin's logic. While the types are not strictly required, we recommend them as a best practice. The generated types include: Module - An interface containing the methods declared in the plugin's schemaArgs_* - An interface for each method, containing the method arguments declared in the schemaCustom Types - An interface for each custom type declared in the schemamanifest - A PluginPackageManifest for the plugin (also useful for JavaScript developers!) "},{"title":"Example​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/create-plugin-wrappers/plugin-architecture#example","content":"&quot;Example: import { Module, Args_sampleMethod, manifest } from &quot;./wrap&quot;; // imports from generated &quot;wrap&quot; folder import { PluginFactory } from &quot;@polywrap/core-js&quot;; // plugin must export a PluginFactory export interface SamplePluginConfig { defaultValue: string; } export class SamplePlugin extends Module&lt;SamplePluginConfig&gt; { // Plugin inherits from Module constructor(config: SamplePluginConfig) { super(config); } public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument return args.data + this.config.defaultValue; } } export const samplePlugin: PluginFactory&lt;SamplePluginConfig&gt; = ( // exported PluginFactory is used by Polywrap client config: SamplePluginConfig ) =&gt; { return { factory: () =&gt; new SamplePlugin(config), // factory method produces a Module manifest, // imported from ./wrap }; }; export const plugin = samplePlugin; // PluginFactory is exported with name &quot;plugin&quot;  "},{"title":"Add Metadata","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/add-metadata","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Add Metadata","url":"/tutorials/create-wasm-wrappers/add-metadata#declaration","content":"Its location must be referenced in the Polywrap Manifest with a field labeled meta. meta: ./polywrap.meta.yaml  "},{"title":"Content​","type":1,"pageTitle":"Add Metadata","url":"/tutorials/create-wasm-wrappers/add-metadata#content","content":"The Meta Manifest contains titles, descriptions, images, tags, and links that application developers can display when presenting or discussing your wrapper. SchemaExample format: # The manifest format version displayName: # (Optional) Name of the wrapper that users should use for presentation subtext: # (Optional) Subtext of display name; brief description of the wrapper description: # (Optional) Detailed description repository: # (Optional) Repository URL icon: # (Optional) Path to wrapper icon or log tags: # (Optional) Array of terms that can help find your wrapper in search links: # (Optional) Array of links relevant to your wrapper - name: # Name of link icon: # (Optional) Icon associated with link url: # (Optional) Link URL  "},{"title":"Configure a Polywrap Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/polywrap-manifest","content":"","keywords":""},{"title":"Default plugins","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/default-plugins","content":"","keywords":""},{"title":"Import to schema​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#import-to-schema","content":"We'll use one of the default plugins, Ethereum, to show how you can import its modules into your wrapper's schema (schema.graphql file). #import { Module, Connection } into Ethereum from &quot;wrap://ens/ethereum.polywrap.eth&quot; Below, we explain what each part of this code means. #import Imports specific modules from a deployed or local plugin { Module, Connection } These are specific modules that we're unpacking from the one of Polywrap's default plugins, Ethereum. into Ethereum This is a namespace, enabling you to use the modules in your schema e.g. Ethereum_Module or Ethereum_Connection from &quot;wrap://ens/ethereum.polywrap.eth&quot; wrap:// is the Polywrap URI schema.ens is the URI authority. It tells the Polywrap client what kind of URI it needs to resolve. The ens authority tells the Polywrap client that what follows is an ENS address that resolves to a decentralized storage hosting a wrapper. Other valid authorities include ipfs for IPFS content hashes, fs for wrappers located on your local filesystem (often used while testing wrappers), or a custom authority that may be handled by a custom URI resolver.ethereum.polywrap.eth is the URI path, which in this case is an ENS address.Note: The client redirects queries from the URI of a plugin wrapper to the plugin object that exists in memory. While plugins typically use an ENS URI for readability, the client does not need to query the ENS registry or an external storage location. See our section on URI redirects for more information. "},{"title":"Use in Wasm Wrapper​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#use-in-wasm-wrapper","content":"Once types have been imported, the functionality of these imported modules can be used in wrapper development. Upon yarn build, the imported types and modules will be made available to you in the src/wrap folder. To use them, you simply need to import the specific modules that you'd like to use. If you're building an AssemblyScript-based wrapper, the import might look like this: import { Ethereum_Module, Ethereum_Connection } from './wrap';  The Ethereum_Module will contain the methods shown here, under the Module type. Once imported, you can access methods like so: Ethereum_Module.callContractMethod({ ... }) "},{"title":"Commonly used default plugins​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#commonly-used-default-plugins","content":"This section contains guides on commonly used default plugins: Ethereum, Subgraph, HTTP, and Logger. "},{"title":"Ethereum​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#ethereum","content":"The Ethereum plugin enables wrappers to query the ethereum blockchain. Schema: Link Example: export function getData(input: Input_getData): u32 { const res = Ethereum_Module.callContractView({ address: input.address, method: 'function get() view returns (uint256)', args: null, connection: input.connection, }).unwrap(); return U32.parseInt(res); }  "},{"title":"Subgraph​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#subgraph","content":"The subgraph plugin enables wrappers to query The Graph's subgraphs. Schema: Link Example Implementation:​ In our ./src/schema.graphql file, we'll write the schema for our wrapper. At the top of this file, import the GraphNode module into your wrapper: #import { Module } into GraphNode from &quot;wrap://ens/graph-node.polywrap.eth&quot;  Then, define the types and fields on the querySubgraph method.  querySubgraph( subgraphAuthor: String! subgraphName: String! query: String! ): JSON!  We'll now implement the querySubgraph method in AssemblyScript. At the top of index.ts, include these import statements: import { GraphNode_Module, Args_querySubgraph } from './wrap'; import { JSON } from '@polywrap/wasm-as';  Then, implement the querySubgraph method: export function querySubgraph(args: Args_querySubgraph): JSON.Value { const response = GraphNode_Module.querySubgraph({ subgraphAuthor: args.subgraphAuthor, subgraphName: args.subgraphName, query: args.query, }).unwrap(); const json = JSON.parse(response); const obj = json as JSON.Obj; return obj.valueOf().get('data') as JSON.Value; }  Example query to test your method: subgraphAuthor: 'ensdomains', subgraphName: 'ens', query: '{\\ndomains(first: 5){\\nid\\nname\\nlabelName\\nlabelhash\\n}\\n}',  "},{"title":"HTTP​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#http","content":"The HTTP plugin enables wrappers to perform HTTP queries in JavaScript applications. Schema: Link Example Implementation​ In this example, we will implement a simple Ping method which pings CoinGecko to see their server status using an HTTP Get request from your wrapper. In our ./src/schema.graphql file, we’ll write the schema for our wrapper. At the top of this file, import the HTTP module into your wrapper: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/http.polywrap.eth&quot;  Then, define the types and fields on the Ping method. First, add a new Ping type at the bottom of the schema. type Ping { gecko_says: String! }  Then, add an argument-less method called ping that returns a non-nullable Ping to the Module type. Our completed schema looks like this: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/http.polywrap.eth&quot; type Module { ping: Ping! } type Ping { gecko_says: String! }  Now, we'll implement the ping method in ./src/index.ts At the top of the file, we'll import the HTTP/Ping methods and types. import { HTTP_Module, HTTP_ResponseType, Ping, } from './wrap';  Then, implement Ping function: export function ping(): Ping { // Writing the HTTP request / response const response = HTTP_Module.get({ url: 'https://api.coingecko.com/api/v3/ping', request: { headers: [], urlParams: [], body: '', responseType: HTTP_ResponseType.TEXT, }, }).unwrap(); // Error handling for the response if (!response || response.status !== 200 || !response.body) { const errorMsg = response &amp;&amp; response.statusText ? (response.statusText as string) : 'An error occurred while fetching data from Coingecko API'; throw new Error(errorMsg); } const json = &lt;JSON.Obj&gt;JSON.parse(response.body); // Response from Coingecko with field `geckoSays` const geckoSays = json.getString('gecko_says'); if (geckoSays) { return { gecko_says: geckoSays.valueOf(), }; } throw new Error('Invalid response body!'); }  "},{"title":"Logger​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wasm-wrappers/default-plugins#logger","content":"The Logger plugin enables logging in a Wasm wrapper, which can be useful for debugging. In our ./src/schema.graphql file, import the Logger module into your wrapper: #import { Module } into Logger from &quot;wrap://ens/js-logger.polywrap.eth&quot;  Then in your implementation file ./src/index.ts, import the Logger function: import { Logger_Module, Logger_Logger_LogLevel, } from './wrap';  And use it like so:  Logger_Module.log({ level: Logger_Logger_LogLevel.INFO, message: `Insert useful log message here`, });  When you run your test e.g. yarn test:e2e, you will see the logged message in the console. "},{"title":"Content​","type":1,"pageTitle":"Configure a Polywrap Manifest","url":"/tutorials/create-wasm-wrappers/polywrap-manifest#content","content":"The Polywrap Manifest contains the name of the wrapper, programming language used to write it, and the location of the wrapper schema that declares the wrapper's interface. It optionally includes a path to the wrapper's entry file (e.g. src/index.ts, src/lib.rs) and paths to other manifests that can be used to configure the build and deploy process. It can also contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of wrapper language: # Wrapper programming language schema: # Path to wrapper schema module: # (Optional) Path to entry file build: # (Optional) Path to Build Manifest file meta: # (Optional) Path to Meta Manifest file deploy: # (Optional) Path to wrapper Deploy Manifest file import_redirects: # (Optional) Array of URI redirects - uri: # Source URI to be redirected schema: # Path to schema of the module to which URI will be redirected  "},{"title":"Build, deploy and test","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test","content":"","keywords":""},{"title":"Build​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#build","content":"Let's start building our project! Simply run: yarn build  In the output window, you'll see that our smart contract was compiled, and our Polywrap wrapper was built and output to the ./build/* folder. It contains the following files: build/ |── wrap.wasm # Wrapper Logic └── wrap.info # Wrapper Manifest  This directory's contents will be uploaded to decentralized storage, and enable any Polywrap Client to download, and execute your wrapper's functionality within the application. The wrap.wasm file is the WebAssembly file that was compiled from AssemblyScript. Lastly, the wrap.info file describes the layout of the package, as well as its methods and custom types. "},{"title":"Deploy​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#deploy","content":"To deploy our Polywrap wrapper and associated smart contracts for testing, let's first setup a test environment. Simply run: yarn test:env:up  This will stand-up an Ethereum node, as well as an IPFS node. tip In the future, test environments will be easily configurable to include any nodes your Polywrap wrapper requires. Next, let's deploy the SimpleStorage.sol smart contract, and the simplestorage.eth wrapper URI by running: yarn deploy  "},{"title":"Test​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wasm-wrappers/tutorial/build-deploy-test#test","content":"With our Polywrap wrapper live at simplestorage.eth on our test network, it's now time to test it out! This is where our workflows come in handy. Run yarn test to see this in action. In the output window, you'll see a combination of jobs and returned results from the Polywrap wrapper. In this workflow, we send a combination of setData and getData queries which modify the SimpleStorage.sol contract's stored value. Now that we've built the SimpleStorage Wasm wrapper, let's add custom functionality to it in the next section! "},{"title":"Deploy locally & run tests","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test","content":"","keywords":""},{"title":"Deploy​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#deploy","content":"With our workflow complete, let's test the Wasm wrapper on our local environment! First, let's set up our test environment with the following command in your terminal: yarn test:env:up  tip This command starts up a test environment with a local Ethereum network using Ganache, an ENS smart contract, and a local IPFS node. To close the test environment, simply run: yarn test:env:down  Next, we will deploy our both our SimpleStorage.sol smart contract as well as our wrapper with the following command: yarn deploy  tip Behind the scenes, yarn deploy will run the following commands: yarn deploy:api &amp;&amp; yarn deploy:contract Let's break down each of these commands, starting with yarn deploy:api, which itself runs this command: npx polywrap deploy The polywrap CLI's deploy command executes a deployment pipeline defined in a polywrap.deploy.yaml manifest. Our deployment pipeline builds and deploys our wrapper to our local test environment. The wrapper is assigned to an Ethereum Name Service (ENS) domain registered in the test environment that is set to resolve to our local IPFS node. We next deploy the SimpleStorage smart contract to the Ethereum test network using a script we've written for you: node ./scripts/deploy-contract.js We'll be interacting with this deployed smart contract using our Wasm wrapper. "},{"title":"Test​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#test","content":"Now, we'll use the following command to check whether our wrapper and smart contract are working properly: yarn test:workflow  This command uses the Polywrap CLI's run command, which will execute a series of Polywrap invocations and return the result to you. "},{"title":"Conclusion​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wasm-wrappers/tutorial/deploy-locally-and-test#conclusion","content":"🎉 Congratulations! You've create a custom Wasm wrapper! Hopefully this article has given you a clear understanding of the Polywrap toolchain's primary features. If at any time in this process you get stuck or have questions, please don't hesitate to reach out on Discord. "},{"title":"Adding new Methods","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods","content":"","keywords":""},{"title":"Custom functionality: IPFS SimpleStorage​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#custom-functionality-ipfs-simplestorage","content":"It's time to build and customize your own Polywrap Wasm wrapper! We'll be adding IPFS support to the SimpleStorage API. "},{"title":"Update the schema​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#update-the-schema","content":"The first step to adding new wrapper functionality is defining the method we want our users to invoke. Add the following method &amp; custom data types to your ./src/schema.graphql schema file: ./src/schema.graphql type Module { ... setIpfsData( options: SetIpfsDataOptions! connection: Ethereum_Connection ): SetIpfsDataResult! } type SetIpfsDataOptions { address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Import IPFS' Polywrap wrapper​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#import-ipfs-polywrap-wrapper","content":"Since we'll be making use of IPFS in our Wasm wrapper, let's import the IPFS plugin wrapper. Then we will be able to call its methods from our code, allowing us to upload content: ./src/schema.graphql #import { Module } into Ipfs from &quot;wrap://ens/ipfs.polywrap.eth&quot; type Module { ...  "},{"title":"Implement the setIpfsData method​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#implement-the-setipfsdata-method","content":"In the ./src/index.ts file, import the new types we've defined: ./src/index.ts import { Ethereum_Module, Args_deployContract, Args_setData, Args_getData, Ipfs_Module, Args_getIpfsData, Args_setIpfsData, SetIpfsDataResult, } from &quot;./wrap&quot;;  These new types will not exist yet, but don't worry, they'll be generated in the ./src/wrap/* folder once the yarn build command is run. Next, we'll implement the setIpfsData method. Add this function to the bottom of your ./src/index.ts file: ./src/index.ts export function setIpfsData(args: Args_setIpfsData): SetIpfsDataResult { // 1. Upload the data to IPFS const ipfsHash = Ipfs_Module.addFile({ data: String.UTF8.encode(args.options.data), }).unwrap(); // 2. Add the data's IPFS hash to SimpleStorage using `setHash(...)` const txReceipt = Ethereum_Module.callContractMethodAndWait({ address: args.options.address, method: 'function setHash(string value)', args: [ipfsHash], connection: args.connection, txOverrides: null, }).unwrap(); // 3. Return the result return { ipfsHash, txReceipt: txReceipt.transactionHash, }; }  As you can see, the SimpleStorage.sol smart contract already exposes a setHash() method. In steps 1 and 2, our SimpleStorage Wasm wrapper is sending a &quot;sub-invocation&quot; to the IPFS and Ethereum plugin wrappers we imported in our schema. Wrappers can be implemented as a WebAssembly-based wrapper, or a plugin wrapper in the client's language (ex: JavaScript). For more information on plugins, see the &quot;Plugin an Existing JS SDK&quot; documentation. The Ethereum_Module.callContractMethodAndWait function also accepts an optional argument, connection. This option allows you to select the network which you're transacting with, by specifying a node's endpoint, or a network (name or chain ID) (e.g. &quot;rinkeby&quot;). To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Adding more methods​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods#adding-more-methods","content":"With our first method implementation complete, it's now time to add more. The steps are the same as above. Update the ./src/schema.graphql file like so: ./src/schema.graphql type Module { ... getIpfsData( address: String! connection: Ethereum_Connection ): String! ... }  Implement the getIpfsData(...) method like so in ./src/index.ts: ./src/index.ts export function getIpfsData(args: Args_getIpfsData): string { const hash = Ethereum_Module.callContractView({ address: args.address, method: 'function getHash() view returns (string)', args: null, connection: args.connection }).unwrap(); return String.UTF8.decode( Ipfs_Module.cat({ cid: hash, options: null }).unwrap() ); }  To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"The Polywrap project folder","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder","content":"","keywords":""},{"title":"polywrap.yaml​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#polywrapyaml","content":"The polywrap.yaml is a manifest file describing the layout of a Polywrap Wasm wrapper. "},{"title":"schema.graphql​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the wrapper's logic. "},{"title":"src/contracts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#srccontracts","content":"The src/contracts directory contains our protocol's Ethereum-based smart contracts. "},{"title":"workflows/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#workflows","content":"Workflows provide a simple way to test your Polywrap without having to write custom testing logic (with JavaScript and Jest, for example). We'll be using this functionality further down in this guide with the polywrap run command, allowing us to easily send test queries against our API. "},{"title":"scripts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wasm-wrappers/tutorial/project-folder#scripts","content":"We've defined some simple build &amp; deployment scripts for our Solidity smart contracts. These are basic utilities, and can be replaced entirely by a Truffle or Hardhat project. In the next section, we'll build this example Wasm wrapper and see what gets outputted in the build folder! "},{"title":"Project setup","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#prerequisites","content":"You'll need the following installed before building your wrapper: nvmyarndockerdocker-compose You'll be using AssemblyScript to implement your wrapper's logic. AssemblyScript compiles to WebAssembly. tip For now, AssemblyScript and Rust are the only languages with which you can implement your wrapper. In the future, we will support additional languages that compile to WebAssembly, such as Go. If you have experience programming in TypeScript, you'll feel at home with AssemblyScript since the language's syntax is very similar. 👋 This guide is meant for those who want to build and deploy their own wrappers. If you're interested in integrating deployed wrappers into your own app, see our Integrate into a JS App guide. "},{"title":"Create your project​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#create-your-project","content":"Let's begin by downloading the Polywrap demos repository, which contains the SimpleStorage Wasm wrapper we will be using in this guide: git clone https://github.com/polywrap/demos.git  From the root of this new directory, navigate to simple-storage/wrapper/assemblyscript. tip The best way to start a new wrapper project is with a project template generated using our CLI. npx polywrap create wasm assemblyscript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choice. For example my-wrapper. After running this command, you'll see a new folder appear with the custom name you've chosen. The folder will contain everything you need to get started! "},{"title":"Installation​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wasm-wrappers/tutorial/project-setup#installation","content":"Let's ensure all of your project's dependencies are installed. From inside the project's directory, simply run: nvm install &amp;&amp; nvm useyarn The Polywrap CLI is now installed locally to your project's directory. Going forward we'll use this local installation by running npx polywrap. We recommend not installing the polywrap package globally to avoid future version conflicts, and maximize reproducibility for the other developers you're working with. Let's head over to the next section to see what's in this new directory! "},{"title":"Writing tests with workflows","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/tutorial/writing-tests-with-workflows","content":"","keywords":""},{"title":"Testing​","type":1,"pageTitle":"Writing tests with workflows","url":"/tutorials/create-wasm-wrappers/tutorial/writing-tests-with-workflows#testing","content":"In order to test this new functionality, we'll update the existing ./workflows/e2e.yaml workflow file to include the new methods we've added (setIpfsData, and getIpfsData). Add the following case to the e2e.yaml workflow in the ./workflows folder. ./workflows/e2e.yaml case2: steps: - uri: fs/build method: setIpfsData args: options: address: &quot;$cases.0.data&quot; data: &quot;Hello from IPFS!&quot; - uri: fs/build method: getIpfsData args: address: &quot;$cases.0.data&quot;  Once our workflow has been defined, we may want to be able to validate our actual results against our expectations. Workflow validation uses CUE, a flexible and expressive data validation language. CUE must be installed to complete this step. If you don't want to install anything right now, don't worry! Our results will be easy to verify with manually. To continue with automated testing, let's add our expected output to a new file in the workflows folder. We will call the file validator.cue. ./workflows/validator.cue package e2e cases: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{40}$&quot;, error?: _|_, // Never fails } case1: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{64}$&quot;, error?: _|_, } $1: { data: uint, error?: _|_ } } case2: { $0: { data: { txReceipt: string, ipfsHash: &quot;QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis&quot; }, error?: _|_, } $1: { data: &quot;Hello from IPFS!&quot;, error?: _|_, } } }  With our workflow complete, we'll deploy and test our Wasm wrapper locally in the next section! "},{"title":"Environmental variables","type":0,"sectionRef":"#","url":"/tutorials/env-variables","content":"","keywords":""},{"title":"Schema declaration​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#schema-declaration","content":"To use environmental variables, wrapper developers must first declare an Env type and add the @env directive to methods in the Wrapper Schema. You can learn more about the schema declarations in the Environmental Variables section of the Wrapper Schema documentation. type Env { str: String! } type Module { foo( arg: String! ): String! @env(required: true) }  "},{"title":"Access Env in the module​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#access-env-in-the-module","content":"Environmental variables can be used in both plugin wrappers and Wasm wrappers. "},{"title":"Env in plugin wrappers​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#env-in-plugin-wrappers","content":"Plugin wrapper developers can access the Env instance as a class property. const env: Env = this.env;  "},{"title":"Env in wasm wrappers​","type":1,"pageTitle":"Environmental variables","url":"/tutorials/env-variables#env-in-wasm-wrappers","content":"Wasm wrapper developers can access the Env instance by accepting the Env as a second argument in their module's methods. When an application developer invokes the method, the environmental variables they set in their ClientConfig will be provided. AssemblyScriptRust // App developers are required to provide Env to invoke this method export function methodRequireEnv(_: Args_methodRequireEnv, env: Env): Env { return env; } // Env is optional when invoking this method export function methodOptionalEnv(_: Args_methodOptionalEnv, env: Env | null): Env | null { return env ? (env as Env) : null; }  "},{"title":"Case study: Uniswap v3 Wrapper","type":0,"sectionRef":"#","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap","content":"","keywords":""},{"title":"Project scaffolding​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#project-scaffolding","content":"The best way to set up a Polywrap project is to start with one of the project templates available in the Polywrap CLI. The polywrap create command lets you bootstrap your project structure without effort. The initial project setup includes a mutation folder and a query folder within src, which correspond to the two types of modules a wrapper can have. It also includes a polywrap.yaml manifest file, a polywrap.build.yaml Build Manifest file, and a polywrap.meta.yaml Meta Manifest file. The polywrap.yaml manifest tells the Polywrap CLI what language your wrapper is in, where your module schemas are located, and more. Our polywrap.yaml looked like this: format: 0.0.1-prealpha.5 build: ./polywrap.build.yaml meta: ./polywrap.meta.yaml language: wasm/assemblyscript modules: mutation: schema: ./src/mutation/schema.graphql module: ./src/mutation/index.ts query: schema: ./src/query/schema.graphql module: ./src/query/index.ts  The Build Manifest lets you customize the build process. The Meta Manifest lets you add meta-data to your project, like a description and a link to your repo. For the Uniswap v3 wrapper, we left the polywrap.yaml manifest and the Build Manifest unchanged. We added detail to the Meta Manifest much later, when wrapper development was largely complete. "},{"title":"Writing the interface in a GraphQL Schema​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#writing-the-interface-in-a-graphql-schema","content":"We started by reading through the entire Uniswap v3 JavaScript SDK repo on GitHub to record all the types and methods we would reproduce, and to take note of their interactions. The interface of a Polywrap API is declared in a GraphQL schema. We wrote a schema type for each externally-facing class in the SDK, with properties that matched those in the class with public access. We wrote a method declaration in the schema for each externally-facing function and class method in the SDK. We even copied over the SDK's inline documentation to fill the schema with context. #An abridged look at our schema &quot;&quot;&quot;ERC20-compliant token or Ether&quot;&quot;&quot; type Token { &quot;&quot;&quot;Id of chain where token exists&quot;&quot;&quot; chainId: ChainId! &quot;&quot;&quot;Address of token's ERC20 contract&quot;&quot;&quot; address: String! &quot;&quot;&quot;Token description&quot;&quot;&quot; currency: Currency! } type Query { &quot;&quot;&quot;Returns true if the tokens are equivalent, false otherwise&quot;&quot;&quot; tokenEquals( tokenA: Token! tokenB: Token! ): Boolean! &quot;&quot;&quot;Returns true if the address of tokenA would precede the address of token B when sorted alphabetically&quot;&quot;&quot; tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean! }  A wrapper can have two modules: a query module and a mutation module. Each module has its own schema that, along with a an optional common schema for shared types, are combined at build time. The difference between mutations and queries is simple: mutations modify state--this typically means blockchain state in web3 applications--while queries do not. The Uniswap v3 SDK does not modify on-chain state, so all of its functionality was placed in the query module schema. The first draft of the Uniswap v3 wrapper's schema was written in just a few hours, though it was revised during development to fix mistakes and improve the user experience. "},{"title":"Implementing the first functions​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#implementing-the-first-functions","content":"When porting an SDK, it's important to understand its project structure. The organization of the SDK's source code can indicate how wrapper development should proceed. Development should allow for iterative changes and testing. The Unsiwap v3 SDK can be mentally modularized into a roughly linear set of dependent components. We can start with the concept of a Token, which is the component of a CurrencyAmount and a Pool. A Route is a set of pools and currencies. A Trade is constructed from two currency amounts and one or more routes. Based on this pattern, it made sense for us to start with Token. In Uniswap's JavaScript SDK, Token has properties like chainId and address, as well as two class methods: equals and sortsBefore. // Methods found in the Token class in Uniswap's SDK Core package public equals(other: Currency): boolean { return other.isToken &amp;&amp; this.chainId === other.chainId &amp;&amp; this.address === other.address } public sortsBefore(other: Token): boolean { invariant(this.chainId === other.chainId, 'CHAIN_IDS') invariant(this.address !== other.address, 'ADDRESSES') return this.address.toLowerCase() &lt; other.address.toLowerCase() }  Using the Polywrap CLI's codegen command, we generated AssemblyScript classes corresponding to each type we defined in the schema. This was as simple as typing polywrap codegen. The classes work like TypeScript interfaces (statically typed JavaScript objects) that include some boilerplate serialization logic. When you declare a function in your schema that returns a custom type or accepts one as an argument, these generated classes are used as the AssemblyScript analogs. The codegen command simultaneously generates another flavor of AssemblyScript class: function inputs. An Input_* class is generated for each function, where * is the name of the function. The classes have properties corresponding to the arguments defined in the schema. These Input_* classes are used as inputs to the functions declared in the GraphQL schema. The Polywrap CLI places the generated files in directories named w3, which can be found within each module folder (as declared in your polywrap.yaml manifest). From there you can implement and use them. Once we generated the classes, we imported the generated types and implemented the functions just as we found them in the Uniswap SDK. The function signatures match the schema definitions we declared earlier. // An abridged copy of src/query/token.ts in the Uniswap v3 wrapper import { Input_tokenEquals, Input_tokenSortsBefore, Token, } from &quot;./w3&quot;; // Checks if the current instance is equal to another (has an identical chainId and address). export function tokenEquals(input: Input_tokenEquals): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; return tokenA.chainId == tokenB.chainId &amp;&amp; tokenA.address == tokenB.address; } // Checks if the current instance sorts before another, by address. export function tokenSortsBefore(input: Input_tokenSortsBefore): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; const tokenAddress: string = tokenA.address.toLowerCase(); const otherAddress: string = tokenB.address.toLowerCase(); return tokenAddress.localeCompare(otherAddress) &lt; 0; }  After implementing the token functions, it was possible to build the project (after commenting out methods in the schema that had not yet been implemented) and write the first automated tests. "},{"title":"Importing plugins and wrappers​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#importing-plugins-and-wrappers","content":"The Uniswap v3 wrapper imports external dependencies to help it with certain tasks. A wrapper can import other wrappers or plugins. One of the most important dependencies we used is Polywrap's Ethereum plugin. The Ethereum plugin is based on the popular ethers.js package. It can be used to prepare and send Ethereum transactions in much the same way. Although the Uniswap v3 JavaScript SDK does not include methods that mutate state on the Ethereum blockchain, several of its functions do return encoded Ethereum transaction calldata that can be sent to Uniswap's on-chain smart contracts. The SDK uses ethers.js to encode calldata. We can do the same with the Ethereum plugin. Our src/query/schema.graphql schema declares several imports at the top of the file. Among these is the Ethereum plugin, which is included in the Polywrap client by default. #import { Query } into Ethereum from &quot;wrap://ens/ethereum.polywrap.eth&quot; #import { Query } into SHA3 from &quot;wrap://ens/sha3.polywrap.eth&quot; #import { Query } into ERC20 from &quot;wrap://ipfs/QmeiPWHe2ixfitcgjRwP5AaJD5R7DbsGhQNQwT4rFNyxx8&quot; #import { Query } into Subgraph from &quot;wrap://ipfs/QmcnrHegojMFqHkRhixazY67Zb9mSbMLv6sSxyDpUtnrQS&quot; #import { ChainId, TradeType, Currency, Token, Price, TokenAmount, Tick, Pool, FeeAmount, Route, TradeSwap, Trade, BestTradeOptions, Position, PermitOptions, FeeOptions, SwapOptions, MethodParameters, MintAmounts } from &quot;../common/schema.graphql&quot;  Wrappers and plugins are queried at URIs. When a user wants to call an API function with the Polywrap Client, they use a URI to tell the Client which API they are calling. The URI's are also used to import wrapper dependencies. Even though the Ethereum plugin is a JavaScript package that gets loaded into memory, it is still queried at a URI that is redirected and resolved to the in-memory instance. Once imports are declared, we can run the codegen command of the Polywrap CLI to generate imported modules and types. The imported module class includes all of the methods declared in its own GraphQL schema. If we want to know what's in it, we might look there first. We used the Ethereum plugin's encodeFunction method to encode calldata for Uniswap's Multicall smart contract. // An abridged copy of src/query/routerUtils.ts in the Uniswap v3 wrapper import { Ethereum_Query, Input_encodeMulticall, } from &quot;./w3&quot;; export function encodeMulticall(input: Input_encodeMulticall): string { const calldatas: string[] = input.calldatas; return calldatas.length == 1 ? calldatas[0] : Ethereum_Query.encodeFunction({ method: &quot;function multicall(bytes[] calldata data) external payable returns (bytes[] memory results)&quot;, args: ['[&quot;' + calldatas.join('&quot;, &quot;') + '&quot;]'], }).unwrap(); }  "},{"title":"Using base schema types​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#using-base-schema-types","content":"Polywrap schemas support additional default types beyond those found in standard GraphQL. The BigInt type is used in the Uniswap v3 wrapper to represent integers larger than 32 bits. Since Ethereum supports unsigned integers as large as 256 bits, we needed to support them as well. &quot;&quot;&quot;An amount of a token&quot;&quot;&quot; type TokenAmount { &quot;&quot;&quot;Token&quot;&quot;&quot; token: Token! &quot;&quot;&quot;Raw amount of the token, not adjusted for the token's decimals&quot;&quot;&quot; amount: BigInt! }  The BigInt type looks like a standard GraphQL type in the schema. In AssemblyScript, the type is received as an instance of the BigInt class from in the as-bigint AssemblyScript package. // compares two TokenAmount types for equality, returning true if they have the // same token and same amount export function tokenAmountEquals(input: Input_tokenAmountEquals): boolean { const amtA: TokenAmount = input.tokenAmountA; const amtB: TokenAmount = input.tokenAmountB; return ( tokenEquals({ tokenA: amtA.token, tokenB: amtB.token }) &amp;&amp; amtA.amount.eq(amtB.amount) ); }  Other base schema types include BigNumber, JSON, and Map&lt;T,U&gt;. These types, along with BigInt, can be imported directly into AssemblyScript modules from the polywrap/wasm package. "},{"title":"Testing​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#testing","content":"We adapted all of the tests in Uniswap's SDK to work with the wrapper. This ensured that the wrapper met at least the same standards of quality the Uniswap team expected of their SDK. The Uniswap team tested their SDK with artificial data that allowed them to calculate the expected results and compare those results to the outputs of their code. We used the same test cases and expected the same results from our wrapper. We also wrote tests based on real-world data, using a fork of the Ethereum Mainnet network, to compare the results of our wrapper queries with results produced by the SDK. This helped us test the wrapper with input of greater complexity. We wrote automated tests using two different testing frameworks: as-pect and jest. "},{"title":"AssemblyScript tests with as-pect​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#assemblyscript-tests-with-as-pect","content":"as-pect is an AssemblyScript testing framework, and that is why we used it. Unit tests written in the native language of the wrapper can be used to test classes and functions that are written to support the main wrapper code. This reduces the layers of complexity that would be associated with testing only the functions declared in our GraphQL schema. For example, we wrote a PriorityQueue class to sort trades for the bestTradeExactIn and bestTradeExactOut functions. We used as-pect to test it. This simplified testing and debugging forbestTradeExactIn and bestTradeExactOut. We wrote many of our other tests in as-pect as well, in part because it was straightforward to copy and paste test scripts from the Uniswap v3 SDK repo and adapt the syntax. One quirk with as-pect is that the following must be added to its configuration file to get it working with Polywrap. imports: { w3: { __w3_invoke_args: () =&gt; {}, __w3_invoke_result: () =&gt; {}, __w3_invoke_error: () =&gt; {}, __w3_subinvoke: () =&gt; {}, __w3_subinvoke_result: () =&gt; {}, __w3_subinvoke_result_len: () =&gt; {}, __w3_subinvoke_error: () =&gt; {}, __w3_subinvoke_error_len: () =&gt; {}, __w3_abort: () =&gt; {}, } },  "},{"title":"End-to-end tests in JavaScript with Jest​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#end-to-end-tests-in-javascript-with-jest","content":"Not all tests can be written in the wrapper's native language, nor should they be. Code that depends on other wrappers or plugins must be tested by making calls to the Polywrap Client. The Client coordinates inter-API communication. We wrote many of our most important tests in the popular JavaScript framework jest. Were we to write the Uniswap v3 wrapper again, we would actually use a lot less as-pect and a lot more jest. One advantage of testing with jest is that it requires developers to make calls in the same way users of their wrappers are likely to make them. A disadvantage is that it requires developers to set up the Polywrap client and a test environment, which is easy but takes more time. You can learn how to set up a Polywrap test environment in JavaScript by reading Write an end to end test. "},{"title":"Other tips for testing in JavaScript​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#other-tips-for-testing-in-javascript","content":"The Polywrap CLI can automatically generate TypeScript types using the polywrap app command. The types mirror those declared in your GraphQL schema. If you love brevity, you can write functions that &quot;wrap&quot; your wrapper calls. This can make your tests a bit easier to read. // This function lets us call the createRoute function in the Uniswap v3 wrapper with one line of code export async function createRoute(client: PolywrapClient, ensUri: string, pools: Pool[], inToken: Token, outToken: Token): Promise&lt;Route&gt; { const query = await client.invoke&lt;Route&gt;({ uri: ensUri, module: &quot;query&quot;, method: &quot;createRoute&quot;, input: { pools, inToken, outToken, }, }); if (query.error) { throw query.error; } return query.data!; } // example usage const route_0_1: Route = await createRoute(client, ensUri, [pool_0_1], token0, token1);  "},{"title":"Documentation​","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"/tutorials/create-wasm-wrappers/uniswapv3-to-polywrap#documentation","content":"As a final touch, we generated ample documentation for the Uniswap v3 wrapper. Polywrap's GraphQL parser can read documentation comments (comments with triple quotes) from the wrapper's GraphQL schema. Using this capability, Polywrap built a tool to help developers create documentation for their wrappers. The Polywrap CLI will soon be able to use GraphQL schemas to automatically generate markdown that is compatible with popular documentation tools like Docusaurus. We tested the tool to generate the reference documentation for the Uniswap v3 wrapper. "},{"title":"Creating the Polywrap client instance","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/create-client-instance","content":"Creating the Polywrap client instance Once the Polywrap JS client has been installed, the next step is to create a PolywrapClient instance: import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient(); At this point, you can already invoke wrappers. In the simple example below, we send one to the &quot;hello world&quot; wrapper. client.invoke({ uri: &quot;ens/rinkeby/helloworld.dev.polywrap.eth&quot;, method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot; } }); ","keywords":""},{"title":"Configure the Polywrap Client","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/configure-client","content":"","keywords":""},{"title":"The ClientConfig object​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#the-clientconfig-object","content":"The PolywrapClient can be configured to redirect URIs, use different plugins, register interface implementations, set environmental variables, and customize URI resolution. interface ClientConfig { redirects: UriRedirect[]; // redirect queries from one uri to another plugins: PluginRegistration[]; // declare and configure plugins interfaces: InterfaceImplementations[]; // declare interface implementations envs: Env[]; // set environmental variables uriResolvers: UriResolver[]; // resolve custom URIs }  "},{"title":"The ClientConfigBuilder​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#the-clientconfigbuilder","content":"You can use the ClientConfigBuilder class present in @polywrap/client-config-builder-js to easily build the ClientConfig object: const config = new ClientConfigBuilder() .addDefaults() // add or remove configs here using ClientConfigBuilder methods... .build(); // We must specify `noDefaults: true` because they are included with the `addDefaults()` method of the ClientConfigBuilder. const client = new PolywrapClient(config, { noDefaults: true });  Alternatively, default configs will be added to the start of our custom configuration if we just pass a built ClientConfig to the client without specifying { noDefaults: true } in the options: const config = new ClientConfigBuilder() // add or remove configs here using ClientConfigBuilder methods... .build(); // The PolywrapClient adds defaults as a first step, then applies our `config` object const client = new PolywrapClient(config);  caution If you are using any kind of custom configuration, it is recommended that you use the ClientConfigBuilder to build your configuration objects, as the Polywrap client and its configurations are undergoing a major change from version 0.9 to 0.10. Doing so will ensure that you encounter as few breaking changes as possible - most likely none. "},{"title":"Redirects​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#redirects","content":"URI Redirects can be used to redirect queries from one URI to another. This redirection occurs in all queries to the URI, even in cases where one wrapper calls another during its execution. const clientConfig: Partial&lt;ClientConfig&gt; = { redirects: [ { from: &quot;wrap://ens/from.eth&quot;, // uri to redirect from to: &quot;wrap://ens/to.eth&quot;, // uri to redirct to } ], };  We can also use the ClientConfigBuilder to add a URI Redirect to our config: const config = new ClientConfigBuilder() .addDefaults() .addUriRedirect(&quot;wrap://ens/from.eth&quot;, &quot;wrap://ens/to.eth&quot;) .build();  "},{"title":"Plugins​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#plugins","content":"To use a plugin wrapper, it has to be registered in the ClientConfig. Each item in the array of plugins contains the URI at which the plugin will be invoked and a PluginPackage. A PluginPackage is a factory function the PolywrapClient uses to create new instances of the plugin. Each plugin can have its own configuration. const clientConfig: Partial&lt;ClientConfig&gt; = { plugins: [ { uri: &quot;wrap://ens/ethereum.polywrap.eth&quot;, plugin: ethereumPlugin({ networks: { testnet: { provider: &quot;http://localhost:8545&quot; }, }, defaultNetwork: &quot;testnet&quot;, }), }, ], };  We can also use the ClientConfigBuilder to add a Plugin to our config: const config = new ClientConfigBuilder() .addDefaults() .addPlugin( &quot;wrap://ens/ethereum.polywrap.eth&quot;, ethereumPlugin({ networks: { testnet: { provider: &quot;http://localhost:8545&quot; }, }, defaultNetwork: &quot;testnet&quot;, }) ) .build();  "},{"title":"Interfaces​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#interfaces","content":"Users can declare custom implementations for an interface by providing the interface URI and one or more URIs that resolve to implementations. const clientConfig: Partial&lt;ClientConfig&gt; = { interfaces: [ { interface: &quot;wrap://ens/logger.core.polywrap.eth&quot;, implementations: [&quot;wrap://ens/js-logger.polywrap.eth&quot;], }, ], };  We can also use the ClientConfigBuilder to add an Interface implementation to our config: const config = new ClientConfigBuilder() .addDefaults() .addInterfaceImplementation(&quot;wrap://ens/logger.core.polywrap.eth&quot;, &quot;wrap://ens/js-logger.polywrap.eth&quot;) .build();  "},{"title":"Envs​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#envs","content":"Users can provide wrapper-specific environmental variables by providing the wrapper URI and an object with strings as keys. Wrapper developers use the Wrapper Schema to specify which methods accept or require environmental variables. const clientConfig: Partial&lt;ClientConfig&gt; = { envs: [ { uri: &quot;wrap://ens/wrapper.eth&quot;, env: { connection: { networkNameOrChainId: &quot;polygon&quot;, }, }, }, ], };  We can also use the ClientConfigBuilder to add an Interface implementation to our config: const config = new ClientConfigBuilder() .addDefaults() .addEnv( &quot;wrap://ens/wrapper.eth&quot;, { connection: { networkNameOrChainId: &quot;polygon&quot;, }, } ) .build();  "},{"title":"Uri Resolvers​","type":1,"pageTitle":"Configure the Polywrap Client","url":"/tutorials/integrate-wrappers/configure-client#uri-resolvers","content":"By default, the Client can resolve ENS, IPFS, and filesystem URIs. It is possible to use custom URI Resolvers as well. Documentation on how to do so is coming soon! "},{"title":"Get Wrapper Metadata","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/get-wrapper-metadata","content":"Get Wrapper Metadata Some application developers may be interested adding or retrieving wrapper metadata. Wrapper developers can add metadata to their wrappers by writing a Meta Manifest file. Application developers can obtain the Meta Manifest as an object or class in the client's native language. More information about the contents of the Meta Manifest can be found in Add Metadata. The client's getFile method can be used to retrieve a file from a wrapper. It uses the wrapper URI as the root path. const result = await client.getFile(uri, { path: &quot;./polywrap.meta.json&quot;, encoding: &quot;utf-8&quot; }); if (!result.ok) return undefined; const manifest: MetaManifest = JSON.parse(result.value as string); To obtain icons from paths listed in a wrapper's Meta Manifest, use getFile again. The return type of getFile will be a string if the encoding option is used, and an ArrayBuffer otherwise. const isBuffer = await client.getFile(uri, { path: manifest.icon }); const isString = await client.getFile(uri, { path: manifest.icon, encoding: &quot;utf-8&quot; }); We wrote a React app to demo fetching and displaying wrapper metadata.You can view the source code here.","keywords":""},{"title":"Installing the Polywrap JS client","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/install-client","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#introduction","content":"If you're a JavaScript developer building Browser, Node.js, or React based apps, this guide is for you. tip In the future, JavaScript will be one of many supported languages. Our goal is to enable the use of Polywrap in every major programming language. By the end of this document, you'll gain the following skills: How to instantiate the Polywrap client in your JavaScript AppInvoke any wrapper using the Polywrap clientConfigure custom Polywrap URI redirectsBuild React apps with ease If you get stuck during this guide, send us a message on our Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#prerequisites","content":"As prerequisites for this guide, we recommend having familiarity with TypeScript. React will also be used in the latter sections. "},{"title":"Installation​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#installation","content":"To use wrappers in your app, all you need is the Polywrap Client! npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js, and browser applications. "},{"title":"Examples​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/integrate-wrappers/install-client#examples","content":"Some example projects that integrate the JS client can be found here. The next section assumes that you're integrating Polywrap into an existing app project. If you want a quick start with our template project, simply run: npx polywrap create app typescript-react &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-wrapper. This command will create a new project folder with a &quot;Hello World&quot; app that lets you interact with a simple Wasm wrapper at ens/rinkeby/helloworld.dev.polywrap.eth. "},{"title":"Generate types for your app","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/types-for-app","content":"","keywords":""},{"title":"App Manifest content​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/integrate-wrappers/types-for-app#app-manifest-content","content":"The App Manifest contains the name of the project, the programming language used to write it, and the location of the wrapper schema that states which code to generate. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of project language: # App programming language schema: # Path to wrapper schema import_redirects: # (Optional) Array of URI redirects - uri: # Source URI to be redirected schema: # Path to schema of the module to which URI will be redirected  "},{"title":"Wrapper Schema for apps​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/integrate-wrappers/types-for-app#wrapper-schema-for-apps","content":"To automatically generate types for an application or test suite, we must tell the Polywrap CLI which types to generate. This is done using a Wrapper Schema. In your wrapper schema, you can add an import statement for each wrapper you're using in your project. You can use the * syntax to import a wrapper's module and all of its types, or you can list the types you'd like to use. Wrapper schema for the Hello World app #import * into HelloWorld from &quot;ens/helloworld.polytest.eth&quot;  Learn more about schema imports at Wrapper Schema. "},{"title":"React integration","type":0,"sectionRef":"#","url":"/tutorials/integrate-wrappers/react-integration","content":"","keywords":""},{"title":"PolywrapProvider​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () =&gt; { return ( &lt;PolywrapProvider&gt; &lt;HelloWorld /&gt; &lt;/PolywrapProvider&gt; ); };  PolywrapProvider Props​ The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: &lt;PolywrapProvider redirects={ [] }/&gt;  Multiple PolywrapProviders​ If you need to use multiple providers, you can do so using the createPolywrapProvider(&quot;...&quot;) method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) =&gt; { return ( &lt;CustomPolywrapProvider&gt; {children} &lt;/CustomPolywrapProvider&gt; ); };  "},{"title":"usePolywrapClient​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient();  "},{"title":"usePolywrapInvoke​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wrappers! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/helloworld.polytest.eth', method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot;, }, });  tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, error, loading } = usePolywrapInvoke({ provider: &quot;custom&quot;, uri: 'ens/helloworld.polytest.eth', method: &quot;logMessage&quot;, args: { message: &quot;Hello World!&quot;, }, });  "},{"title":"usePolywrapQuery​","type":1,"pageTitle":"React integration","url":"/tutorials/integrate-wrappers/react-integration#usepolywrapquery","content":"The usePolywrapQuery hook works the same as the usePolywrapInvoke hook, but uses the client's query syntax instead. const { execute, data, errors, loading } = usePolywrapQuery({ uri: 'ens/helloworld.polytest.eth', query: `{ logMessage(message: &quot;Hello World!&quot;) }`, });  "},{"title":"Configure interfaces in the client","type":0,"sectionRef":"#","url":"/tutorials/interfaces/client-config-interfaces","content":"Configure interfaces in the client The Polywrap Client can be configured to use one or more implementations for an abstract interface wrapper. The interfaces property of the ClientConfig is declared as an array of InterfaceImplementation. Each InterfaceImplementation is assigned an interface wrapper URI and an array of URIs pointing to Wasm and plugin wrappers that implement the interface. For example, the URI Resolver interface is provided three implementation URIs in thePolywrap Client default configuration. interfaces: [ { interface: coreInterfaceUris.uriResolver, implementations: [ new Uri(&quot;wrap://ens/ipfs-resolver.polywrap.eth&quot;), new Uri(&quot;wrap://ens/ens-resolver.polywrap.eth&quot;), new Uri(&quot;wrap://ens/fs-resolver.polywrap.eth&quot;), ], } ] ","keywords":""},{"title":"Interface instances","type":0,"sectionRef":"#","url":"/tutorials/interfaces/interface-instances","content":"","keywords":""},{"title":"Instantiating an interface​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#instantiating-an-interface","content":"After an interface is imported in your Wrapper Schema, you can update the generated classes with the Polywrap CLI's codegen command. You will then be able to import the interface module in your wrapper. To instantiate an interface module, you must provide a URI that resolves to a wrapper that implements the interface. import { MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const instance = new MyInterface_Module(&quot;wrap://...&quot;); ... }  "},{"title":"Getting Interface Implementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#getting-interface-implementations","content":"To instantiate an interface agnostic to the implementation, you can use getImplementations to obtain a list of interface implementations registered in the Polywrap Client. "},{"title":"Declaring getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#declaring-getimplementations","content":"In addition to importing the interface module in the Wrapper Schema, you must declare that getImplementations will be used for the interface with the use { getImplementations } keywords. #import { Module } into MyInterface from &quot;wrap://ens/interface.eth&quot; #use { getImplementations } for MyInterface  "},{"title":"Using getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/interfaces/interface-instances#using-getimplementations","content":"Now you can import the interface namespace and call its getImplementations method. The getImplementations method returns an array of URI strings that can be used to instantiate the interface module. import { MyInterface, MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const impls = MyInterface.getImplementations(); if (impls.length &lt; 1) { throw new Error(&quot;...&quot;) } const instance = new MyInterface_Module(impls[0]); ... }  "},{"title":"Define and implement interfaces","type":0,"sectionRef":"#","url":"/tutorials/interfaces/define-implement-interfaces","content":"","keywords":""},{"title":"Declaring an interface project​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#declaring-an-interface-project","content":"Interface projects are declared using a Polywrap Manifest. To indicate that a project is an abstract interface, set the project language to interface. Interface projects do not have a module. Only a schema path is declared. format: 0.1.0 name: UriResolver deploy: ./polywrap.deploy.yaml language: interface schema: ./src/schema.graphql  "},{"title":"Defining an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#defining-an-interface","content":"Defining an interface is as simple as writing the Wrapper Schema. Once the schema is complete, you are ready to deploy the interface wrapper. "},{"title":"Implementing an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/interfaces/define-implement-interfaces#implementing-an-interface","content":"As described in Wrapper Schema, an interface can be imported and then implemented with the implements keyword. When a module implements an interface module, it inherits all of its method declarations. The ENS Resolver plugin implements the URI Resolver interface and inherits its methods. ENS Resolver SchemaURI Resolver Schema #import { Module, MaybeUriOrManifest } into UriResolver from &quot;ens/uri-resolver.core.polywrap.eth&quot; #import { Module } into Ethereum from &quot;ens/ethereum.polywrap.eth&quot; type Module implements UriResolver_Module {}  "},{"title":"Configure Polywrap infrastructure pipeline","type":0,"sectionRef":"#","url":"/tutorials/test-wasm-wrappers/infra-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#declaration","content":"Unlike some manifests, the Infra Manifest does not need to be declared in your Polywrap manifest. "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#content","content":"The Infra Manifest consists of environmental variable declarations and one or more infrastructure modules. Each module points to a local, remote, or default docker-compose file. SchemaExample format: # The manifest format version env: # Declare environmental variables here modules: myRemote: # A remote package with a docker-compose file package: # Package name version: # Package version registry: # Package registry name dockerComposePath: # (Optional) Path to docker-compose file in the package directory myLocal: # A local package with a docker-compose file path: # Path to the package eth-ens-ipfs: default # A module available by default  "},{"title":"Infrastructure Modules​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#infrastructure-modules","content":"An Infra Manifest can declare any number of infrastructure modules. Polywrap currently supports three types of infrastructure modules: A local module exists on your local filesystem.A remote module is a package hosted by a package registry.The default module is included with the CLI. "},{"title":"Local​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#local","content":"A local infrastructure module is a path from the Infra Manifest to a local folder with a docker-compose file. Example: local module configuration format: 0.1.0 modules: myLocal: path: ../local-packages/myLocal  "},{"title":"Remote​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#remote","content":"A remote infrastructure module is a package hosted at a package registry. The package must contain a docker-compose file. The path to the docker-compose file must be declared in the Infra Manifest if the file is not located in the package root. Remote packages can be shared. Users can add remote packages to their manifest to replicate the infrastructure modules defined by other users or projects. Example: remote module configuration format: 0.1.0 modules: myIpfsNode: package: &quot;@namestys/ipfs-node&quot; version: &quot;1.0.2&quot; registry: npm dockerComposePath: ./config/docker-compose.yaml  "},{"title":"Default​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wasm-wrappers/infra-pipeline#default","content":"A default infrastructure module is included with the polywrap CLI. It is declared in the Infra Manifest as a module named eth-ens-ipfs and the value default. If an Infra Manifest is not found, the Polywrap CLI infra command can still use this module. To use the default module without an Infra Manifest, pass eth-ens-ipfs as an argument to the infra command's modules option: npx polywrap infra up --modules=eth-ens-ipfs  The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wrappers and deploy them to an ENS registry on your locally hosted testnet. The Ethereum address of the ENS registry is 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab. Example: local module configuration format: 0.1.0 modules: eth-ens-ipfs: default  "},{"title":"Understanding plugins","type":0,"sectionRef":"#","url":"/tutorials/understanding-plugins","content":"","keywords":""},{"title":"Default Plugin wrappers​","type":1,"pageTitle":"Understanding plugins","url":"/tutorials/understanding-plugins#default-plugin-wrappers","content":"The Polywrap client has a default configuration that enables developers to use the following plugins: wrap://ens/js-logger.polywrap.ethwrap://ens/ipfs.polywrap.ethwrap://ens/ens-resolver.polywrap.ethwrap://ens/ethereum.polywrap.ethwrap://ens/http.polywrap.ethwrap://ens/fs.polywrap.ethwrap://ens/fs-resolver.polywrap.ethwrap://ens/ipfs-resolver.polywrap.eth NOTE: This default configuration will be removed in the near future, and replaced by a &quot;config builder&quot;. This will make the client agnostic, and allow users to combine and customize different &quot;config bundles&quot;, in addition to creating their your own. "},{"title":"Plugin URI Redirects​","type":1,"pageTitle":"Understanding plugins","url":"/tutorials/understanding-plugins#plugin-uri-redirects","content":"Plugin wrappers are configured using URI Redirects. We would specify the uri property as the URI of the plugin we want to use, and the plugin property as the actual plugin. For example, we can add an Ethereum plugin that uses MetaMask (or any other Ethereum JS provider) for its provider &amp; signer! import { PolywrapClient } from &quot;@polywrap/client-js&quot;; import { ethereumPlugin, Connections, Connection } from '@polywrap/ethereum-plugin-js'; // Enable Metamask const ethereum = (window as any).ethereum; await ethereum.request({ method: 'eth_requestAccounts', }); // Configure the Ethereum plugin w/ MetaMask const client = new PolywrapClient({ plugins: [{ uri: &quot;ens/ethereum.polywrap.eth&quot;, plugin: ethereumPlugin({ connections: new Connections({ networks: { mainnet: new Connection({ provider: ethereum }), }, // If defaultNetwork is not specified, mainnet will be used. defaultNetwork: &quot;mainnet&quot; }) }) }] });  "},{"title":"URI redirects","type":0,"sectionRef":"#","url":"/tutorials/understanding-uri-redirects","content":"URI redirects Similar to how browsers can redirect from one URI to another, the Polywrap client can have custom URI redirects configured as well. For example, if we'd like to redirect all queries from the ens/api.helloworld.polywrap.eth URI to our own custom URI (ens/api.myhelloworld.eth , for example), we'd simply configure the client like so: const client = new PolywrapClient({ redirects: [ { from: &quot;ens/api.helloworld.polywrap.eth&quot;, to: &quot;ens/api.myhelloworld.eth&quot;, }, ], }); caution The ens/api.myhelloworld.eth wrapper must fully implement the ens/api.helloworld.polywrap.eth schema.","keywords":""},{"title":"Running Workflows","type":0,"sectionRef":"#","url":"/tutorials/workflows/running-workflows","content":"","keywords":""},{"title":"Writing workflows​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/workflows/running-workflows#writing-workflows","content":"A workflow consists of a tree of Jobs and Steps. A Job is an independent, named unit that can contain an array of Steps named steps and/or a set of sub-Jobs named jobs. Each Job runs asynchronously, and therefore Jobs may run in any order. Although all the sub-jobs are guaranteed to be executed after the parent job completes. Outputs of the parent jobs can be referenced as the input of any of its sub-jobs. By default, test will run all jobs in a workflow. A Job index can be provided to test to execute a specific job. A Step is a wrapper invocation. An array of Steps runs synchronously--i.e. in the order defined in the workflow. The result of a Job or Step can be passed as an input argument to a Job or Step that is its child in the tree hierarchy. SchemaExample name: # name of the workflow jobs: # a set of one or more jobs case1: # a job, named by the user steps: # an array of steps - uri: fs/build # uri of invocation method: query # method to invoke args: # method arguments config: # (Optional) modified client configuration for this call  "},{"title":"Configuring the Client​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/workflows/running-workflows#configuring-the-client","content":"Users can configure the Polywrap client used to execute a workflow. This is done by providing the Polywrap CLI's test command with the path to a custom configuration file. The configuration file can be a JavaScript or TypeScript module. It must implement and export a function named getClientConfig. The getClientConfig function accepts the default ClientConfig as an argument and returns the custom Polywrap client configuration. It must be implemented with the following signature: TypeScriptJavaScript // asynchronous option export async function getClientConfig( defaultConfigs: Partial&lt;PolywrapClientConfig&gt; ): Promise&lt;Partial&lt;PolywrapClientConfig&gt;&gt; // synchronous option export function getClientConfig( defaultConfigs: Partial&lt;PolywrapClientConfig&gt; ): Partial&lt;PolywrapClientConfig&gt;  "},{"title":"Workflow output​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/workflows/running-workflows#workflow-output","content":"The output of a workflow can be written as a file in the JSON or YAML format with the output-file option of the Polywrap CLI'stest command. Workflow output is printed to the console by default. Console output can be suppressed with the quiet option of the Polywrap CLI's test command. "},{"title":"Workflow Validation","type":0,"sectionRef":"#","url":"/tutorials/workflows/workflow-validation","content":"","keywords":""},{"title":"CUE​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/workflows/workflow-validation#cue","content":"Validation files are written in CUE, an open-source data validation language. It has a simple syntax and is easy to use. CUE provides flexible data validation, including: matching exact valuesmatching typesmatching bounds (e.g. result &gt; 2)matching regular expressions To validate a workflow, you must have CUE installed on your computer. "},{"title":"Writing a validation script​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/workflows/workflow-validation#writing-a-validation-script","content":"A validation script should match the structure of the workflow it seeks to validate. It is compared against the output of the workflow. tip To validate a particular job in a workflow, your validation file should be modified to match the output of that particular job. The json-rpc demo uses aworkflow andvalidator to replicate its full integration test suite. We've provided a sample workflow and validation script based on the json-rpc demo here: workflow.yamlvalidator.cue name: json-rpc jobs: case1: steps: - uri: fs/build method: query args: url: &quot;https://archival-rpc.testnet.near.org&quot; request: method: &quot;gas_price&quot; params: &quot;[93019381]&quot; id: &quot;1&quot;  "},{"title":"Writing tests with TypeScript","type":0,"sectionRef":"#","url":"/tutorials/test-wasm-wrappers/end-to-end-test","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#introduction","content":"Here we discuss the process of writing end to end (e2e) tests for your Wasm wrapper using TypeScript. By end-to-end, we mean tests that make calls to the wrapper through a Polywrap Client. E2e testing is both necessary and useful. It is necessary because calls between wrappers depend on the Polywrap Client, and therefore cannot always be made in a Wasm wrapper's native language. It is useful because such tests can more accurately represent the user experience of your wrapper when it is integrated into an application. We will focus on setting up a test environment and a Polywrap Client. Once these tasks are completed, testing a Wasm wrapper is similar to testing a traditional SDK. "},{"title":"Prerequisites​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#prerequisites","content":"This guide uses TypeScript to implement the Polywrap test environment. We will also use the Jest testing framework, though you can use any framework and follow without difficulty. tip In the future, TypeScript will be one of many supported languages with a Polywrap client. As more Polywrap Clients are released in various languages, implementing plugin wrappers in those languages will be supported as well. You'll need the following installed as developer dependencies before testing your wrapper: polywrap@polywrap/test-env-js@polywrap/client-jsjest@types/jest These can be added to your TypeScript project using the npm or yarn package managers: npm install --save-dev polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest  yarn add -D polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest  "},{"title":"The Polywrap Test Environment​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#the-polywrap-test-environment","content":"An ideal Polywrap test environment will integrate everything you need to test your wrapper. In the case of this guide, we will need an IPFS node and an Ethereum test network. tip Polywrap makes it easy to create a custom test environment that you can start and stop with the Polywrap CLI. See Configure Polywrap infrastructure pipeline for more information. This guide will use the @polywrap/test-env-js package. The @polywrap/test-env-js package uses the default infrastructure module included with the polywrap CLI. We can use @polywrap/test-env-js to start and stop the test environment programmatically. The package also exports the ethereum provider, ipfs provider, and ens addresses used by the default infrastructure module. "},{"title":"Starting and stopping a Polywrap Test environment with @polywrap/test-env-js​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js","content":"If you're unfamiliar with @polywrap/test-env-js, feel free to check out the reference documentation before we continue. Let's start a new file where we will write our first test. Like many testing frameworks in JavaScript, the Jest framework includes hooks that run before and after all tests. I've added a call to initTestEnvironment in the beforeAll hook, so we can start our test environment before running our tests. I added a call to stopTestEnvironment in the afterAll hook to make sure the test environment does not continue running on our system after we finish testing. import { initTestEnvironment, stopTestEnvironment } from &quot;@polywrap/test-env-js&quot;; jest.setTimeout(360000); describe('Wrapper Test', () =&gt; { beforeAll(async () =&gt; { // initialize test environment await initTestEnvironment(); }); afterAll(async () =&gt; { // stop test environment await stopTestEnvironment(); }); test(&quot;&quot;, async () =&gt; { }); });  "},{"title":"Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js","content":"To invoke a Wasm wrapper in a test, we first need to build it. In this guide, we will do this with@polywrap/test-env-js using the buildWrapper function. tip Alternatively, we could have used the @polywrap/test-env-js function buildAndDeployWrapper. The buildAndDeployWrapper function will build a wrapper, deploy it to IPFS, point an ENS domain to it. It returns both the IPFS content hash and the ENS domain, either of which could be used to invoke the wrapper. The buildWrapper function requires an absolute path to the directory containing the wrapper's polywrap manifest. We will obtain the absolute path to our wrapper project in three steps. First we get the directory of the folder containing our test script, using the node.js __dirname global variable. We then append the path from our test script file to the manifest directory. Finally, we import the node.js feature path, and use path.resolve to get direct absolute path to our wrapper project. We will invoke our wrapper using the path to our build folder. We prefix the path with wrap://fs/ to conform to the WRAP URI standard, though prefixing the path with fs/ alone would work just as well. See URIs to learn more. import { buildWrapper, initTestEnvironment, stopTestEnvironment } from &quot;@polywrap/test-env-js&quot;; import path from &quot;path&quot;; jest.setTimeout(360000); describe('Wrapper Test', () =&gt; { // path to the wrapper's build folder let wrapperPath: string; beforeAll(async () =&gt; { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + &quot;/../../../&quot;); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` }); afterAll(async () =&gt; { // stop test environment await stopTestEnvironment(); }); test(&quot;&quot;, async () =&gt; { }); });  "},{"title":"Setting up a Polywrap Client​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#setting-up-a-polywrap-client","content":"Now that we have deployed our Wasm wrapper to a local test environment, we need to set up a Polywrap Client that can invoke it. We can make sure our client is ready to invoke the wrapper by configuring two of the default plugin wrappers. The ipfsResolverPlugin can be configured using the test environment's local IPFS node.The ethereumPlugin can be configured with an Ethereum provider for the Ganache Ethereum test network. "},{"title":"Configure the IPFS Resolver Plugin​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#configure-the-ipfs-resolver-plugin","content":"The ipfsResolverPlugin can be configured with a default IPFS provider and an array of fallback providers that will be tried if the default provider fails. import { ipfsPlugin, IpfsPluginConfig } from &quot;@polywrap/ipfs-plugin-js&quot;; const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, };  "},{"title":"Configure the Ethereum Plugin​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#configure-the-ethereum-plugin","content":"The ethereumPlugin can be configured with Ethereum providers and signers. It accepts JSON RPC provider strings, Providers from the ethers.js package, and providers from the web3.js package. To configure the plugin, we need to provide it with an object containing network names along with a provider. We can optionally provide a signer as well, but by default the plugin will attempt to obtain a signer from the provider if it is needed. We can give networks any name we want in our configuration. We can later use these names to choose which network to query. Here we will use the name &quot;testnet&quot; for our local Ethereum test network. We also need to tell the Ethereum plugin which network should be used when a network is not specified. We do this by setting the value of the defaultNetwork property to one of our network names. import { ethereumPlugin, EthereumPluginConfig } from &quot;@polywrap/ethereum-plugin-js&quot;; const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: &quot;testnet&quot;, };  "},{"title":"Create the Polywrap Client Instance​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#create-the-polywrap-client-instance","content":"Now we are ready to add the plugins to our Polywrap Client configuration and create the client. The URI's we assign in our client configuration will redirect to the plugin instances when queried. import { ClientConfig, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { ethereumPlugin, EthereumPluginConfig } from &quot;@polywrap/ethereum-plugin-js&quot;; import { ipfsPlugin, IpfsPluginConfig } from &quot;@polywrap/ipfs-plugin-js&quot;; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from &quot;@polywrap/test-env-js&quot;; import path from &quot;path&quot;; jest.setTimeout(360000); describe('Wrapper Test', () =&gt; { // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () =&gt; { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + &quot;/../../../&quot;); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: &quot;testnet&quot;, }; // configure the client const clientConfig: Partial&lt;ClientConfig&gt; = { plugins: [ { uri: &quot;wrap://ens/ipfs.polywrap.eth&quot;, plugin: ipfsPlugin(ipfsConfig), }, { uri: &quot;wrap://ens/ethereum.polywrap.eth&quot;, plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); }); afterAll(async () =&gt; { // stop test environment await stopTestEnvironment(); }); test(&quot;&quot;, async () =&gt; { }); });  "},{"title":"Deploy the Smart Contract​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#deploy-the-smart-contract","content":"The SimpleStorage wrapper is designed to interact with a SimpleStorage smart contract. We need to deploy an instance of the contract to work with. While there are many tools developers can use to deploy a smart contract on a local network, the SimpleStorage API has a method deployContract we can use to get the job done. We'll call it before running our test to make sure the contract is ready. import { ClientConfig, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { ethereumPlugin, EthereumPluginConfig } from &quot;@polywrap/ethereum-plugin-js&quot;; import { ipfsPlugin, IpfsPluginConfig } from &quot;@polywrap/ipfs-plugin-js&quot;; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from &quot;@polywrap/test-env-js&quot;; import path from &quot;path&quot;; jest.setTimeout(360000); describe('Wrapper Test', () =&gt; { // the Ethereum address of the SimpleStorage smart contract let simpleStorageAddress: string; // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () =&gt; { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + &quot;/../../../&quot;); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: &quot;testnet&quot;, }; // configure the client const clientConfig: Partial&lt;ClientConfig&gt; = { plugins: [ { uri: &quot;wrap://ens/ipfs.polywrap.eth&quot;, plugin: ipfsPlugin(ipfsConfig), }, { uri: &quot;wrap://ens/ethereum.polywrap.eth&quot;, plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); // deploy simple storage contract const { data, error } = await client.invoke&lt;string&gt;({ uri: wrapperPath, method: &quot;deployContract&quot;, }); if (error) throw error; simpleStorageAddress = data as string; }); afterAll(async () =&gt; { // stop test environment await stopTestEnvironment(); }); test(&quot;&quot;, async () =&gt; { }); });  "},{"title":"Generate TypeScript Types​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#generate-typescript-types","content":"Since we are using TypeScript, we will want types to work with. It is possible to automatically generate TypeScript types from a GraphQL schema using the Polywrap CLI's app command. Let's set up a polywrap.app.yaml manifest in a new folder called types. We will provide the manifest with the path to the composed schema in our build folder. polywrap.app.yaml format: 0.2.0 project: name: generate-typescript-types type: app/typescript source: schema: ../../../build/schema.graphql  We can then call the codegen command of the Polywrap CLI. yarn polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  The generated output includes TypeScript types for the SimpleStorage wrapper and its imports. types.ts ... export type String = string; export type Boolean = boolean; export interface SetIpfsDataOptions { address: Types.String; data: Types.String; } export interface SetIpfsDataResult { ipfsHash: Types.String; txReceipt: Types.String; } /// Imported Objects START /// /* URI: &quot;wrap://ens/ethereum.polywrap.eth&quot; */ export interface Ethereum_Connection { node?: Types.String | null; networkNameOrChainId?: Types.String | null; } ...  "},{"title":"Testing a Wrapper Method​","type":1,"pageTitle":"Writing tests with TypeScript","url":"/tutorials/test-wasm-wrappers/end-to-end-test#testing-a-wrapper-method","content":"From this point, testing a function in your wrapper is no different from testing a traditional SDK. Instead of calling a method in a traditional SDK, you will invoke your wrapper. We will test the setIpfsData method we added to the SimpleStorage API in Adding new functions. For arguments, the setIpfsData method takes the Ethereum address of a deployed SimpleStorage contract and the data the user wants to add to IPFS. It returns the IPFS hash of the data. We will test the setIpfsData method using the string &quot;Hello from IPFS!&quot; as the data for our test case. To be sure our method returns the correct IPFS hash, we can compare the method's return value to the value we get from the freeFile CID Checker service provided by Pinata. Final test file import { ClientConfig, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { ethereumPlugin, EthereumPluginConfig } from &quot;@polywrap/ethereum-plugin-js&quot;; import { ipfsPlugin, IpfsPluginConfig } from &quot;@polywrap/ipfs-plugin-js&quot;; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from &quot;@polywrap/test-env-js&quot;; import path from &quot;path&quot;; import { SetIpfsDataResult } from '../types/wrap'; jest.setTimeout(360000); describe('Wrapper Test', () =&gt; { // the Ethereum address of the SimpleStorage smart contract let simpleStorageAddress: string; // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () =&gt; { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + &quot;/../../../&quot;); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` console.log(wrapperPath); // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: &quot;testnet&quot;, }; // configure the client const clientConfig: Partial&lt;ClientConfig&gt; = { plugins: [ { uri: &quot;wrap://ens/ipfs.polywrap.eth&quot;, plugin: ipfsPlugin(ipfsConfig), }, { uri: &quot;wrap://ens/ethereum.polywrap.eth&quot;, plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); // deploy simple storage contract const { data, error } = await client.invoke&lt;string&gt;({ uri: wrapperPath, method: &quot;deployContract&quot;, }); if (error) throw error; simpleStorageAddress = data as string; console.log(simpleStorageAddress); }); afterAll(async () =&gt; { // stop test environment await stopTestEnvironment(); }); test(&quot;setIpfsData&quot;, async () =&gt; { // invoke setIpfs method const { data, error } = await client.invoke&lt;SetIpfsDataResult&gt;({ uri: wrapperPath, method: &quot;setIpfsData&quot;, args: { options: { address: simpleStorageAddress, data: &quot;Hello from IPFS!&quot;, }, } }); // check for errors expect(error).toBeFalsy(); // will be undefined if no exception is thrown in the wrapper expect(data).toBeTruthy(); // will be undefined if an exception is thrown in the wrapper // compare results expect(data?.ipfsHash).toEqual(&quot;QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis&quot;); }); });  "},{"title":"Wrapper Schema","type":0,"sectionRef":"#","url":"/tutorials/wrapper-schema","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#declaration","content":"A wrapper project's schema must be declared in the project manifest (Polywrap Manifest or Plugin Manifest). schema: ./src/schema.graphql  "},{"title":"Codegen​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#codegen","content":"The wrapper schema tells the Polywrap compiler which types and serialization logic to generate. Generated types are updated every time you build the wrapper. The polywrap CLI also provides a codegen command to quickly update the generated wrap folder where generated types are stored. The Polywrap compiler generates types for method arguments and custom schema types. Wrapper developers must use the generated method arguments for methods declared in the schema, and generated types for method return values when the return value is of a custom type. The generated types come with serialization logic that allows Wrappers to communicate with the client. The following example demonstrates this practice. DeclarationImplementation type Module { foo( bar: String! arg: Int! ): ReturnType! } type ReturnType { prop: Int! }  "},{"title":"Language Syntax​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#language-syntax","content":"Wrapper schemas are written in Polywrap's variant of the GraphQL schema definition language (SDL). Polywrap's GraphQL variant is simpler than standard GraphQL and easy to learn. "},{"title":"Custom Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#custom-types","content":"Custom types are declared with the type keyword. They can be given any number of properties. Properties can be of any supported type, including other custom types. type CustomType { myString: String! myObject: AnotherType! } type AnotherType { myInt: Int! }  "},{"title":"Nullability​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#nullability","content":"As in standard GraphQL, properties, method arguments, and method return values are declared non-nullable by appending a ! at the end of the type name. The absence of a ! indicates that a value is nullable. type CustomType { nullable: String # can be String or null nonNullable: String! # must be String }  "},{"title":"Methods​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#methods","content":"Methods are declared within the Module type. Methods must return a value. type Module { foo( arg: CustomType! bar: CustomType ): ReturnType! }  Custom types and modules can be imported from other wrappers by placing an import statement at the top of the schema. Imports become available in the schema immediately and in the wrapper following codegen. "},{"title":"Imports​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#imports","content":"Imported types and modules must be assigned a namespace. References to them are prepended with the namespace. #import { Module, CustomType } into Namespace from &quot;wrap://authority/path&quot; type CustomType { prop: Namespace_CustomType! }  "},{"title":"Example​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#example","content":"The following example uses all of the elements we've discussed so far. #import { Module, Connection } into Ethereum from &quot;wrap://ens/ethereum.polywrap.eth&quot; #import { Module } into Ipfs from &quot;wrap://ens/ipfs.polywrap.eth&quot; type Module { # methods are declared in type Module getIpfsData( address: String! # types ending with ! are non-nullable connection: Ethereum_Connection # imported types are used like local types ): String! setIpfsData( options: SetIpfsDataOptions! # custom types can be arguments connection: Ethereum_Connection ): SetIpfsDataResult! # custom types can be return values } type SetIpfsDataOptions { # custom types are declared with &quot;type&quot; keyword address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Default Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#default-types","content":"Polywrap's schema definition language supports three kinds of default types: Basic types like integers and stringsComplex types like BigInt and JSONGeneric types like Array and Map These types may be implemented differently in different programming languages. The language-specific implementations are clarified in each of the following sections. "},{"title":"Basic Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#basic-types","content":"Basic types include primitive types like integers and boolean values, as well as Strings and Bytes. SchemaClientWasm wrapper Schema Type\tDescriptionUInt\t32-bit unsigned integer UInt8\t8-bit unsigned integer UInt16\t16-bit unsigned integer UInt32\t32-bit unsigned integer Int\t32-bit signed integer Int8\t8-bit signed integer Int16\t16-bit signed integer Int32\t32-bit signed integer String\tUTF-8 string Boolean\tTrue or false stored as 1 byte Bytes\tArray of 8-bit unsigned integers "},{"title":"Complex Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#complex-types","content":"Complex types are represented as basic types to the Polywrap client and plugin wrappers. Within Wasm wrappers, they are implemented as classes or structs with behavior. For example, consider an application developer invoking a Wasm wrapper with the JavaScript client. If the invoked method requires an argument of type BigInt, the application developer will provide a stringrepresentation of an integer number to satisfy the argument. Within the wrapper, the string is deserialized into an instantion of the wrapper language's implementation of a BigInt. If the invoked method returns a BigInt, the wrapper will serialize the returned BigInt, which the client will then deserialize into a string before returning it to the application developer. SchemaClientWasm wrapper Schema Type\tDescriptionBigInt\tMultiple precision integer BigNumber\tMultiple precision float JSON\tJSON object "},{"title":"Generic Types​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#generic-types","content":"When using a generic type, with the exception of arrays, schema writers must add a directive annotation declaring its subtype(s). The directive takes the form @annotate(type: &quot;TypeName&lt;T\\&gt;&quot;), where T is the type of the subtype. The generic type and its subtype(s) can be independently nullable or non-nullable. The following example illustrates use of the generic type directive with the Map type. type Module { getKey( key: String! map: Map! @annotate(type: &quot;Map&lt;String!, Int!\\&gt;!&quot;) ): Int! returnMap( map: Map! @annotate(type: &quot;Map&lt;String!, Int!\\&gt;!&quot;) ): Map! @annotate(type: &quot;Map&lt;String!, Int!\\&gt;!&quot;) }  Like complex types, the implementation of generic types can differ by language. SchemaClientWasm wrapper Schema Type\tDescription[Type]\tArray of elements. Map\tMap of key-value pairs. "},{"title":"Interfaces​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#interfaces","content":"A module can inherit the method declarations of any other module by using the implements keyword. A module that implements an interface in this manner is required to implement and export the interface module's declared methods. Similarly, a type can inherit the property declarations of any other type by using the implements keyword. If a type implements an interface, it inherits the interface type's property declarations as though the properties were declared explicitly. #import { Module, InterfaceType } into Interface from &quot;wrap://ens/interface.eth&quot; type Module implements Interface_Module { # declares methods of Interface_Module } type ImplementationType implements Interface_InterfaceType { # declares properties of Interface_InterfaceType }  "},{"title":"Environmental Variables​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#environmental-variables","content":"Wrapper developers can declare a map of environmental variables for application developers to provide. To use environmental variables, declare an Env type and add a directive to each schema method that will use it. You can learn how to access environmental variables in code by reading the Access Env in the module section of our Environmental Variables documentation for wrapper developers. "},{"title":"Declare the Env object​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#declare-the-env-object","content":"Environmental variables are declared in a custom type named Env. type Env { str: String! number: Int! bool: Boolean! }  "},{"title":"Add the @env directive​","type":1,"pageTitle":"Wrapper Schema","url":"/tutorials/wrapper-schema#add-the-env-directive","content":"To access an Env object during a method invocation, add the @env directive to a method. The @env directive has one attribute that indicates whether the Env is required or optional. type Module { # App developers are required to provide Env to invoke this method methodRequireEnv( arg: String! ): String! @env(required: true) # Env is optional when invoking this method methodOptionalEnv( arg: String! ): String! @env(required: false) }  "}]