[{"title":"CLI","type":0,"sectionRef":"#","url":"/cli","content":"CLI The Polywrap CLI is a command-line tool used for integrating, building, deploying and testing Wraps. You can install the Polywrap CLI globally by running: npm install -g polywrap@latest You can learn everything you need about the CLI by either visiting the CLI Github repository, or running: polywrap help ","keywords":""},{"title":"Clients","type":0,"sectionRef":"#","url":"/clients","content":"Clients A Client is any library that can resolve and invoke Wraps. The Polywrap Foundation maintains a number of Clients, most notably: Polywrap JS ClientPolywrap Python ClientPolywrap Rust ClientPolywrap Swift ClientPolywrap Kotlin Client Other clients: Polywrap Go Client More clients are in development, such as a Polywrap C# Client(more soon).","keywords":""},{"title":"ABI","type":0,"sectionRef":"#","url":"/concepts/abi","content":"ABI In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user. In the context of Polywrap, an ABI refers to the interface a Wrap provides. It defines invokable methods and types found within the Wrap. The Wrap Manifest file (wrap.info) contains, among other things, the Wrap's ABI, which comes as a msgpack-encoded schema of the Wrap.","keywords":""},{"title":"Environmental variables","type":0,"sectionRef":"#","url":"/concepts/env-variables","content":"","keywords":""},{"title":"Schema declaration​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#schema-declaration","content":"To use environmental variables, wrapper developers must first declare an Env type and add the @env directive to methods in the Wrapper Schema. You can learn more about the schema declarations in the Environmental Variables section of the Wrapper Schema documentation. type Env { str: String! } type Module { foo( arg: String! ): String! @env(required: true) }  "},{"title":"Access Env in the module​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#access-env-in-the-module","content":"Environmental variables can be used in both plugin wrappers and Wasm wrappers. "},{"title":"Env in plugin wrappers​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#env-in-plugin-wrappers","content":"Plugin wrapper developers can access the Env instance as a class property. const env: Env = this.env;  "},{"title":"Env in wasm wrappers​","type":1,"pageTitle":"Environmental variables","url":"/concepts/env-variables#env-in-wasm-wrappers","content":"Wasm wrapper developers can access the Env instance by accepting the Env as a second argument in their module's methods. When an application developer invokes the method, the environmental variables they set in their ClientConfig will be provided. AssemblyScriptRust export class Module extends ModuleBase { // App developers are required to provide Env to invoke this method methodRequireEnv(_: Args_methodRequireEnv, env: Env): Env { return env; } // Env is optional when invoking this method methodOptionalEnv(_: Args_methodOptionalEnv, env: Env | null): Env | null { return env ? (env as Env) : null; } }  "},{"title":"URI redirects","type":0,"sectionRef":"#","url":"/concepts/uri-redirects","content":"URI redirects Similar to how browsers can redirect from one URI to another, the Polywrap client can have custom URI redirects configured as well. For example, if we'd like to redirect all queries from the ens/api.helloworld.polywrap.eth URI to our own custom URI (ens/api.myhelloworld.eth , for example), we'd simply configure the client like so: const config = new ClientConfigBuilder() .addDefaults() .addRedirect(&quot;ens/api.helloworld.polywrap.eth&quot;, &quot;ens/api.myhelloworld.eth&quot;) .build(); const client = new PolywrapClient(config); caution The ens/api.myhelloworld.eth wrapper must fully implement the ens/api.helloworld.polywrap.eth schema.","keywords":""},{"title":"Plugins","type":0,"sectionRef":"#","url":"/concepts/plugins","content":"","keywords":""},{"title":"Default Plugin wrappers​","type":1,"pageTitle":"Plugins","url":"/concepts/plugins#default-plugin-wrappers","content":"The Polywrap client has a default configuration that enables developers to use the following plugins and the interfaces they implement: Logger Plugin wrap://ens/wraps.eth:logger@1.0.0 HTTP Plugin ens/wraps.eth:http@1.1.0ens/wraps.eth:http@1.0.0 FileSystem Plugin ens/wraps.eth:file-system@1.0.0 Concurrency Plugin ens/wraps.eth:concurrent@1.0.0 Ethereum Provider Plugin V1 ens/wraps.eth:ethereum-provider@1.1.0ens/wraps.eth:ethereum-provider@1.0.0 V2 ens/wraps.eth:ethereum-provider@2.0.0 "},{"title":"Configuring Plugins​","type":1,"pageTitle":"Plugins","url":"/concepts/plugins#configuring-plugins","content":"Some plugins, like the Ethereum Provider, require additional configuration in certain environments like the browser. We can configure the Ethereum Provider plugin to use MetaMask (or any other Ethereum JS provider) for its provider &amp; signer using the Client Config Builder: import { ClientConfigBuilder, IWrapPackage, PolywrapClient, } from &quot;@polywrap/client-js&quot;; import { Connection, Connections, ethereumProviderPlugin, } from &quot;@polywrap/ethereum-provider-js&quot;; // Enable Metamask const ethereum = (window as any).ethereum; await ethereum.request({ method: &quot;eth_requestAccounts&quot;, }); // Configure the Ethereum plugin w/ MetaMask const config = new ClientConfigBuilder() .addDefaults() .addPackages({ &quot;wrap://ens/wraps.eth:ethereum-provider@2.0.0&quot;: ethereumProviderPlugin({ connections: new Connections({ networks: { goerli: new Connection({ provider: ethereum, }), }, defaultNetwork: &quot;goerli&quot;, }), }) as IWrapPackage, }) .build(); const client = new PolywrapClient(config);  "},{"title":"URIs","type":0,"sectionRef":"#","url":"/concepts/uris","content":"URIs Deployed wrappers are identified using custom URIs (Uniform Resource Identifier) called WRAP URIs. For example: wrap://ens/api.helloworld.polywrap.eth WRAP URIs follow the WRAP URI Standard. WRAP URIs have 3 parts: a protocol, an authority, and a path. Scheme​ WRAP URIs use the wrap scheme. Including wrap:// in your URI is optional in practice. Authority​ The Authority is used to denote which underlying protocol/standard the URI is part of. Usually, during URI resolution, the Polywrap Client will have at least one URI Resolver for each Authority used. For example: ens/ for resolving ENS domainsipfs/ for resolving IPFS contentfs/ for resolving content on the local filesystemhttp/ for resolving content via HTTP Path​ This is simply everything that comes after the Authority, and defines the unique resource we are trying to resolve. For example: api.domain.eth for an ENS domainQmaLbZnnnHbcRRo3wNBQ2MhugmBGL9R2YYeBvj6Nk2QumP for an IPFS file/directory./build for a local directoryexample.com/my-wrapper.wasm for a Wrap downloadable over HTTP tip ens/ and ipfs/ URI resolution is supported in all Polywrap clients by default. Adding custom URI resolvers is possible. More documentation on how to do this will be released soon.","keywords":""},{"title":"WASM","type":0,"sectionRef":"#","url":"/concepts/wasm","content":"WASM WASM (WebAssembly) is a binary instruction format designed to provide a portable and efficient target for the compilation of high-level programming languages such as C, C++, Rust, and others. It is a low-level, virtual machine-based format that is designed to be executed in web browsers, but can also be used in other contexts. WASM allows web developers to write web applications in languages other than JavaScript, while still being able to execute them in the browser. This provides a number of benefits, including better performance, improved security, and the ability to reuse existing code. In the context of Polywrap, WASM is used as the underlying technology to provide a secure, portable and efficient way to run Wraps. Polywrap loads and executs Wraps written in WASM, providing a sandboxed environment that ensures that the Wraps cannot interfere with the host application or other Wraps.","keywords":""},{"title":"Wraps","type":0,"sectionRef":"#","url":"/concepts/wraps","content":"Wraps Wraps are at the core of Polywrap - they are the portable, executable modules that can be called by any Polywrap Client. They are WASM modules accompanied by a manifest file which describes said module. A Wrap consists of at least the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions) - wrap.wasmA Wrap Manifest file that orchestrates the wrapper, and provides types and parameters for the module functions (it's ABI) - wrap.info Additional files can be present in a Wrap (e.g. metadata files), but these are not required for a Wrap to be valid.","keywords":""},{"title":"Wrap Schema","type":0,"sectionRef":"#","url":"/concepts/wrap-schema","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#declaration","content":"A wrap project's schema must be declared in the project manifest (Polywrap Manifest or Plugin Manifest). source: module: ./src/index.ts schema: ./src/schema.graphql  "},{"title":"Codegen​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#codegen","content":"The wrap schema tells the Polywrap compiler which types and serialization logic to generate. Generated types are updated every time you build the wrap. The Polywrap CLI also provides a codegen command to quickly update the generated wrap folder where generated types are stored. The Polywrap compiler generates types for method arguments and custom schema types. Wrap developers must use the generated method arguments for methods declared in the schema, and generated types for method return values when the return value is of a custom type. The generated types come with serialization logic that allows Wraps to communicate with the client. The following example demonstrates this practice. DeclarationImplementation type Module { sampleMethod(arg: String!): SampleResult! } type SampleResult { result: String! }  "},{"title":"Language Syntax​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#language-syntax","content":"Wrap schemas are written in Polywrap's variant of the GraphQL schema definition language (SDL). Polywrap's GraphQL variant is simpler than standard GraphQL and easy to learn. "},{"title":"Custom Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#custom-types","content":"Custom types are declared with the type keyword. They can be given any number of properties. Properties can be of any supported type, including other custom types. type CustomType { myString: String! myObject: AnotherType! } type AnotherType { myInt: Int! }  "},{"title":"Nullability​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#nullability","content":"As in standard GraphQL, properties, method arguments, and method return values are declared non-nullable by appending a ! at the end of the type name. The absence of a ! indicates that a value is nullable. type CustomType { nullable: String # can be String or null nonNullable: String! # must be String }  "},{"title":"Methods​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#methods","content":"Methods are declared within the Module type. Methods must return a value. type Module { foo( arg: CustomType! bar: CustomType ): ReturnType! }  Custom types and modules can be imported from other wraps by placing an import statement at the top of the schema. Imports become available in the schema immediately and in the wrap following codegen. "},{"title":"Imports​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#imports","content":"Imported types and modules must be assigned a namespace. References to them are prepended with the namespace. #import { Module, CustomType } into Namespace from &quot;wrap://authority/path&quot; type CustomType { prop: Namespace_CustomType! }  "},{"title":"Example​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#example","content":"The following example uses all of the elements we've discussed so far. #import { Module, Connection } into Ethereum from &quot;wrap://ens/wraps.eth:ethereum@2.0.0&quot; #import { Module } into Ipfs from &quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot; type Module { # methods are declared in type Module getIpfsData( address: String! # types ending with ! are non-nullable ipfsProvider: String! connection: Ethereum_Connection # imported types are used like local types ): String! setIpfsData( options: SetIpfsDataOptions! # custom types can be arguments ipfsProvider: String! connection: Ethereum_Connection ): SetIpfsDataResult! # custom types can be return values } type SetIpfsDataOptions { # custom types are declared with &quot;type&quot; keyword address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Default Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#default-types","content":"Polywrap's schema definition language supports three kinds of default types: Basic types like integers and stringsComplex types like BigInt and JSONGeneric types like Array and Map These types may be implemented differently in different programming languages. The language-specific implementations are clarified in each of the following sections. "},{"title":"Basic Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#basic-types","content":"Basic types include primitive types like integers and boolean values, as well as Strings and Bytes. SchemaClientWasm wrap Schema Type\tDescriptionUInt\t32-bit unsigned integer UInt8\t8-bit unsigned integer UInt16\t16-bit unsigned integer UInt32\t32-bit unsigned integer Int\t32-bit signed integer Int8\t8-bit signed integer Int16\t16-bit signed integer Int32\t32-bit signed integer String\tUTF-8 string Boolean\tTrue or false stored as 1 byte Bytes\tArray of 8-bit unsigned integers "},{"title":"Complex Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#complex-types","content":"Complex types are represented as basic types to the Polywrap client and plugin wraps. Within Wasm wraps, they are implemented as classes or structs with behavior. For example, consider an application developer invoking a Wasm wrap with the JavaScript client. If the invoked method requires an argument of type BigInt, the application developer will provide a stringrepresentation of an integer number to satisfy the argument. Within the wrap, the string is deserialized into an instantion of the wrap language's implementation of a BigInt. If the invoked method returns a BigInt, the wrap will serialize the returned BigInt, which the client will then deserialize into a string before returning it to the application developer. SchemaClientWasm wrap Schema Type\tDescriptionBigInt\tMultiple precision integer BigNumber\tMultiple precision float JSON\tJSON object "},{"title":"Generic Types​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#generic-types","content":"When using a generic type, with the exception of arrays, schema writers must add a directive annotation declaring its subtype(s). The directive takes the form @annotate(type: &quot;TypeName&lt;T\\&gt;&quot;), where T is the type of the subtype. The generic type and its subtype(s) can be independently nullable or non-nullable. The following example illustrates use of the generic type directive with the Map type. type Module { getKey( key: String! map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Int! returnMap( map: Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) ): Map! @annotate(type: &quot;Map&lt;String!, Int!&gt;!&quot;) }  Like complex types, the implementation of generic types can differ by language. SchemaClientWasm wrap Schema Type\tDescription[Type]\tArray of elements. Map\tMap of key-value pairs. "},{"title":"Interfaces​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#interfaces","content":"A module can inherit the method declarations of any other module by using the implements keyword. A module that implements an interface in this manner is required to implement and export the interface module's declared methods. Similarly, a type can inherit the property declarations of any other type by using the implements keyword. If a type implements an interface, it inherits the interface type's property declarations as though the properties were declared explicitly. #import { Module, InterfaceType } into Interface from &quot;wrap://ens/interface.eth&quot; type Module implements Interface_Module { # declares methods of Interface_Module } type ImplementationType implements Interface_InterfaceType { # declares properties of Interface_InterfaceType }  "},{"title":"Environmental Variables​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#environmental-variables","content":"Wrap developers can declare a map of environmental variables for application developers to provide. To use environmental variables, declare an Env type and add a directive to each schema method that will use it. You can learn how to access environmental variables in code by reading the Access Env in the module section of our Environmental Variables documentation for wrap developers. "},{"title":"Declare the Env object​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#declare-the-env-object","content":"Environmental variables are declared in a custom type named Env. type Env { str: String! number: Int! bool: Boolean! }  "},{"title":"Add the @env directive​","type":1,"pageTitle":"Wrap Schema","url":"/concepts/wrap-schema#add-the-env-directive","content":"To access an Env object during a method invocation, add the @env directive to a method. The @env directive has one attribute that indicates whether the Env is required or optional. type Module { # App developers are required to provide Env to invoke this method methodRequireEnv( arg: String! ): String! @env(required: true) # Env is optional when invoking this method methodOptionalEnv( arg: String! ): String! @env(required: false) }  "},{"title":"Quick start","type":0,"sectionRef":"#","url":"/quick-start","content":"","keywords":""},{"title":"The Polywrap Client​","type":1,"pageTitle":"Quick start","url":"/quick-start#the-polywrap-client","content":"To use Wraps in your app, all you need is the Polywrap Client! tip Currently we have a stable implementation of the Polywrap Client in Javascript. Python, Rust, Swift, Kotlin, and C# are coming soon. "},{"title":"NodeJS application boilerplate​","type":1,"pageTitle":"Quick start","url":"/quick-start#nodejs-application-boilerplate","content":"We'll be using a simple NodeJS application boilerplate for this guide. Using npm init or yarn init within a directory initialize an empty NodeJS project. Within package.json, change the type of the project to &quot;module&quot;. This is not required as you can also use require. package.json { &quot;name&quot;: &quot;my-app-name&quot;, //... &quot;type&quot;: &quot;module&quot;, //... }  Add an index.js file with the following code: index.js async function main() { // your code goes here... } main() .then(() =&gt; { process.exit(0); }) .catch((error) =&gt; { console.error(error); process.exit(1); });  "},{"title":"Install the Polywrap Client​","type":1,"pageTitle":"Quick start","url":"/quick-start#install-the-polywrap-client","content":"Using NPM: npm install --save @polywrap/client-js  Using yarn: yarn add @polywrap/client-js  "},{"title":"Invoking your first Wrap​","type":1,"pageTitle":"Quick start","url":"/quick-start#invoking-your-first-wrap","content":"In order to invoke a Wrap, we first need to instantiate the Polywrap Client: At the top of your index.js file, import the PolywrapClient and instantiate it: index.js import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient();  At this point, you can already invoke Wraps! In the simple example below, we will invoke the Logger Wrap within our main function: const result = await client.invoke({ uri: &quot;ens/wraps.eth:logger@1.0.0&quot;, method: &quot;log&quot;, args: { message: &quot;Hello Polywrap!&quot;, }, }); console.log(result);  Running the application using node index.js, you should now see two lines appear in your console: Hello Polywrap! { ok: true, value: true }  The first line is printed by the Logger Wrap, while the second line shows the structure of the InvokeResult object. What's going on here?​ Using the Polywrap Client, we are invoking the log method of a Wrap found under the WRAP URI ens/wraps.eth:logger@1.0.0 called the Logger Wrap. Under the hood, through a process we call URI Resolution, the Polywrap Client knows how to fetch and execute the Wrap from decentralized storage. The PolywrapClient comes pre-configured with everything you need for most Web2 and Web3 use-cases by default. The InvokeResult object​ The InvokeResult object can have one of two structures: A successful Wrap invocation returns { ok: true, value: ... } with value being the return value of the Wrap invocation. This can be anything - a boolean value, a string, an object, etc.A failed Wrap invocation returns { ok: false, error: ... } with error describing the reason for invocation failure. Although not particularly useful in our last example, our next example leverages the fact that Wrap invocations return a value. "},{"title":"Universal SDKs​","type":1,"pageTitle":"Quick start","url":"/quick-start#universal-sdks","content":"Now that we know how a Wrap is invoked, let's see Polywrap's true use-case: universal SDKs! One of the greatest benefits of Polywrap for the end-user (you!) lies in the fact that you can use the Polywrap Client to invoke the same Wrap from a variety of platforms and languages. If there's a Polywrap Client for your language, you can invoke any Wrap. This means that you can use the same SDK across multiple languages! Another important benefit of using Polywrap is that, since Wraps are downloaded from various sources, you can automatically receive patches and updates to your SDKs without having to update your codebase. Now we'll invoke the Uniswap V3 Wrap which is a port of the Uniswap SDK, but written as a Wrap. We can use the Uniswap Wrap to fetch Uniswap's basic data related to the WETH and USDC tokes, find the address of the pool for those two tokens. We are also checking each result for errors. const wethResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if(!wethResult.ok) { console.log(wethResult.error) return; } console.log(&quot;WETH:&quot;, wethResult.value); const usdcResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;, chainId: &quot;MAINNET&quot;, }, }); // Log the invocation error and stop execution if the invocation fails if(!usdcResult.ok) { console.log(usdcResult.error) return; } console.log(&quot;USDC:&quot;, usdcResult.value); const poolAddressResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;getPoolAddress&quot;, args: { tokenA: wethResult.value, tokenB: usdcResult.value, fee: &quot;MEDIUM&quot; }, }); // Log the invocation error and stop execution if the invocation fails if(!poolAddressResult.ok) { console.log(poolAddressResult.error); return; } console.log(&quot;Pool address:&quot;, poolAddressResult.value);  You can see more examples on how to use the Uniswap V3 Wrap in its docs page. "},{"title":"Compose everything​","type":1,"pageTitle":"Quick start","url":"/quick-start#compose-everything","content":"So far, we've only invoked a single Wrap, essentially using Polywrap to access a single SDK. Using the Polywrap Client, we can invoke any number of SDKs, allowing us to build infinitely composable applications. If there's a Wrap for it, we can invoke it and use its functionality. In this chapter's last example, we will use two separate SDKs to figure out the IPFS hash behind the Logger Wrap's ENS domain record, then fetch that Wrap's schema (more about that in the next chapter). First, we will use the Ens Text Record Resolver Wrap to resolve the ENS domain to an IPFS Wrap URI. // We first want to resolve the ENS address (uniswap.wraps.eth) // and text record (v3) into an IPFS WRAP URI const resolutionResult = await client.invoke({ uri: &quot;ens/wraps.eth:ens-text-record-uri-resolver-ext@1.0.0&quot;, method: &quot;tryResolveUri&quot;, args: { authority: &quot;ens&quot;, path: &quot;uniswap.wraps.eth:v3&quot;, }, }); if (!resolutionResult.ok) { console.log(resolutionResult.error); return; } console.log(resolutionResult.value);  Now, if we look at the uri property of resolutionResult.value, we will see a WRAP URI. We can also see a manifest property which is set to null, which you can safely ignore for now. This is because our ENS Text Record Resolver Wrap only resolves from an ENS Text Record to another URI. Once we have the IPFS hash, we will use the IPFS Wrap to fetch the contents of the Wrap's manifest file (wrap.info), and print them out. // Extract the IPFS CID from the resolution result's URI const cid = resolutionResult.value.uri.replace(&quot;wrap://ipfs/&quot;, &quot;&quot;); // Since the CID is a directory, we need to add a path to the Wrap's manifest file const catResult = await client.invoke({ uri: &quot;ens/wraps.eth:ipfs-http-client@1.0.0&quot;, method: &quot;cat&quot;, args: { cid: cid + &quot;/wrap.info&quot;, ipfsProvider: &quot;https://ipfs.wrappers.io&quot; }, }); console.log(catResult); if (!catResult.ok) { console.log(catResult.error); return; } // Turn the returned buffer into a string and log it const schema = new TextDecoder().decode(catResult.value); console.log(schema);  In this example, we printed out a Wrap's Manifest file. This is a file that contains the definiton of the Wrap. Amongst other things it contains what types and methods are present within a Wrap, called the Wrap's Schema, and we'll talk more about it in the next section. "},{"title":"The Polywrap CLI​","type":1,"pageTitle":"Quick start","url":"/quick-start#the-polywrap-cli","content":"Now that we have a basic understanding of the Polywrap Client, it's time to see how we can use the Polywrap CLI to create an amazing experience when working with Wraps. "},{"title":"Installation​","type":1,"pageTitle":"Quick start","url":"/quick-start#installation","content":"To install the Polywrap CLI, add the polywrap package as a dev dependency to your project: NPM: npm i --save-dev polywrap  Yarn: yarn add --dev polywrap  You can also install the Polywrap CLI globally: NPM: npm i -g polywrap  Yarn: yarn global add polywrap  "},{"title":"Overview​","type":1,"pageTitle":"Quick start","url":"/quick-start#overview","content":"The Polywrap CLI allows us not only to build, test, and deploy Wraps, but also generate types for our applications which use the Polywrap Client. This tutorial assumes that you installed polywrap globally, but you can always prefix the commands with npx or yarn run to run the locally installed version of your Polywrap CLI. You can see all available commands by running: polywrap help  "},{"title":"Create a Polywrap-powered application​","type":1,"pageTitle":"Quick start","url":"/quick-start#create-a-polywrap-powered-application","content":"tip If you already have an application you want to add Polywrap to, it is advised that you still follow this guide and transfer/modify the polywrap.yaml and src/schema.graphql files once you're done with this tutorial. The Polywrap CLI can be used to quickly set up a template application. For this tutorial, we will create a sample Node application written in Typescript and use the Polywrap Client to invoke multiple Wraps. To set up a Polywrap-powered application, run: polywrap create app typescript my-application  This uses the create command to set up a template Node application written in Typescript called my-application inside the my-application/ directory. Now we want to navigate into the application folder and install its dependencies. cd my-application yarn  If you take a look at package.json, you'll find the app depends on @polywrap/client-js and has a dev dependency on polywrap, with the addition of minimal dev dependencies that allow us to develop the app using Typescript. Now let's take a look at some of the files Polywrap works with. "},{"title":"The Polywrap Manifest (polywrap.yaml)​","type":1,"pageTitle":"Quick start","url":"/quick-start#the-polywrap-manifest-polywrapyaml","content":"In order for the Polywrap CLI to know what it's working with, it needs a Polywrap Manifest file to obtain some basic information about your project. This is the polywrap.yaml file. It has a structure similar to this: polywrap.yaml format: 0.3.0 project: name: Sample type: app/typescript source: schema: ./schema.graphql  The format property denotes the version of the Polywrap Manifest format. Under project, you can set the name field to the name of your application, while the type field describes the project type, thus letting the CLI know how to interact with the application code. Under the source section, we have a schema field with a path that leads to a Schema file. In the context of a Polywrap-powered application project, this file defines which Wraps our application imports/uses. This will come in handy later when we'll use the CLI to generate types and code which your app will use. The Schema File (schema.graphql)​ Every Polywrap project has a Schema file - it defines the types found within the project, what Wraps the project imports, and, in the case of a WASM Wrap, the methods that Wrap exposes. In the context of an application project, the Schema file defines which Wraps our application imports and is used by the CLI to generate code with which we can invoke our Wraps in a type-safe manner. Taking a look at the file, we can see two import statements: schema.graphql #import * into Logging from &quot;ens/wraps.eth:logging@1.0.0&quot; #import * into Ethereum from &quot;ens/wraps.eth:ethereum@1.0.0&quot;  An import statement defines which Wraps we are importing, therefore using within our application. Imports are namespaced - the Wrap found under the WRAP URI ens/wraps.eth:logging@1.0.0 is going to be found within the Logging_ namespace. Generating types (codegen)​ caution While we used Javascript in previous samples, Polywrap is native to Typescript, and all future examples will be written in Typescript. Now that we know how we can &quot;import&quot; Wraps into our application, we can use the codegen command inside the Polywrap CLI to generate types that represent our Wraps which we can use within our application. To generate types, all we need to do is run the codegen command: polywrap codegen  This will generate types inside the src/wrap directory which you will use within your application. "},{"title":"Introduce type-safety into your code​","type":1,"pageTitle":"Quick start","url":"/quick-start#introduce-type-safety-into-your-code","content":"Now that we have our types generated, we can take a look at our sample application's src/index.ts file. Let's first take a look at some of the imports: import { Logging_Module, Ethereum_Module, } from &quot;./wrap&quot;;  Here we can see that we've imported Module types that represent our Wraps, according to their specified namespace. Using these types, we can invoke our Wraps in a type-safe manner, without having to repeatedly specify the Wrap URI: const client = new PolywrapClient(); await Logging_Module.info({ message: &quot;Hello there&quot;, }, client);  This allows us to write all of our code in a type-safe manner, and allows for IDEs like VS Code to give us autocompletion suggestions via IntelliSense. Now we can explore our Wraps by simply importing them and trying them out! "},{"title":"A real-world example, revisited​","type":1,"pageTitle":"Quick start","url":"/quick-start#a-real-world-example-revisited","content":"Let's revisit our Uniswap V3 Wrap example from the Quick Start tutorial. If we wanted to invoke the Uniswap V3 Wrap without codegen, we had to write the following code: const usdcResult = await client.invoke({ uri: &quot;ens/uniswap.wraps.eth:v3&quot;, method: &quot;fetchToken&quot;, args: { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: &quot;MAINNET&quot;, }, });  Instead, we can now add an import statement for the Uniswap V3 Wrap to our schema.graphql file: schema.graphql #import * into UniswapV3 from &quot;ens/uniswap.wraps.eth:v3&quot;  Running codegen now will add all types defined inside the Uniswap V3 Wrap to our wrap folder: polywrap codegen  We can now import the UniswapV3_Module and supporting types into our index.ts file: import { UniswapV3_Module, UniswapV3_ChainIdEnum, } from &quot;./wrap&quot;;  We can now invoke the Uniswap V3 Wrap by writing: const usdcResult = await UniswapV3_Module.fetchToken( { address: &quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;, chainId: UniswapV3_ChainIdEnum.MAINNET, }, client );  Already inside the invocation, we can see that the chainId is an enum type, with all supported networks already listed. Polywrap also takes care of required and optional arguments, and if you play around, you will find that we omitted the name and symbol optional invocation arguments. If usdcResult.ok is true, its value will now have a type of UniswapV3_Token: if(!usdcResult.ok) { console.error(usdcResult.error); return; } // token is now of type UniswapV3_Token found in &quot;./wrap&quot; const token = usdcResult.value; console.log(token);  As you can see, Polywrap allows us to invoke any SDK or other piece of executable logic packaged as a Wrap in a type-safe manner, accross a multitude of platforms and languages! Of course, by using the Polywrap CLI you can build your own Wraps which you will be able to run anywhere where there's a Polywrap Client. Make sure to check out our list of supported (and coming) clients, and proceed to the next section to see what Wraps are readily available! "},{"title":"Plugin an existing JS SDK","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/create-js-plugin","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#introduction","content":"In this guide, we'll walk you through creating your own JavaScript-based plugin that can be added to the JavaScript Polywrap Client. caution Plugins do not retain all of Polywrap's benefits. We recommend re-writing your existing JavaScript SDKs as Wasm wraps if possible. As always, if you need any help, message us on Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#prerequisites","content":"You'll need the following installed before building your plugin: nvmyarn You'll be using TypeScript to implement your Polywrap plugin. tip In the future, TypeScript will be one of many supported languages for implementing plugins. As more Polywrap Clients are released in various languages, implementing plugins in those languages will be supported as well. "},{"title":"Getting started​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#getting-started","content":"To get started, use the following command to spin up a project folder for your plugin. npx polywrap create plugin typescript &lt;project-name&gt;  Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-plugin. Once complete, you'll see a new folder appear, named after the custom name you've chosen. Please navigate into this new directory (using cd for example). "},{"title":"Installation​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#installation","content":"Let's ensure all of your project's dependencies are installed. From inside your project's directory, simply run: nvm install &amp;&amp; nvm useyarn "},{"title":"Overview of project files​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#overview-of-project-files","content":"Your project should look something like this: polywrap.yaml # Plugin Manifest src/ | index.ts # Entry File │ schema.graphql # Schema  "},{"title":"polywrap.yaml​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#polywrapyaml","content":"The Plugin Project Manifest describes the layout of a plugin. "},{"title":"schema.graphql​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#schemagraphql","content":"Each wrap project has a Wrap Schema. The schema defines the wrap's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrap. "},{"title":"src/index.ts​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#srcindexts","content":"The index.ts file exports the wrap's method's implementations, which contain the plugin's logic. Learn more about the plugin's code architecture by reading Plugin Architecture "},{"title":"Building the plugin​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#building-the-plugin","content":"To build your plugin, all you need is the following command: yarn build # alias for &quot;npx polywrap build&quot;  "},{"title":"Example Plugins​","type":1,"pageTitle":"Plugin an existing JS SDK","url":"/tutorials/advanced/create-plugins/create-js-plugin#example-plugins","content":"See Understanding Plugins for some examples of Plugins used within the default configuration of the Polywrap Client. "},{"title":"Configure a Plugin Manifest","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/plugin-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Plugin Manifest","url":"/tutorials/advanced/create-plugins/plugin-manifest#content","content":"The Plugin Manifest contains the name of the plugin, programming language used to write the plugin, the location of the plugin's entry file (i.e. the file that exports the plugin contents), and the GraphQl schema that declares the plugin's interface. SchemaExample format: # Polywrap manifest format version. Values: 0.3.0 project: # Basic project properties. name: # Name of this project. type: # Type of this project. source: # Project source files. module: # Path to the project's entry point. schema: # Path to the project's graphql schema. import_abis: # Specify ABIs to be used for the import URIs within your schema.  "},{"title":"Plugin Architecture","type":0,"sectionRef":"#","url":"/tutorials/advanced/create-plugins/plugin-architecture","content":"","keywords":""},{"title":"Required Exports​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#required-exports","content":"A plugin must export a PluginFactory to be used by the Polywrap Client. A PluginFactory is a function that returns a PluginPackageManifest and a factory method that generates an instance of the plugin. "},{"title":"TypeScript Support​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#typescript-support","content":"The Polywrap CLI's codegen and build commands will generate a wrap folder containing useful types. The generated types will save you time and energy. You won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs. You can forget about boilerplate code and focus on your plugin's logic. While the types are not strictly required, we recommend them as a best practice. The generated types include: Module - An interface containing the methods declared in the plugin's schemaArgs_* - An interface for each method, containing the method arguments declared in the schemaCustom Types - An interface for each custom type declared in the schemamanifest - A PluginPackageManifest for the plugin (also useful for JavaScript developers!) "},{"title":"Example​","type":1,"pageTitle":"Plugin Architecture","url":"/tutorials/advanced/create-plugins/plugin-architecture#example","content":"&quot;Example: import { Module, Args_sampleMethod, manifest } from &quot;./wrap&quot;; // imports from generated &quot;wrap&quot; folder import { PluginFactory, PluginPackage } from &quot;@polywrap/plugin-js&quot;; // plugin must export a PluginFactory export interface SamplePluginConfig { defaultValue: string; } export class SamplePlugin extends Module&lt;SamplePluginConfig&gt; { // Plugin inherits from Module constructor(config: SamplePluginConfig) { super(config); } public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument return args.data + this.config.defaultValue; } } export const samplePlugin: PluginFactory&lt;SamplePluginConfig&gt; = ( // exported PluginFactory is used by Polywrap client config: SamplePluginConfig ) =&gt; { return new PluginPackage( new SamplePlugin(config), // factory method produces a Module manifest // imported from ./wrap ); }; export const plugin = samplePlugin; // PluginFactory is exported with name &quot;plugin&quot;  "},{"title":"Configure interfaces in the client","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/client-config-interfaces","content":"Configure interfaces in the client The Polywrap Client can be configured to use one or more implementations for an abstract interface. You can use the Client Config Builder to register implementations for an interface URI. const config = new ClientConfigBuilder() .addDefaults() .addInterfaceImplementations( &quot;wrap://ens/wrap.interface.eth&quot;, [ &quot;wrap://ens/wrap.implementation1.eth&quot;, &quot;wrap://ens/wrap.implementation2.eth&quot;, &quot;wrap://ens/wrap.implementation3.eth&quot;, ] ) .build(); ","keywords":""},{"title":"Define and implement interfaces","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/define-implement-interfaces","content":"","keywords":""},{"title":"Declaring an interface project​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#declaring-an-interface-project","content":"Interface projects are declared using a Polywrap Manifest. To indicate that a project is an abstract interface, set the project type to interface. Interface projects do not have a module. Only a schema path is declared. format: 0.3.0 project: name: UriResolver type: interface source: schema: ./src/schema.graphql  "},{"title":"Defining an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#defining-an-interface","content":"Defining an interface is as simple as writing the Wrap Schema. Once the schema is complete, you are ready to deploy the interface. "},{"title":"Implementing an interface​","type":1,"pageTitle":"Define and implement interfaces","url":"/tutorials/advanced/interfaces/define-implement-interfaces#implementing-an-interface","content":"As described in Wrap Schema, an interface can be imported and then implemented with the implements keyword. When a module implements an interface module, it inherits all of its method declarations. The URI Resolver Extensions plugins implement the URI Resolver interface and inherit its methods. ENS Resolver SchemaURI Resolver Schema #import { Module, MaybeUriOrManifest } into UriResolver from &quot;ens/wraps.eth:uri-resolver-ext@1.1.0&quot; #import { Module } into Ethereum from &quot;ens/wraps.eth:ethereum@2.0.0&quot; type Module implements UriResolver_Module {}  "},{"title":"Interface instances","type":0,"sectionRef":"#","url":"/tutorials/advanced/interfaces/interface-instances","content":"","keywords":""},{"title":"Instantiating an interface​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#instantiating-an-interface","content":"After an interface is imported in your Wrap Schema, you can update the generated classes with the Polywrap CLI's codegen command. You will then be able to import the interface module in your wrap. To instantiate an interface module, you must provide a URI that resolves to a wrap that implements the interface. import { MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const instance = new MyInterface_Module(&quot;wrap://...&quot;); ... }  "},{"title":"Getting Interface Implementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#getting-interface-implementations","content":"To instantiate an interface agnostic to the implementation, you can use getImplementations to obtain a list of interface implementations registered in the Polywrap Client. "},{"title":"Declaring getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#declaring-getimplementations","content":"In addition to importing the interface module in the Wrap Schema, you must declare that getImplementations will be used for the interface with the use { getImplementations } keywords. #import { Module } into MyInterface from &quot;wrap://ens/interface.eth&quot; #use { getImplementations } for MyInterface  "},{"title":"Using getImplementations​","type":1,"pageTitle":"Interface instances","url":"/tutorials/advanced/interfaces/interface-instances#using-getimplementations","content":"Now you can import the interface namespace and call its getImplementations method. The getImplementations method returns an array of URI strings that can be used to instantiate the interface module. import { MyInterface, MyInterface_Module, Args_foo } from &quot;./wrap&quot;; export function foo(args: Args_foo): boolean { const impls = MyInterface.getImplementations(); if (impls.length &lt; 1) { throw new Error(&quot;...&quot;) } const instance = new MyInterface_Module(impls[0]); ... }  "},{"title":"Workflow Validation","type":0,"sectionRef":"#","url":"/tutorials/advanced/workflows/workflow-validation","content":"","keywords":""},{"title":"CUE​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/advanced/workflows/workflow-validation#cue","content":"Validation files are written in CUE, an open-source data validation language. It has a simple syntax and is easy to use. CUE provides flexible data validation, including: matching exact valuesmatching typesmatching bounds (e.g. result &gt; 2)matching regular expressions To validate a workflow, you must have CUE installed on your computer. "},{"title":"Writing a validation script​","type":1,"pageTitle":"Workflow Validation","url":"/tutorials/advanced/workflows/workflow-validation#writing-a-validation-script","content":"A validation script should match the structure of the workflow it seeks to validate. It is compared against the output of the workflow. tip To validate a particular job in a workflow, your validation file should be modified to match the output of that particular job. The json-rpc demo uses aworkflow andvalidator to replicate its full integration test suite. We've provided a sample workflow and validation script based on the json-rpc demo here: workflow.yamlvalidator.cue name: json-rpc jobs: case1: steps: - uri: fs/build method: query args: url: &quot;https://archival-rpc.testnet.near.org&quot; request: method: &quot;gas_price&quot; params: &quot;[93019381]&quot; id: &quot;1&quot;  "},{"title":"Running Workflows","type":0,"sectionRef":"#","url":"/tutorials/advanced/workflows/running-workflows","content":"","keywords":""},{"title":"Writing workflows​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/advanced/workflows/running-workflows#writing-workflows","content":"A workflow consists of a tree of Jobs and Steps. A Job is an independent, named unit that can contain an array of Steps named steps and/or a set of sub-Jobs named jobs. Each Job runs asynchronously, and therefore Jobs may run in any order. Although all the sub-jobs are guaranteed to be executed after the parent job completes. Outputs of the parent jobs can be referenced as the input of any of its sub-jobs. By default, test will run all jobs in a workflow. A Job index can be provided to test to execute a specific job. A Step is a wrap invocation. An array of Steps runs synchronously--i.e. in the order defined in the workflow. The result of a Job or Step can be passed as an input argument to a Job or Step that is its child in the tree hierarchy. SchemaExample name: # name of the workflow jobs: # a set of one or more jobs case1: # a job, named by the user steps: # an array of steps - uri: fs/build # uri of invocation method: query # method to invoke args: # method arguments  "},{"title":"Workflow output​","type":1,"pageTitle":"Running Workflows","url":"/tutorials/advanced/workflows/running-workflows#workflow-output","content":"The output of a workflow can be written as a file in the JSON or YAML format with the output-file option of the Polywrap CLI'stest command. Workflow output is printed to the console by default. Console output can be suppressed with the quiet option of the Polywrap CLI's test command. "},{"title":"Configure Polywrap build pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/build-pipeline","content":"","keywords":""},{"title":"Build pipeline​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#build-pipeline","content":"The build process begins by running the build command from the polywrap CLI. The command will first search for the Polywrap Manifest, find the wrap schema and implementation, and move these files into a Docker image. Within the docker image, the wrap schema is parsed and its contents are extracted into an ABI. The ABI is used to generate binding code for the wrap. The wrap is then compiled into a Wasm module. The ABI and the Polywrap Manifest are merged into a Wrap Manifest file called wrap.info. While the default build settings work well for many projects, the toolchain offers a highly configurable build pipeline for those who need more customization. "},{"title":"Build Manifest​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#build-manifest","content":"The Build Manifest polywrap.build.yaml file is the entry point to build pipeline configuration. "},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#declaration","content":"The location of the Build Manifest must be declared in your Polywrap Manifest with a field labeled build. If a custom build manifest is not declared, the default build configuration will be used. build: ./polywrap.build.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#content","content":"SchemaExampleDefault Configuration format: # Polywrap build manifest format version. Values: 0.3.0 strategies: # Custom build image configurations. image: # Docker image strategy configuration name: # Docker image name. dockerfile: # Docker image file name. buildx: # Configuration options for Docker Buildx, set to true for default value. removeImage: # Remove the image. local: # Local build strategy configuration scriptPath: # Custom script path for local build vm: # Docker VM strategy configuration baseImage: # Base image for the Docker VM defaultIncludes: # Files to include in build VM container, by default linked_packages: # Locally linked packages into docker build image. config: # General configurations.  "},{"title":"Customizing the Dockerfile​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#customizing-the-dockerfile","content":"Those who need to fully customize the Docker image build steps can customize the Dockerfile. The Dockerfile is a text file containing instructions for Docker to build images. You can learn more about it at Docker's Dockerfile documentation. To begin, either copy the default Dockerfile from the .polywrap/wasm/build/image folder or create your own. Then, in the polywrap.build.yaml file, add a key called dockerfile with the path of the newly created Dockerfile as the value. That's it! Now, you can customize the Dockerfile to your heart's content. format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile  "},{"title":"Mustache support​","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"/tutorials/build-and-deploy-wraps/build-pipeline#mustache-support","content":"Mustache is a logic-less template system that can be used for HTML, config files, and more. You can learn more about writing Mustache templates here. To enable Mustache capabilities for your Dockerfile, name your custom Dockerfile with a .mustache file extension: dockerfile: ./Dockerfile.mustache  With Mustache, your Dockerfile will be able to recognize variable tags set within the config field of the Build Manifest. For example, in your Build Manifest file, you could have a key such as foo with the value hey like so: format: 0.3.0 docker: name: build-env dockerfile: ./Dockerfile.mustache config: foo: hey strategies: image: name: build-env dockerfile: ./Dockerfile.mustache node_version: 16.13.0 include: - ./package.json buildx: keepBuilder: false  To use this variable in your Mustache-enabled Dockerfile, simply reference the variable with curly braces like so: {{ foo }}  "},{"title":"Configure Polywrap deployment pipeline","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#declaration","content":"The location of the deployment manifest should be declared in your Polywrap Manifest polywrap.yaml with a field labeled deploy. deploy: ./polywrap.deploy.yaml  "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#content","content":"The concents of a Deploy Manifest consists of one or more jobs with their steps, each of which has some common fields and a set of configuration options particular to the step's module. All jobs run in parallel, while steps of each job run in series. The result of a step can be passed as input to a later step using $$step_name. SchemaExample format: # The manifest format version primaryJobName: # Name of the job that runs the primary deployment sequence. jobs: # Each job describes series of events in the pipeline [name]: # Name of the job config: # configuration for all deployment modules, can be overridden within each step steps: # Each step describes an event in the pipeline - name: # The name of the step package: # Deployment module uri: # The wrap URI of source content depends_on: # (Optional) Use prior step's output config: # Configuration for the deployment module  "},{"title":"Deployment Modules​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#deployment-modules","content":"Polywrap currently supports three types of deployment modules: ipfs: pins a folder's contents to IPFS and returns the content hash (CID)ens: points an ENS domain to an IPFS content hashlocal-dev-ens: registers a domain on a local test environment and points the domain to an IPFS content hash "},{"title":"IPFS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#ipfs","content":"The IPFS module pins a folder's contents to IPFS and returns the content hash (CID). It can be used to deploy a wrap by pinning the contents of your project's build folder to the IPFS network. The IPFS module's custom configuration requires an IPFS gateway URI so the CLI knows where to send the files. Example: ipfs configuration config: gatewayUri: 'ipfs.wraps.io' # IPFS gateway URI  "},{"title":"ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#ens","content":"The ENS module accepts an IPFS content hash (CID) as input and points an ENS domain name to it. The ENS module's custom configuration requires three arguments and accepts an optional fourth: domainName: the ENS domain name owned by your Ethereum accountprovider: an Ethereum JSON RPC providerensRegistryAddress: the Ethereum address of the ENS Registry smart contractprivateKey: (optional) your Ethereum account's private key, used when the Ethereum provider cannot produce an account signer Example: ens configuration config: domainName: 'wrap.eth' # ENS domain name provider: 'http://localhost:4545' # an Ethereum JSON RPC provider URI ensRegistryAddress: '0x...' # The ENS Registry contract address privateKey: '' # a private key may be required to sign ethereum transactions  "},{"title":"Local Dev ENS​","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"/tutorials/build-and-deploy-wraps/deploy-pipeline#local-dev-ens","content":"The Local Dev ENS module accepts an IPFS content hash (CID) as input, registers an ENS domain name, and points the domain name to the IPFS CID. The Local Dev ENS module was created with Polywrap's default test environment infrastructure in mind. tip Polywrap's default test environment can be started with the polywrap infra up eth-ens-ipfs CLI command and stopped with the polywrap infra down eth-ens-ipfs CLI command. The module assumes ENS infrastructure is set up on a local Ethereum network with the ENS smart contracts deployed at the following addresses: ENS Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbENS Resolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24ENS Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbENS Reverse Lookup: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C The Local Dev ENS module's custom configuration requires two arguments: domainName: the desired ENS domain name to be registeredports: contains the port of the local Ethereum test network Example: local-dev-ens configuration config: domainName: 'wrap.eth' # ENS domain name ports: ethereum: 4545  "},{"title":"Deploy to IPFS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#polywrap-cli","content":"The polywrap CLI has a deploy command for publishing Wasm wraps to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wraps.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"Fleek​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#fleek","content":"Fleek makes it easy to build websites and apps on the new open web. &gt; Step-By-Step Guide "},{"title":"Pinata​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#pinata","content":"Pinata provides tools and infrastructure for all creators to easily create and manage content on IPFS. &gt; Step-By-Step Guide "},{"title":"Crust Network​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#crust-network","content":"Crust Network provides a Web3.0 decentralized storage network for the Metaverse. &gt; Step-By-Step Guide "},{"title":"Aleph​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#aleph","content":"Aleph allows your blockchain enabled app to securely access trusted off-chain data or computation within a couple lines of code. "},{"title":"Arweave​","type":1,"pageTitle":"Deploy to IPFS","url":"/tutorials/build-and-deploy-wraps/deploy-to-ipfs#arweave","content":"Arweave enables you to store documents and applications forever. "},{"title":"Deploying to CRUST Files","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/crust","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrap using the Crust Files. so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to Crust NetworkStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 👛 Metamask🥐 Crust Network🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  "},{"title":"Step 4. Upload the build folder to Crust Network​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-4-upload-the-build-folder-to-crust-network","content":"Make sure you signin using a wallet Metamask.  Click Public  Click Upload   Upload the build folder then Click Upload   Click Sign and Upload   Your wallet will ask for a signature request Click Sign  The page should look like this:   "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to CRUST Files","url":"/tutorials/build-and-deploy-wraps/deployment/crust#step-5-verifying-the-package-on-ipfs","content":"You will get an IPFS hash! This will lead you to IPFS link: https://gw.crustapps.net/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq?filename=build  🎉 Congratulations 🎉 on deploying using the Crust Files! "},{"title":"Deploying to Fleek","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/fleek","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrap to Fleek so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to FleekStep 5. Verifying the package on IPFS  "},{"title":"What is Fleek?​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#what-is-fleek","content":"Fleek is the easiest way to build, deploy, and host websites &amp; apps on IPFSFleek provides one seamless workflow with everything you need to build fast, modern sites &amp; web apps hosted on IPFS. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js ⚡ Fleek🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Fleek​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-4--upload-the-build-folder-to-fleek","content":"Make sure you signup for a Fleek account. On the left-hand side menu of your Fleek. Account page, click on the &quot;Storage&quot; link.  Then, click &quot;Create Folder&quot; Example: Gm-Polywrap  Click Confirm to create the folder   Click the Folder After that, click &quot;Upload&quot;   Select the contents of your build folder onto Fleek.  Click Confirm.  tip Due to the current Filecoin deal size limitation, files are batched together across Fleek products and uploaded as one Filecoin So it might take 24-48 hours, depending on Fleek usage, for content to appear in ipfs "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Fleek","url":"/tutorials/build-and-deploy-wraps/deployment/fleek#step-5--verifying-the-package-on-ipfs","content":"Click the &quot;Verify on IPFS&quot; button. You will get an IPFS hash! For an example of what you should see, visit this IPFS link. Now that you have the IPFS hash, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrap. You can also register an ENS domain and have it resolved to this IPFS content. 🎉 Congratulations 🎉 on deploying to Fleek! "},{"title":"Publish to ENS","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/publish-to-ens","content":"","keywords":""},{"title":"polywrap CLI​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wraps/publish-to-ens#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wraps to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wraps.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"The ENS App​","type":1,"pageTitle":"Publish to ENS","url":"/tutorials/build-and-deploy-wraps/publish-to-ens#the-ens-app","content":"ENS App is a distributed, open, and extensible naming system based on the Ethereum blockchain. "},{"title":"Deploying to Pinata","type":0,"sectionRef":"#","url":"/tutorials/build-and-deploy-wraps/deployment/pinata","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrap to Pinata so that other apps could integrate it into their apps! "},{"title":"Table of Contents​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrap Step 4. Upload the build folder to PinataStep 5. Verifying the package on IPFS  "},{"title":"What is Pinata?​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#what-is-pinata","content":"Pinata is building the largest pinning service on IPFS! Pinata gives users the ability to upload, manage, and share their content whenever, wherever and, with whomever they want. "},{"title":"What you need to get started:​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🪅 Pinata🐳 Docker🧶Yarn Versions: node &gt;=10.0.0 or yarn &gt;=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git  "},{"title":"Step 2. Git pull metadata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata  "},{"title":"Step 3. Build the wrap​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-3-build-the-wrap","content":"Now, we can build the sample wrap with the following commands: nvm use yarn yarn build  Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Pinata​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-4--upload-the-build-folder-to-pinata","content":"Make sure you signup for a Pinata account. Click &quot;Upload&quot;  Click &quot;Folder&quot;  Click Select for a folder to upload should be the build folder   Give your file or folder a name. Example: Gm-Polywrap  Click &quot;Upload&quot; from the alert message  "},{"title":"Step 5. Verifying the package on IPFS​","type":1,"pageTitle":"Deploying to Pinata","url":"/tutorials/build-and-deploy-wraps/deployment/pinata#step-5--verifying-the-package-on-ipfs","content":"You will get an IPFS hash! Click the name of the folder   This will lead you to IPFS link:https://gateway.pinata.cloud/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq Now that you have the IPFS hash located in the CID column in the pinata manager, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrap. 🎉 Congratulations 🎉 on deploying to Pinata! "},{"title":"Add Metadata","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/add-metadata","content":"Add Metadata Developers can add content, such as a README.md, to their wrap packages. The location of this content must be defined in the project manifest under the resources key. resources: &quot;./resources&quot; By convention, the resources directory should be located at the root of the project. polywrap.yaml # Project Manifest resources/ # Resources directory src/ # Source code ","keywords":""},{"title":"Configure a Polywrap Manifest","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/polywrap-manifest","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Configure a Polywrap Manifest","url":"/tutorials/create-wraps/polywrap-manifest#content","content":"The Polywrap Manifest contains the name of the wrap, programming language used to write it, and the location of the wrap schema that declares the wrap's interface. It optionally includes a path to the wrap's entry file (e.g. src/index.ts, src/lib.rs) and paths to other manifests that can be used to configure the build and deploy process. It can also contain an array of URI Redirects. SchemaExample format: # The manifest format version project: # Project information name: # Name of wrap type: # Type/language of project source: # Source code information schema: # Path to wrap schema module: # (Optional) Path to entry file import_abis: # (Optional) Array of URI redirects used to resolve imports in the schema - uri: # One of the schema's import URI abi: # Path to a local ABI or schema. Supported file formats: [*.graphql, *.info, *.json, *.yaml] extensions: build: # (Optional) Path to Build Manifest file resources: # (Optional) Path to Resources directory  "},{"title":"Adding new Methods","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/adding-new-methods","content":"","keywords":""},{"title":"Custom functionality: IPFS SimpleStorage​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wraps/tutorial/adding-new-methods#custom-functionality-ipfs-simplestorage","content":"It's time to build and customize your own Polywrap wrap! We'll be adding IPFS support to the SimpleStorage API. "},{"title":"Update the schema​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wraps/tutorial/adding-new-methods#update-the-schema","content":"The first step to adding new wrap functionality is defining the method we want our users to invoke. Add the following method &amp; custom data types to your ./src/schema.graphql schema file: ./src/schema.graphql type Module { ... setIpfsData( options: SetIpfsDataOptions! ipfsProvider: String! connection: Ethereum_Connection ): SetIpfsDataResult! } type SetIpfsDataOptions { address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! }  "},{"title":"Implement the setIpfsData method​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wraps/tutorial/adding-new-methods#implement-the-setipfsdata-method","content":"In the ./src/index.ts file, import the new types we've defined: ./src/index.ts import { Ethereum_Module, Args_deployContract, Args_setData, Args_getData, Ipfs_Module, Args_getIpfsData, Args_setIpfsData, SetIpfsDataResult, ModuleBase } from './wrap';  These new types will not exist yet, but don't worry, they'll be generated in the ./src/wrap/* folder once the yarn build command is run. Next, we'll implement the setIpfsData method. Add this function to the bottom of your ./src/index.ts file: ./src/index.ts setIpfsData(args: Args_setIpfsData): SetIpfsDataResult { // 1. Upload the data to IPFS const ipfsAddResult = Ipfs_Module.addFile({ data: { name: &quot;data&quot;, data: String.UTF8.encode(args.options.data) }, ipfsProvider: args.ipfsProvider, timeout: null, addOptions: null, }).unwrap(); const ipfsHash = ipfsAddResult.hash; // 2. Add the data's IPFS hash to SimpleStorage using `setHash(...)` const txReceipt = Ethereum_Module.callContractMethodAndWait({ address: args.options.address, method: 'function setHash(string value)', args: [ipfsHash], connection: args.connection, options: null, }).unwrap(); // 3. Return the result return { ipfsHash, txReceipt: txReceipt.transactionHash, }; }  As you can see, the SimpleStorage.sol smart contract already exposes a setHash() method. In steps 1 and 2, our SimpleStorage wrap is sending a &quot;sub-invocation&quot; to the IPFS and Ethereum plugin wraps we imported in our schema. Wraps can be implemented as a WebAssembly-based wrap, or a plugin wrap in the client's language (ex: JavaScript). For more information on plugins, see the &quot;Plugin an Existing JS SDK&quot; documentation. The Ethereum_Module.callContractMethodAndWait function also accepts an optional argument, connection. This option allows you to select the network which you're transacting with, by specifying a node's endpoint, or a network (name or chain ID) (e.g. &quot;rinkeby&quot;). To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Adding more methods​","type":1,"pageTitle":"Adding new Methods","url":"/tutorials/create-wraps/tutorial/adding-new-methods#adding-more-methods","content":"With our first method implementation complete, it's now time to add more. The steps are the same as above. Update the ./src/schema.graphql file like so: ./src/schema.graphql type Module { ... getIpfsData( address: String! ipfsProvider: String! connection: Ethereum_Connection ): String! ... }  Implement the getIpfsData(...) method like so in ./src/index.ts: ./src/index.ts getIpfsData(args: Args_getIpfsData): string { const hash = Ethereum_Module.callContractView({ address: args.address, method: 'function getHash() view returns (string)', args: null, connection: args.connection }).unwrap(); return String.UTF8.decode( Ipfs_Module.cat({ cid: hash, ipfsProvider: args.ipfsProvider, timeout: null, catOptions: null }).unwrap() ); }  To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Build, deploy and test","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/build-deploy-test","content":"","keywords":""},{"title":"Build​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wraps/tutorial/build-deploy-test#build","content":"Let's start building our project! Simply run: yarn build  In the output window, you'll see that our smart contract was compiled, and our Polywrap wrap was built and output to the ./build/* folder. It contains the following files: build/ |── wrap.wasm # Wrap Logic └── wrap.info # Wrap Manifest  This directory's contents will be uploaded to decentralized storage, and enable any Polywrap Client to download, and execute your wrap's functionality within the application. The wrap.wasm file is the WebAssembly file that was compiled from AssemblyScript. Lastly, the wrap.info file describes the layout of the package, as well as its methods and custom types. "},{"title":"Deploy​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wraps/tutorial/build-deploy-test#deploy","content":"To deploy our Polywrap wrap and associated smart contracts for testing, let's first setup a test environment. Simply run: yarn test:env:up  This will stand-up an Ethereum node, as well as an IPFS node. tip In the future, test environments will be easily configurable to include any nodes your Polywrap wrap requires. Next, let's deploy the SimpleStorage.sol smart contract, and the simplestorage.eth wrap URI by running: yarn deploy  "},{"title":"Test​","type":1,"pageTitle":"Build, deploy and test","url":"/tutorials/create-wraps/tutorial/build-deploy-test#test","content":"With our Polywrap wrap live at simplestorage.eth on our test network, it's now time to test it out! This is where our workflows come in handy. Run yarn test to see this in action. In the output window, you'll see a combination of jobs and returned results from the Polywrap wrap. In this workflow, we send a combination of setData and getData queries which modify the SimpleStorage.sol contract's stored value. Now that we've built the SimpleStorage wrap, let's add custom functionality to it in the next section! "},{"title":"Deploy locally & run tests","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/deploy-locally-and-test","content":"","keywords":""},{"title":"Deploy​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wraps/tutorial/deploy-locally-and-test#deploy","content":"With our workflow complete, let's test the wrap on our local environment! First, let's set up our test environment with the following command in your terminal: yarn test:env:up  tip This command starts up a test environment with a local Ethereum network using Ganache, an ENS smart contract, and a local IPFS node. To close the test environment, simply run: yarn test:env:down  Next, we will deploy our both our SimpleStorage.sol smart contract as well as our wrap with the following command: yarn deploy  tip Behind the scenes, yarn deploy will run the following commands: yarn deploy:api &amp;&amp; yarn deploy:contract Let's break down each of these commands, starting with yarn deploy:api, which itself runs this command: npx polywrap deploy The polywrap CLI's deploy command executes a deployment pipeline defined in a polywrap.deploy.yaml manifest. Our deployment pipeline builds and deploys our wrap to our local test environment. The wrap is assigned to an Ethereum Name Service (ENS) domain registered in the test environment that is set to resolve to our local IPFS node. We next deploy the SimpleStorage smart contract to the Ethereum test network using a script we've written for you: node ./scripts/deploy-contract.js We'll be interacting with this deployed smart contract using our wrap. "},{"title":"Test​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wraps/tutorial/deploy-locally-and-test#test","content":"Now, we'll use the following command to check whether our wrap and smart contract are working properly: yarn test:workflow  This command uses the Polywrap CLI's run command, which will execute a series of Polywrap invocations and return the result to you. "},{"title":"Conclusion​","type":1,"pageTitle":"Deploy locally & run tests","url":"/tutorials/create-wraps/tutorial/deploy-locally-and-test#conclusion","content":"🎉 Congratulations! You've create a custom wrap! Hopefully this article has given you a clear understanding of the Polywrap toolchain's primary features. If at any time in this process you get stuck or have questions, please don't hesitate to reach out on Discord. "},{"title":"The Polywrap project folder","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/project-folder","content":"","keywords":""},{"title":"polywrap.yaml​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#polywrapyaml","content":"The polywrap.yaml is a manifest file describing the layout of a Polywrap wrap. "},{"title":"schema.graphql​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#schemagraphql","content":"Each wrap project has a Wrap Schema. The schema defines the wrap's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrap. "},{"title":"src/index.ts​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#srcindexts","content":"The index.ts file exports the wrap's method's implementations, which contain the wrap's logic. "},{"title":"src/contracts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#srccontracts","content":"The src/contracts directory contains our protocol's Ethereum-based smart contracts. "},{"title":"workflows/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#workflows","content":"Workflows provide a simple way to test your Polywrap without having to write custom testing logic (with JavaScript and Jest, for example). We'll be using this functionality further down in this guide with the polywrap run command, allowing us to easily send test queries against our API. "},{"title":"scripts/*​","type":1,"pageTitle":"The Polywrap project folder","url":"/tutorials/create-wraps/tutorial/project-folder#scripts","content":"We've defined some simple build &amp; deployment scripts for our Solidity smart contracts. These are basic utilities, and can be replaced entirely by a Truffle or Hardhat project. In the next section, we'll build this example wrap and see what gets outputted in the build folder! "},{"title":"Default plugins","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/default-plugins","content":"","keywords":""},{"title":"Import to schema​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#import-to-schema","content":"We'll use one of the default plugins, HTTP, to show how you can import its modules into your wrap's schema (schema.graphql file). We typically import plugins into a schema by importing the interface they implement and letting users of the wrap decide which plugin to use. #import { Module, Request } into Http from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; Below, we explain what each part of this code means. #import Imports specific modules from a deployed or local plugin { Module, Request } These are specific modules that we're unpacking from the one of Polywrap's default plugins, HTTP. into Http This is a namespace, enabling you to use the modules in your schema e.g. Http_Module or Http_Request from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; wrap:// is the Polywrap URI schema.ens is the URI authority. It tells the Polywrap client what kind of URI it needs to resolve. See URIs for more information.wraps.eth:http@1.1.0 is the URI path, which in this case is an ENS address. "},{"title":"Use in Wrap​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#use-in-wrap","content":"Once types have been imported, the functionality of these imported modules can be used in wrap development. Upon yarn build, the imported types and modules will be made available to you in the src/wrap folder. To use them, you simply need to import the specific modules that you'd like to use. If you're building an AssemblyScript-based wrap, the import might look like this: import { Http_Module, Http_Request } from './wrap';  The Http_Module will contain the methods shown here, under the Module type. Once imported, you can access methods like so: Http_Module.get({ ... }) "},{"title":"Commonly used default plugins​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#commonly-used-default-plugins","content":"This section contains brief guides on the default plugins: EthereumProvider, FileSystem, HTTP, Logger, Concurrent. "},{"title":"Ethereum Provider​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#ethereum-provider","content":"The Ethereum Provider plugin can send RPC requests to Ethereum-compatible (EVM) blockchains. Schema: Link Importing the Ethereum Provider plugin into your wrap's schema: #import { Module } into Provider from &quot;plugin/ethereum-provider@2.0.0&quot;  Example: Link pub fn request_sync&lt;T: Serialize + Send + Sync, R: DeserializeOwned&gt;( &amp;self, method: &amp;str, params: T, ) -&gt; Result&lt;R, ProviderError&gt; { let params_v = JSON::to_value(&amp;params).unwrap(); let res = ProviderModule::request(&amp;ArgsRequest { method: method.to_string(), params: Some(params_v), connection: self.connection.clone(), }).map_err(|err| ClientError::Error(err))?; let res = JSON::from_value(res).map_err(|err| ClientError::SerdeJson { err, text: &quot;from str failed&quot;.to_string(), })?; Ok(res) }  "},{"title":"FileSystem​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#filesystem","content":"The FileSystem plugin can interact with the host filesystem. Schema: Link Importing the FileSystem plugin into your wrap's schema: #import { Module } into FileSystem from &quot;ens/wraps.eth:file-system@1.0.0&quot;  Example: Link pub fn get_file(args: ArgsGetFile, _env: Option&lt;Env&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; { let res = FileSystemModule::read_file(&amp;ArgsReadFile { path: args.path }); res.ok() }  "},{"title":"HTTP​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#http","content":"The HTTP plugin can send HTTP requests. Schema: Link Example Implementation​ In this example, we will implement a simple Ping method which pings CoinGecko to see their server status using an HTTP Get request from your wrap. In our ./src/schema.graphql file, we’ll write the schema for our wrap. At the top of this file, import the HTTP module into your wrap: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot;  Then, define the types and fields on the Ping method. First, add a new Ping type at the bottom of the schema. type Ping { gecko_says: String! }  Then, add an argument-less method called ping that returns a non-nullable Ping to the Module type. Our completed schema looks like this: #import { Module, Request, Response } into HTTP from &quot;wrap://ens/wraps.eth:http@1.1.0&quot; type Module { ping: Ping! } type Ping { gecko_says: String! }  Now, we'll implement the ping method in ./src/index.ts At the top of the file, we'll import the HTTP/Ping methods and types. import { HTTP_Module, HTTP_ResponseType, Ping, } from './wrap';  Then, implement Ping function: export function ping(): Ping { // Writing the HTTP request / response const response = HTTP_Module.get({ url: 'https://api.coingecko.com/api/v3/ping', request: { headers: [], urlParams: [], body: '', responseType: HTTP_ResponseType.TEXT, }, }).unwrap(); // Error handling for the response if (!response || response.status !== 200 || !response.body) { const errorMsg = response &amp;&amp; response.statusText ? (response.statusText as string) : 'An error occurred while fetching data from Coingecko API'; throw new Error(errorMsg); } const json = &lt;JSON.Obj&gt;JSON.parse(response.body); // Response from Coingecko with field `geckoSays` const geckoSays = json.getString('gecko_says'); if (geckoSays) { return { gecko_says: geckoSays.valueOf(), }; } throw new Error('Invalid response body!'); }  "},{"title":"Logger​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#logger","content":"The Logger plugin enables logging in a wrap, which can be useful for debugging. In our ./src/schema.graphql file, import the Logger module into your wrap: #import { Module } into Logger from &quot;ens/wraps.eth:logger@1.0.0&quot;  Then in your implementation file ./src/index.ts, import the Logger function: import { Logger_Module, Logger_Logger_LogLevel, } from './wrap';  And use it like so:  Logger_Module.log({ level: Logger_Logger_LogLevel.INFO, message: `Insert useful log message here`, });  When you run your test e.g. yarn test:e2e, you will see the logged message in the console. "},{"title":"Concurrent​","type":1,"pageTitle":"Default plugins","url":"/tutorials/create-wraps/default-plugins#concurrent","content":"The Concurrent plugin enables concurrent execution of wrap sub-invocations. The meaning of &quot;concurrent&quot; depends on the plugin implementation, which varies by language. Schema: Link Importing the Concurrent plugin into your wrap's schema: #import { Module } into Concurrent from &quot;ens/wraps.eth:concurrent@1.0.0&quot;  Example: Link pub fn cat_task(ipfs_provider: &amp;str, cid: &amp;str, timeout: u32, client_uri: &amp;str) -&gt; ConcurrentTask { ConcurrentTask { uri: client_uri.to_string(), method: String::from(&quot;cat&quot;), args: serialize_cat_args(&amp;ClientArgsCat { cid: cid.to_string(), ipfs_provider: ipfs_provider.to_string(), timeout: Some(timeout), cat_options: None, }).unwrap() } } pub fn cat_task_result(task_result: &amp;ConcurrentTaskResult) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { if matches!(task_result.status, ConcurrentTaskStatus::COMPLETED) { return match &amp;task_result.result { Some(result) =&gt; Ok(deserialize_cat_result(result.as_ref()).unwrap()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } return match &amp;task_result.error { Some(error) =&gt; Err(error.to_string()), None =&gt; Err(String::from(&quot;Received empty result from concurrent task&quot;)) }; } pub fn exec_parallel( providers: &amp;Vec&lt;&amp;str&gt;, cid: &amp;str, timeout: u32, ) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; { // get ipfs http client uri let client_uri: String = get_ipfs_http_client_uri()?; // get Concurrent implementation let impls = Concurrent::get_implementations(); if impls.len() &lt; 1 { println!(&quot;Parallel execution is not available. Executing sequentially instead. \\ Parallel execution requires an implementation of the Concurrent interface. \\ You can declare an interface implementation in your Polywrap Client configuration.&quot;); return exec_sequential(providers, cid, timeout); } let concurrent_module = ConcurrentModule::new(impls[0].clone()); // schedule tasks let mut tasks: Vec&lt;ConcurrentTask&gt; = Vec::new(); for &amp;provider in providers { tasks.push(cat_task(provider, cid, timeout, &amp;client_uri)); } let task_ids: Vec&lt;i32&gt; = concurrent_module.schedule(&amp;ArgsSchedule { tasks })?; // request task results let return_when = ConcurrentReturnWhen::ANY_COMPLETED; let result_args = &amp;ArgsResult { task_ids: task_ids.clone(), return_when }; let results: Vec&lt;ConcurrentTaskResult&gt; = concurrent_module.result(result_args)?; // return completed result value or panic let mut errors: Vec&lt;String&gt; = Vec::new(); for i in 0..results.len() { let result = cat_task_result(&amp;results[i]); if result.is_ok() { return result; } let error = build_exec_error(providers[i], timeout, result.unwrap_err().as_str()); errors.push(error); } return Err(errors.join(&quot;\\n&quot;)); }  "},{"title":"Project setup","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/project-setup","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wraps/tutorial/project-setup#prerequisites","content":"You'll need the following installed before building your wrap: nvmyarndockerdocker-compose You'll be using AssemblyScript to implement your wrap's logic. AssemblyScript compiles to WebAssembly. tip For now, AssemblyScript and Rust are the only languages with which you can implement your wrap. In the future, we will support additional languages that compile to WebAssembly, such as Go. If you have experience programming in TypeScript, you'll feel at home with AssemblyScript since the language's syntax is very similar. 👋 This guide is meant for those who want to build and deploy their own wraps. If you're interested in integrating deployed wraps into your own app, see our Integrate into a JS App guide. "},{"title":"Create your project​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wraps/tutorial/project-setup#create-your-project","content":"Let's begin by downloading the Polywrap demos repository, which contains the SimpleStorage wrap we will be using in this guide: git clone https://github.com/polywrap/demos.git  From the root of this new directory, navigate to simple-storage/wrap/assemblyscript. tip The best way to start a new wrap project is with a project template generated using our CLI. npx polywrap create wasm assemblyscript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choice. For example my-wrap. After running this command, you'll see a new folder appear with the custom name you've chosen. The folder will contain everything you need to get started! "},{"title":"Installation​","type":1,"pageTitle":"Project setup","url":"/tutorials/create-wraps/tutorial/project-setup#installation","content":"Let's ensure all of your project's dependencies are installed. From inside the project's directory, simply run: nvm install &amp;&amp; nvm useyarn The Polywrap CLI is now installed locally to your project's directory. Going forward we'll use this local installation by running npx polywrap. We recommend not installing the polywrap package globally to avoid future version conflicts, and maximize reproducibility for the other developers you're working with. Let's head over to the next section to see what's in this new directory! "},{"title":"Writing tests with workflows","type":0,"sectionRef":"#","url":"/tutorials/create-wraps/tutorial/writing-tests-with-workflows","content":"","keywords":""},{"title":"Testing​","type":1,"pageTitle":"Writing tests with workflows","url":"/tutorials/create-wraps/tutorial/writing-tests-with-workflows#testing","content":"In order to test this new functionality, we'll update the existing ./workflows/e2e.yaml workflow file to include the new methods we've added (setIpfsData, and getIpfsData). Add the following case to the e2e.yaml workflow in the ./workflows folder. ./workflows/e2e.yaml case2: steps: - uri: fs/build method: setIpfsData args: options: address: &quot;$cases.0.data&quot; data: &quot;Hello from IPFS!&quot; ipfsProvider: &quot;http://localhost:5001&quot; - uri: fs/build method: getIpfsData args: address: &quot;$cases.0.data&quot; ipfsProvider: &quot;http://localhost:5001&quot;  Once our workflow has been defined, we may want to be able to validate our actual results against our expectations. Workflow validation uses CUE, a flexible and expressive data validation language. CUE must be installed to complete this step. If you don't want to install anything right now, don't worry! Our results will be easy to verify with manually. To continue with automated testing, let's add our expected output to a new file in the workflows folder. We will call the file validator.cue. ./workflows/validator.cue package e2e cases: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{40}$&quot;, error?: _|_, // Never fails } case1: { $0: { data: =~&quot;^0x[A-Fa-f0-9]{64}$&quot;, error?: _|_, } $1: { data: uint, error?: _|_ } } case2: { $0: { data: { txReceipt: string, ipfsHash: &quot;QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis&quot; }, error?: _|_, } $1: { data: &quot;Hello from IPFS!&quot;, error?: _|_, } } }  With our workflow complete, we'll deploy and test our wrap locally in the next section! "},{"title":"Configure Polywrap infrastructure pipeline","type":0,"sectionRef":"#","url":"/tutorials/test-wraps/infra-pipeline","content":"","keywords":""},{"title":"Declaration​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#declaration","content":"Unlike some manifests, the Infra Manifest does not need to be declared in your Polywrap manifest. "},{"title":"Content​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#content","content":"The Infra Manifest consists of environmental variable declarations and one or more infrastructure modules. Each module points to a local, remote, or default docker-compose file. SchemaExample format: # The manifest format version env: # Declare environmental variables here modules: myRemote: # A remote package with a docker-compose file package: # Package name version: # Package version registry: # Package registry name dockerComposePath: # (Optional) Path to docker-compose file in the package directory myLocal: # A local package with a docker-compose file path: # Path to the package eth-ens-ipfs: default # A module available by default  "},{"title":"Infrastructure Modules​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#infrastructure-modules","content":"An Infra Manifest can declare any number of infrastructure modules. Polywrap currently supports three types of infrastructure modules: A local module exists on your local filesystem.A remote module is a package hosted by a package registry.The default module is included with the CLI. "},{"title":"Local​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#local","content":"A local infrastructure module is a path from the Infra Manifest to a local folder with a docker-compose file. Example: local module configuration format: 0.1.0 modules: myLocal: path: ../local-packages/myLocal  "},{"title":"Remote​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#remote","content":"A remote infrastructure module is a package hosted at a package registry. The package must contain a docker-compose file. The path to the docker-compose file must be declared in the Infra Manifest if the file is not located in the package root. Remote packages can be shared. Users can add remote packages to their manifest to replicate the infrastructure modules defined by other users or projects. Example: remote module configuration format: 0.1.0 modules: myIpfsNode: package: &quot;@namestys/ipfs-node&quot; version: &quot;1.0.2&quot; registry: npm dockerComposePath: ./config/docker-compose.yaml  "},{"title":"Default​","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"/tutorials/test-wraps/infra-pipeline#default","content":"A default infrastructure module is included with the polywrap CLI. It is declared in the Infra Manifest as a module named eth-ens-ipfs and the value default. If an Infra Manifest is not found, the Polywrap CLI infra command can still use this module. To use the default module without an Infra Manifest, pass eth-ens-ipfs as an argument to the infra command's modules option: npx polywrap infra up --modules=eth-ens-ipfs  The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wraps and deploy them to an ENS registry on your locally hosted testnet. The Ethereum address of the ENS registry is 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab. Example: local module configuration format: 0.1.0 modules: eth-ens-ipfs: default  "},{"title":"Configuring the Polywrap Client","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/configure-client","content":"","keywords":""},{"title":"The ClientConfigBuilder​","type":1,"pageTitle":"Configuring the Polywrap Client","url":"/tutorials/use-wraps/configure-client#the-clientconfigbuilder","content":"You can use the ClientConfigBuilder class to easily build the ClientConfig object: const config = new ClientConfigBuilder() .addDefaults() // add or remove configs here using ClientConfigBuilder methods... .build(); const client = new PolywrapClient(config);  "},{"title":"Test Wraps In TypeScript","type":0,"sectionRef":"#","url":"/tutorials/test-wraps/in-typescript","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#introduction","content":"In this tutorial we'll learn how to develop custom end to end (e2e) tests for your wrap in TypeScript. These tests will be make calls into your wrap using the JavaScript / TypeScript Polywrap Client. "},{"title":"Prerequisites​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#prerequisites","content":"You'll need the following NPM packages installed before testing your wrap: @polywrap/client-js@polywrap/cli-jsjest "},{"title":"Project Setup​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#project-setup","content":"The tests we'll be developing will live next to your wrap's source-code. Polywrap has published pre-configured projects for both wasm/rust and wasm/assemblyscript wraps. You can use &amp; reference these when configuring your own project. In this tutorial we'll assume a fresh wasm/assemblyscript project has been created via the polywrap create wasm assemblyscript ... CLI command. "},{"title":"Build The Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#build-the-wrap","content":"Before any tests can be run, we must ensure the wrap has been freshly built. This will ensure we test against the latest version of the wrap's source-code. When using jest, we leverage the beforeAll function to do this. Additionally, the @polywrap/cli-js package makes it easy to invoke the polywrap build CLI command to build your wrap. import { Commands } from &quot;@polywrap/cli-js&quot;; describe(&quot;e2e Wrap Tests&quot;, () =&gt; { beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); });  This should result in a wrap package being emitted to the build/ directory. "},{"title":"Configure a Polywrap Client​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#configure-a-polywrap-client","content":"Before we create a new Polywrap client, we must create a configuration for it to use. This can be done through use of the ClientConfigBuilder. In the case of this example we'll be using the default configuration bundle. If your wrap requires any custom integration dependencies like plugins or environment variables, then now would be the time to configure this. import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; describe(&quot;e2e Wrap Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); ... });  "},{"title":"Load The Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#load-the-wrap","content":"We'll be loading our wrap directly from the build/ directory in the file-system. This can be accomplished in 1 of 2 ways: Package Embedding import { WasmPackage } from &quot;@polywrap/wasm-js&quot;; import fs from &quot;fs&quot;; ... const buildDir = `${__dirname}/../../build`; const embedPackage = WasmPackage.from( fs.readFileSync(`${buildDir}/wrap.info`), fs.readFileSync(`${buildDir}/wrap.wasm`) ); const uri = &quot;wrap://embed/test-wrapper&quot;; const config = new ClientConfigBuilder() .addPackage(uri, embedPackage) .build();  File-System URIs const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`;  In both cases, you end up with a uri which can be used to invoke your wrap through the client. "},{"title":"Test Your Wrap​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#test-your-wrap","content":"Now that we have a client invoke wraps, and a uri to reference our wrap, we're ready to write some tests.  test(&quot;Test Case&quot;, async () =&gt; { const result = await client.invoke({ uri, method: &quot;sampleMethod&quot;, args: { arg: &quot;foo bar baz&quot; } }); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value).toMatchObject({ result: &quot;foo bar baz&quot; }); });  "},{"title":"Type Safety​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#type-safety","content":"In the example above, it shows the use of the client.invoke(...) In the example above, it shows the use of the client.invoke(...)` method, which is generic. This means that if your wrap's schema changes, and (for example) the method being called no longer exists or its types change, the test will fail. In order to help ensure this can be caught sooner, and easier to debug, we suggest generating TypeScript types for your wrap's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  And an import schema like so: #import * into Wrapper from &quot;wrap://file/build&quot;  We suggest putting these files in a folder next to your tests, for example src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way.  test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  debug, we suggest generating TypeScript types for your wrap's schema. All you need is an app/typescript polywrap.yaml manifest like so: format: 0.3.0 project: name: sample-typescript-type-generation type: app/typescript source: schema: ./schema.graphql  We suggesting putting this polywrap.yaml manifest in a folder next to your tests like src/__tests__/types/. Once here, you can generate types by simply running the following command: polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap  With this done, you can now rewrite the test above in a type-safe way. import { Wrapper_Module } from &quot;./types/wrap&quot;; ... test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); });  "},{"title":"Conclusion​","type":1,"pageTitle":"Test Wraps In TypeScript","url":"/tutorials/test-wraps/in-typescript#conclusion","content":"And that's a wrap! import { Commands } from &quot;@polywrap/cli-js&quot;; import { ClientConfigBuilder, PolywrapClient } from &quot;@polywrap/client-js&quot;; import { Wrapper_Module } from &quot;./types/wrap&quot;; jest.setTimeout(50000); describe(&quot;e2e Wrapper Tests&quot;, () =&gt; { const config = new ClientConfigBuilder() .addDefaults() .build(); const client = new PolywrapClient(config); const buildDir = `${__dirname}/../../build`; const uri = `wrap://file/${buildDir}`; beforeAll(async () =&gt; { const result = await Commands.build({}, { cwd: `${__dirname}/../../` }); if (result.exitCode !== 0) { console.log(result.stdout); console.error(result.stderr); fail(&quot;Failed to build wrapper.&quot;); } }); test(&quot;Test Case&quot;, async () =&gt; { const result = await Wrapper_Module.sampleMethod({ arg: &quot;foo bar baz&quot; }, client, uri); expect(result.ok).toBe(true); if (!result.ok) fail(result.error); expect(result.value.result).toBe(&quot;foo bar baz&quot;); }); });  If you'd like to see an in-production wrap w/ tests in TypeScript, checkout the ethereum wrap's tests here. "},{"title":"Creating the Polywrap client instance","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/create-client-instance","content":"Creating the Polywrap client instance Once the Polywrap JS client has been installed, the next step is to create a PolywrapClient instance: import { PolywrapClient } from &quot;@polywrap/client-js&quot;; const client = new PolywrapClient(); At this point, you can already invoke wraps. In the simple example below, we send one to the &quot;hello world&quot; wrap. client.invoke({ uri: &quot;ens/wraps.eth:logging@1.0.0&quot;, method: &quot;info&quot;, args: { message: &quot;Hello World!&quot; } }); ","keywords":""},{"title":"Installing the Polywrap JS client","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/install-client","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#introduction","content":"If you're a JavaScript developer building Browser, Node.js, or React based apps, this guide is for you. tip In the future, JavaScript will be one of many supported languages. Our goal is to enable the use of Polywrap in every major programming language. By the end of this document, you'll gain the following skills: How to instantiate the Polywrap client in your JavaScript AppInvoke any wrap using the Polywrap clientConfigure the Polywrap clientBuild React apps with ease If you get stuck during this guide, send us a message on our Discord! "},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#prerequisites","content":"As prerequisites for this guide, we recommend having familiarity with TypeScript. React will also be used in the latter sections. "},{"title":"Installation​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#installation","content":"To use wraps in your app, all you need is the Polywrap Client! npm install --save @polywrap/client-js  The Polywrap JavaScript Client works in both Node.js, and browser applications. "},{"title":"Examples​","type":1,"pageTitle":"Installing the Polywrap JS client","url":"/tutorials/use-wraps/install-client#examples","content":"Some example projects that integrate the JS client can be found here. The next section assumes that you're integrating Polywrap into an existing app project. If you want a quick start with our template project, simply run: npx polywrap create app typescript &lt;project-name&gt; Where &lt;project-name&gt; is replaced with a custom name of your choosing. For example my-app. This command will create a new project folder with a &quot;Hello World&quot; app that lets you interact with two simple Wasm wraps at wrap://ens/wraps.eth:logging@1.0.0 and wrap://ens/wraps.eth:ethereum@1.0.0. "},{"title":"Generate types for your app","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/types-for-app","content":"","keywords":""},{"title":"App Manifest content​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/use-wraps/types-for-app#app-manifest-content","content":"The App Manifest contains the name of the project, the programming language used to write it, and the location of the wrap schema that states which code to generate. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of project language: # App programming language schema: # Path to wrap schema import_abis: # (Optional) Array of URI redirects for schema imports - uri: # Source URI to be redirected abi: # Path to a local ABI (or schema). Supported file formats: [*.graphql, *.info, *.json, *.yaml]  "},{"title":"Wrap Schema for apps​","type":1,"pageTitle":"Generate types for your app","url":"/tutorials/use-wraps/types-for-app#wrap-schema-for-apps","content":"To automatically generate types for an application or test suite, we must tell the Polywrap CLI which types to generate. This is done using a Wrap Schema. In your wrap schema, you can add an import statement for each wrap you're using in your project. You can use the * syntax to import a wrap's module and all of its types, or you can list the types you'd like to use. Wrap schema for the Hello World app #import * into Logging from &quot;ens/wraps.eth:logging@1.0.0&quot;  Learn more about schema imports at Wrap Schema. "},{"title":"React integration","type":0,"sectionRef":"#","url":"/tutorials/use-wraps/react-integration","content":"","keywords":""},{"title":"PolywrapProvider​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () =&gt; { return ( &lt;PolywrapProvider&gt; &lt;HelloWorld /&gt; &lt;/PolywrapProvider&gt; ); };  PolywrapProvider Props​ The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: &lt;PolywrapProvider redirects={ [] }/&gt;  Multiple PolywrapProviders​ If you need to use multiple providers, you can do so using the createPolywrapProvider(&quot;...&quot;) method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) =&gt; { return ( &lt;CustomPolywrapProvider&gt; {children} &lt;/CustomPolywrapProvider&gt; ); };  "},{"title":"usePolywrapClient​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient();  "},{"title":"usePolywrapInvoke​","type":1,"pageTitle":"React integration","url":"/tutorials/use-wraps/react-integration#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wraps! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, error, loading } = usePolywrapInvoke({ provider: &quot;custom&quot;, uri: 'ens/wraps.eth:logging@1.0.0', method: &quot;info&quot;, args: { message: &quot;Hello World!&quot;, }, });  "},{"title":"AI","type":0,"sectionRef":"#","url":"/use-cases/ai","content":"AI Coming soon... ✨","keywords":""},{"title":"Use case: Web3","type":0,"sectionRef":"#","url":"/use-cases/web3","content":"","keywords":""},{"title":"Web3's Problem​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#web3s-problem","content":"We see traditional SDKs as a fundamental bottleneck for web3's adoption, let us explain... In web3, any application should be able to interact with smart contract protocols such as Uniswap or Aave. To do this, application developers utilize software development kits (SDKs) to simplify this process. However, traditional SDKs come with a number of issues: "},{"title":"Difficult to compose.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#difficult-to-compose","content":"A lack of standards makes traditional SDKs difficult to mix-and-match.  Today, protocol SDKs like Uniswap, Safe and Ethers aren't standardized. This means that a lot of complex, custom code needs to be written to compose them in dApps. "},{"title":"Not portable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#not-portable","content":"SDKs are language-specific, but the modern landscape of applications is more varied than ever: web, mobile, server, games, etc.  "},{"title":"Not upgradable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#not-upgradable","content":"When traditional SDKs undergo patch updates, the entire application needs to be rebuilt and redeployed, which doesn't scale to large web3 ecosystems.  "},{"title":"Polywrap's Solution ✨​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#polywraps-solution-","content":"Wraps offer a much better strategy for code reuse and composability than traditional SDKs. Wraps are: "},{"title":"Composable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#composable","content":"Wraps are developed in a standardized way. Standardization means Wraps can be easily composed, resulting in even more sophisticated Wraps.  "},{"title":"Portable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#portable","content":"Wraps can run on any platform that has the Polywrap client installed. Now, web3 dev teams can build their SDKs as Wraps, and application developers can integrate these Wraps across all platforms.  "},{"title":"Updatable.​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#updatable","content":"Wraps do not have to be bundled into applications. Instead they can be safely fetched and run at runtime. This allows applications to stay in-sync with web3 protocol upgrades. "},{"title":"Web3 Hosting​","type":1,"pageTitle":"Use case: Web3","url":"/use-cases/web3#web3-hosting","content":"Wraps can be easily deployed to the InterPlanetary File System (IPFS), and published to a decentralized domain like the Ethereum Name Service (ENS). "}]