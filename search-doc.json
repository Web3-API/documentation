[{"title":"FAQ","type":0,"sectionRef":"#","url":"concepts/faq","content":"","keywords":""},{"title":"Technology","type":1,"pageTitle":"FAQ","url":"concepts/faq#technology","content":""},{"title":"What are URIs?","type":1,"pageTitle":"FAQ","url":"concepts/faq#what-are-uris","content":"A URI is a Uniform Resource Identifier. URIs are used to identify resources on the internet. In the context of the Polywrap, URIs are used to identify wrappers. "},{"title":"How does Polywrap use GraphQL?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-does-polywrap-use-graphql","content":"Every wrapper has a schema that defines all methods and types used by the wrapper. GraphQL is used as the Schema Definition Language (SDL). "},{"title":"How does Polywrap use Docker?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-does-polywrap-use-docker","content":"Docker is used by the Polywrap CLI in order to provide reproducible build and test environments. "},{"title":"What is Wasm?","type":1,"pageTitle":"FAQ","url":"concepts/faq#what-is-wasm","content":"As described by W3C via https://webassembly.org/: WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. "},{"title":"Why is a Wasm wrapper more secure than a JavaScript SDK?","type":1,"pageTitle":"FAQ","url":"concepts/faq#why-is-a-wasm-wrapper-more-secure-than-a-javascript-sdk","content":"A Wasm module is executed inside a sandboxed environment with a virtual memory space. It is not possible for a nefarious actor to write Wasm code capable of accessing memory address space intended for the operating system or other applications. Likewise, Wasm does not allow system calls. Wasm modules cannot access the file system, make network requests, or interact with the browser. "},{"title":"How does a Wasm wrapper interact with a blockchain wallet?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-does-a-wasm-wrapper-interact-with-a-blockchain-wallet","content":"Polywrap created plugin wrappers to securely complete tasks that are not otherwise possible in Wasm. The Ethereum Plugin package can be configured to make Ethereum transactions with any standard Ethereum provider. "},{"title":"Building Wrappers","type":1,"pageTitle":"FAQ","url":"concepts/faq#building-wrappers","content":""},{"title":"What are Base Schema Types?","type":1,"pageTitle":"FAQ","url":"concepts/faq#what-are-base-schema-types","content":"Base Schema Types are default types that can be used by wrapper developers in their wrapper schemas. Some are primitive types, while others are objects with implementations that may differ between wrapper development languages. Each language has type mappings that correspond to the Base Schema Types. These are used when invoking wrappers, and correctly serialize to the corresponding Base Schema Types. "},{"title":"What schema types are supported by Polywrap?","type":1,"pageTitle":"FAQ","url":"concepts/faq#what-schema-types-are-supported-by-polywrap","content":"Polywrap supports several default types, as well as user-defined custom types. You can find a list of supported default types in Wrapper Schema, as well as guidance on creating your own custom types. "},{"title":"How can I create Polywrap \"schema types\"?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-create-polywrap-schema-types","content":"Polywrap schemas use a subset of GraphQL syntax. "},{"title":"Testing Wrappers","type":1,"pageTitle":"FAQ","url":"concepts/faq#testing-wrappers","content":""},{"title":"How can I run a polywrap test environment locally?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-run-a-polywrap-test-environment-locally","content":"The Polywrap CLI can be used to start and stop a local test environment you can use to deploy and invoke wrappers. "},{"title":"Deploying Wrappers","type":1,"pageTitle":"FAQ","url":"concepts/faq#deploying-wrappers","content":""},{"title":"How can I pin my Wasm wrapper to IPFS?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-pin-my-wasm-wrapper-to-ipfs","content":"Several third-party services exist to help users pin files to IPFS. They are described in our section on Deploying to IPFS. You can learn more about IFPS and \"pinning\" at https://docs.ipfs.io/how-to/pin-files "},{"title":"How can I deploy my Wasm wrapper?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-deploy-my-wasm-wrapper","content":"Wasm wrappers can be deployed using Polywrap's deployment pipeline or pinned to IPFS using the tools described inDeploying to IPFS. "},{"title":"App Integration","type":1,"pageTitle":"FAQ","url":"concepts/faq#app-integration","content":""},{"title":"Do I need to know AssemblyScript to use a wrapper?","type":1,"pageTitle":"FAQ","url":"concepts/faq#do-i-need-to-know-assemblyscript-to-use-a-wrapper","content":"No, AssemblyScript is one of the languages used to build wrappers. Once this wrapper is built and published, you can invoke it using a Polywrap Client. "},{"title":"Polywrap DAO","type":1,"pageTitle":"FAQ","url":"concepts/faq#polywrap-dao","content":""},{"title":"Does polywrap have any grant programs or sponsorships available for building on the ecosystem?","type":1,"pageTitle":"FAQ","url":"concepts/faq#does-polywrap-have-any-grant-programs-or-sponsorships-available-for-building-on-the-ecosystem","content":"We do not have a formal grant program, but we have given grants in extraordinary cases in the past.Join our discord and tell us about your idea! "},{"title":"How can I join the Polywrap DAO?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-join-the-polywrap-dao","content":"You can learn more about joining and contributing to the Polywrap DAO in our handbook. "},{"title":"What are Polywrap mini-hacks?","type":1,"pageTitle":"FAQ","url":"concepts/faq#what-are-polywrap-mini-hacks","content":"The community hackathons are a way for you to earn rewards and learn more about the project. Our hackathons aren't limited to just developers — in the past, we've had technical submissions like dApps and wrappers as well as non-technical ones like articles, memes, and more. In short, the only requirement is that your hackathon provides some kind of benefit to the Polywrap ecosystem. Our hackathons are ongoing. To get started, simply join our Discord and visit the #mini-hacks channel to let us know what you're working on. Our team is happy to give feedback and support on your project when we can. "},{"title":"Are there any job opportunities available in polywrap?","type":1,"pageTitle":"FAQ","url":"concepts/faq#are-there-any-job-opportunities-available-in-polywrap","content":"Polywrap is always looking for talent. Check out our available positions. "},{"title":"I have a proposal for potential partnership / opportunity, who should I contact?","type":1,"pageTitle":"FAQ","url":"concepts/faq#i-have-a-proposal-for-potential-partnership--opportunity-who-should-i-contact","content":"Please include all details on an email to hello@polywrap.io. Be as descriptive as possible, add links and validation for the DAO to consider your proposal. "},{"title":"How can I join the Polywrap DAO?","type":1,"pageTitle":"FAQ","url":"concepts/faq#how-can-i-join-the-polywrap-dao-1","content":"The Polywrap DAO is open to anyone who wishes to join. There is no membership fee. "},{"title":"Should you build a Wasm or Plugin Wrapper?","type":0,"sectionRef":"#","url":"concepts/plugin-vs-wasm-wrapper","content":"","keywords":""},{"title":"Benefits of building Wasm wrappers","type":1,"pageTitle":"Should you build a Wasm or Plugin Wrapper?","url":"concepts/plugin-vs-wasm-wrapper#benefits-of-building-wasm-wrappers","content":"Encapsulating as much business logic as possible in a Wasm wrapper is the ideal state. By doing this, you get to take advantage of all of the benefits of Wasm including cross-language support, security, performance, composability, and smaller package size. "},{"title":"Benefits of building plugin wrappers","type":1,"pageTitle":"Should you build a Wasm or Plugin Wrapper?","url":"concepts/plugin-vs-wasm-wrapper#benefits-of-building-plugin-wrappers","content":"Despite the benefits of Wasm wrappers, however, plugin wrappers are sometimes necessary due to the limitations of Wasm. For example, Wasm does not support HTTP queries, filesystem access, or browser interaction. Wasm wrappers will typically depend on one or more plugin wrappers, and sometimes a custom plugin wrapper may be useful to support a Wasm wrapper. "},{"title":"A hybrid approach","type":1,"pageTitle":"Should you build a Wasm or Plugin Wrapper?","url":"concepts/plugin-vs-wasm-wrapper#a-hybrid-approach","content":"If you are starting a new project, you can take a \"Wasm wrapper-first\" approach by following our guide to \"Creating a Wasm wrapper\" If you have an existing SDK, you can consider an approach of first \"wrapping\" the SDK as a plugin wrapper and then gradually moving each interface that your SDK provides to a Wasm wrapper. The example of migrating the Uniswap v3 SDK to a wrapper demonstrates how to think about this migration process while preserving feature parity and code quality. If you have any questions about the best approach to take for your project, you are welcome to ask a question in the Polywrap Discord. "},{"title":"Project Manifests","type":0,"sectionRef":"#","url":"concepts/project-manifests","content":"","keywords":""},{"title":"The YAML format","type":1,"pageTitle":"Project Manifests","url":"concepts/project-manifests#the-yaml-format","content":"Polywrap project manifests are formatted in YAML. The YAML format was chosen because of its easy of human readability. If you're not familiar with the YAML syntax, you can learn the basics at Learn YAML in Y Minutes. "},{"title":"Manifest Types","type":1,"pageTitle":"Project Manifests","url":"concepts/project-manifests#manifest-types","content":"Polywrap Manifest - Orchestrates a Wasm wrapper projectPlugin Manifest - Orchestrates a Plugin wrapper projectInfra Manifest - Manage local test environment infrastructureBuild Manifest - Customize the build processMeta Manifest - Add metadata to your Wasm wrapperDeploy Manifest - Automate a deployment pipeline "},{"title":"Polywrap vs. JavaScript SDKs","type":0,"sectionRef":"#","url":"concepts/polywrap-vs-javascript-sdks","content":"tip Polywrap is a substantial improvement over JavaScript SDKs and produces a seamless and intuitive Web3 protocol integration experience for blockchain developers. The table below highlights the contrasts between JavaScript SDKs and Polywrap Wasm wrappers as it concerns compatibility & maintainability, ease of use, bundle size, and upgrades & patches. Category\tPolywrap wrapper\tJavaScript SDKCompatibility & Maintainability\tWasm wrappers run in any environment, meaning you just need to program your SDK once -- saving you time.\tJS-based SDKs require JS-based apps in order to run, thereby disincentivizing developers from building apps in other languages. Supporting new app \"types\" requires writing and maintaining a new SDK. Easy of Use\tDevelopers interact with Polywrap through simple syntax, making them as easy to use as Web2 APIs like Twitter's.\tDevelopers must learn how to instantiate classes, and call into the various methods and functions the JS SDK provides. Security\tWasm wrappers run within individual sandboxes, ensuring your integrations are isolated from your application. Users are safer with Polywrap.\tJavaScript SDKs, and any other type of traditional SDK, execute unbounded within your application's memory. This means that the SDK, and all of its dependencies, have direct access to the user's data within your applications. This has lead to many hacks in the past, leaving users vulnerable and with a large loss of funds. Bundle Size\tWasm wrappers do not affect your app's bundle size, since Wasm wrappers are downloaded at runtime from a decentralized endpoint like IPFS.\tJavaScript SDKs are installed using npm, and embedded into your app's bundle, increasing the overall size of the application. Upgrades & Patches\tSince Wasm wrappers are resolved at runtime, this allows for optional automatic updates, in the event the app is invoking an updatable URI (such as an \"ENS\" domain).\tSince JS SDKs are bundled into applications, when new patches or features are released, the application must be rebuilt with the latest version. If breaking backend (smart contract) upgrades are performed, this would render the application broken until you rebuild with the latest SDK.","keywords":""},{"title":"URI redirects","type":0,"sectionRef":"#","url":"concepts/understanding-uri-redirects","content":"Similar to how browsers can redirect from one URI to another, the Polywrap client can have custom URI redirects configured as well. For example, if we'd like to redirect all queries to the ens/api.helloworld.polywrap.eth URI to our own custom URI (ens/api.myhelloworld.eth , for example), we'd simply configure the client like so: const client = new PolywrapClient({ redirects: [ { from: `ens/api.helloworld.polywrap.eth`, to: `ens/api.myhelloworld.eth`, }, ], }); Copy caution The ens/api.myhelloworld.eth wrapper must fully implement the ens/api.helloworld.polywrap.eth schema.","keywords":""},{"title":"Understanding plugins","type":0,"sectionRef":"#","url":"concepts/understanding-plugins","content":"","keywords":""},{"title":"Default Plugin wrappers","type":1,"pageTitle":"Understanding plugins","url":"concepts/understanding-plugins#default-plugin-wrappers","content":"The Polywrap client has a default configuration that enables developers to use the following plugins: wrap://ens/js-logger.polywrap.ethwrap://ens/ipfs.polywrap.ethwrap://ens/ens-resolver.polywrap.ethwrap://ens/ethereum.polywrap.ethwrap://ens/http.polywrap.ethwrap://ens/fs.polywrap.ethwrap://ens/fs-resolver.polywrap.ethwrap://ens/ipfs-resolver.polywrap.eth NOTE: This default configuration will be removed in the near future, and replaced by a \"config builder\". This will make the client agnostic, and allow users to combine and customize different \"config bundles\", in addition to creating their your own. "},{"title":"Plugin URI Redirects","type":1,"pageTitle":"Understanding plugins","url":"concepts/understanding-plugins#plugin-uri-redirects","content":"Plugin wrappers are configured using URI Redirects. We would specify the uri property as the URI of the plugin we want to use, and the plugin property as the actual plugin. For example, we can add an Ethereum plugin that uses MetaMask (or any other Ethereum JS provider) for its provider & signer! import { PolywrapClient } from \"@polywrap/client-js\"; import { ethereumPlugin } from '@polywrap/ethereum-plugin-js'; // Enable Metamask const ethereum = (window as any).ethereum; await ethereum.request({ method: 'eth_requestAccounts', }); // Configure the Ethereum plugin w/ MetaMask const client = new PolywrapClient({ plugins: [{ uri: \"ens/ethereum.polywrap.eth\", plugin: ethereumPlugin({ networks: { mainnet: { provider: ethereum } }, // If defaultNetwork is not specified, mainnet will be used. defaultNetwork: \"mainnet\" }) }] }); Copy "},{"title":"What is Polywrap?","type":0,"sectionRef":"#","url":"concepts/what-is-polywrap","content":"","keywords":""},{"title":"Web3 protocol integration","type":1,"pageTitle":"What is Polywrap?","url":"concepts/what-is-polywrap#web3-protocol-integration","content":"Web3 developers may want to integrate functions into their own app that allows users to perform a token swap, for example. The main way that developers do this today is by installing a JavaScript SDK like the Uniswap SDK as a dependency into their app. While JavaScript SDKs is one way for apps to interact with protocols, they come with major disadvantages. "},{"title":"What's inside a Polywrap Wasm wrapper?","type":1,"pageTitle":"What is Polywrap?","url":"concepts/what-is-polywrap#whats-inside-a-polywrap-wasm-wrapper","content":"A Polywrap Wasm \"wrapper\" consists of the following files: A Wasm module containing the protocol's business logic functions (e.g. Uniswap's swap functions)Wrap Manifest file that orchestrates the wrapper, and provides types and parameters for the module functions "},{"title":"Where is it deployed?","type":1,"pageTitle":"What is Polywrap?","url":"concepts/what-is-polywrap#where-is-it-deployed","content":"We currently support deploying wrappers to decentralized endpoints, Ethereum Name Service (ENS), a decentralized Ethereum-based naming system and InterPlanetary File System (IPFS), a distributed P2P file system. You can see a list of all deployed wrappers here: https://wrappers.io/pins "},{"title":"How can apps integrate this deployed wrapper?","type":1,"pageTitle":"What is Polywrap?","url":"concepts/what-is-polywrap#how-can-apps-integrate-this-deployed-wrapper","content":"In a JavaScript application, a developer would first install the Polywrap JavaScript client. At that point, a Polywrap-enabled app will be able to download and use the protocol's functions. These functions are exported from WebAssembly (Wasm) modules, and can be used in any environment that can execute Wasm functions (like your web browser!). tip The Polywrap JavaScript client allows the app to use any deployed wrapper. After instantiating the client, the app can call queries to the wrapper using familiar GraphQL or our streamlined invocation syntax. All that is needed is: The URI specifying the ENS or IPFS resolving to content containing the wrapperSpecifying the function and arguments provided by that wrapper For detailed information on how to integrate in apps, take a look at our Create a JS App guide. For a guide on how to build your own Polywrap and deploy it for other developers to integrate into their own app, see our Creating a Wasm wrapper guide. "},{"title":"Understanding URIs","type":0,"sectionRef":"#","url":"concepts/understanding-uris","content":"Deployed wrappers are identified using custom URIs (Uniform Resource Identifier). For example: wrap://ens/api.helloworld.polywrap.eth Copy Polywrap URIs have 3 parts: a protocol, an authority, and a path. Protocol# Polywrap URIs use the wrap protocol. Including wrap:// in your URI is optional in practice. Authority# For example: ens/ for resolving ENS domainsipfs/ for resolving IPFS contentfs/ for resolving content on the local filesystem Path# For example: api.domain.eth for an ENS domainQmaLbZnnnHbcRRo3wNBQ2MhugmBGL9R2YYeBvj6Nk2QumP for an IPFS file/directory./build for a local directory tip ens/ and ipfs/ URI resolution is supported in all Polywrap clients by default. Adding custom URI resolvers is possible. More documentation on how to do this will be released soon.","keywords":""},{"title":"Common GraphQL Types","type":0,"sectionRef":"#","url":"demos/uniswapv2/common-types","content":"","keywords":""},{"title":"Enumeration Types","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#enumeration-types","content":""},{"title":"ChainId","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#chainid","content":"enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN } Copy "},{"title":"TradeType","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#tradetype","content":"enum TradeType { EXACT_INPUT EXACT_OUTPUT } Copy "},{"title":"Rounding","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#rounding","content":"enum Rounding { ROUND_DOWN ROUND_HALF_UP ROUND_UP } Copy "},{"title":"Common Types","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#common-types","content":""},{"title":"TradeOptions","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#tradeoptions","content":"type TradeOptions { allowedSlippage: String! recipient: String! unixTimestamp: UInt64! ttl: UInt32 deadline: UInt32 feeOnTransfer: Boolean } Copy "},{"title":"Token","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"Currency","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#currency","content":"type Currency { decimals: UInt8! symbol: String name: String } Copy "},{"title":"TokenAmount","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#tokenamount","content":"type TokenAmount { token: Token! amount: String! # UInt256! } Copy "},{"title":"Pair","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#pair","content":"type Pair { tokenAmount0: TokenAmount! tokenAmount1: TokenAmount! } Copy "},{"title":"Route","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#route","content":"type Route { path: [Token!]! pairs: [Pair!]! input: Token! output: Token! } Copy "},{"title":"Trade","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#trade","content":"type Trade { route: Route! inputAmount: TokenAmount! outputAmount: TokenAmount! tradeType: TradeType! } Copy "},{"title":"Swap Parameters","type":1,"pageTitle":"Common GraphQL Types","url":"demos/uniswapv2/common-types#swap-parameters","content":"type SwapParameters { methodName: String! args: [String!]! value: String! } Copy type TxOverrides { gasPrice: BigInt gasLimit: BigInt } Copy "},{"title":"Fetch","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/fetch","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"TokenAmount","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#tokenamount","content":"type TokenAmount { token: Token! amount: String! # UInt256! } Copy "},{"title":"ChainId","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#chainid","content":"enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#query-schemas","content":""},{"title":"fetchTokenData","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#fetchtokendata","content":"Fetches token data.  fetchTokenData( chainId: ChainId! address: String! symbol: String name: String ): Token! Copy "},{"title":"fetchTotalSupply","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#fetchtotalsupply","content":"Fetches total supply.  fetchTotalSupply( token: Token! ): TokenAmount! Copy "},{"title":"fetchPairData","type":1,"pageTitle":"Fetch","url":"demos/uniswapv2/queries/fetch#fetchpairdata","content":"Fetches pair data.  fetchPairData( token0: Token! token1: Token! ): Pair! Copy "},{"title":"Swap","type":0,"sectionRef":"#","url":"demos/uniswapv2/mutations/swap","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"TradeOptions","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#tradeoptions","content":"type TradeOptions { allowedSlippage: String! recipient: String! unixTimestamp: UInt64! ttl: UInt32 deadline: UInt32 feeOnTransfer: Boolean } Copy "},{"title":"TradeType","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#tradetype","content":"enum TradeType { EXACT_INPUT EXACT_OUTPUT } Copy "},{"title":"TxOverrides","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#txoverrides","content":"type TxOverrides { gasPrice: BigInt gasLimit: BigInt } Copy "},{"title":"ChainId","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#chainid","content":"enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN } Copy "},{"title":"Mutation schemas","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#mutation-schemas","content":""},{"title":"swap","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#swap","content":"Select token in and token out and amount for the swap.  swap ( tokenIn: Token! tokenOut: Token! amount: BigInt! tradeType: TradeType! tradeOptions: TradeOptions! txOverrides: TxOverrides ): Ethereum_TxReceipt! Copy "},{"title":"exec","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#exec","content":"Executes the trade.  exec( trade: Trade! tradeOptions: TradeOptions! txOverrides: TxOverrides ): Ethereum_TxReceipt! Copy "},{"title":"execCall","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#execcall","content":"Executes swap given swap parameters and chain ID.  execCall( parameters: SwapParameters! chainId: ChainId! txOverrides: TxOverrides ): Ethereum_TxReceipt! Copy "},{"title":"approve","type":1,"pageTitle":"Swap","url":"demos/uniswapv2/mutations/swap#approve","content":"Approves tokens in the swap.  approve( token: Token! amount: BigInt txOverrides: TxOverrides ): Ethereum_TxReceipt! Copy "},{"title":"Route","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/route","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#query-schemas","content":""},{"title":"createRoute","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#createroute","content":"Creates a route.  createRoute( pairs: [Pair!]! input: Token! output: Token ): Route! Copy "},{"title":"routePath","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#routepath","content":"Returns the full path from input token to output token.  routePath( pairs: [Pair!]! input: Token! ): [Token!]! Copy "},{"title":"routeMidPrice","type":1,"pageTitle":"Route","url":"demos/uniswapv2/queries/route#routemidprice","content":"Helper function for use in routeMidPrice and trade query functions.  routeMidPrice( route: Route! ): String! Copy "},{"title":"Pair","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/pair","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"TokenAmount","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#tokenamount","content":"type TokenAmount { token: Token! amount: String! # UInt256! } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#query-schemas","content":""},{"title":"pairAddress","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairaddress","content":"Returns address of pair liquidity token contract.  pairAddress( token0: Token! token1: Token! ): String! Copy "},{"title":"pairLiquidityToken","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairliquiditytoken","content":"Returns pair liquidity token.  pairLiquidityToken( pair: Pair! ): Token! Copy "},{"title":"pairReserves","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairreserves","content":"Returns reserves for pair tokens in sorted order.  pairReserves( pair: Pair! ): [TokenAmount!]! Copy "},{"title":"pairToken0Price","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairtoken0price","content":"Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0.  pairToken0Price( pair: Pair! ): String! Copy "},{"title":"pairToken1Price","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairtoken1price","content":"Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1.  pairToken1Price( pair: Pair! ): String! Copy "},{"title":"pairOutputAmount","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairoutputamount","content":"Pricing function for exact input amounts. Returns maximum output amount, based on current reserves, if the trade were executed.  pairOutputAmount( pair: Pair! inputAmount: TokenAmount! ): TokenAmount! Copy "},{"title":"pairOutputNextPair","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairoutputnextpair","content":"Pricing function for exact input amounts. Returns next pair state, based on current reserves, if the trade were executed.  pairOutputNextPair( pair: Pair! inputAmount: TokenAmount! ): Pair! Copy "},{"title":"pairInputNextPair","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairinputnextpair","content":"Pricing function for exact output amounts. Returns next pair state, based on current reserves, if the trade were executed.  pairInputNextPair( pair: Pair! outputAmount: TokenAmount! ): Pair! Copy "},{"title":"pairInputAmount","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairinputamount","content":"Pricing function for exact output amounts. Returns minimum input amount, based on current reserves, if the trade were executed.  pairInputAmount( pair: Pair! outputAmount: TokenAmount! ): TokenAmount! Copy "},{"title":"pairLiquidityMinted","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairliquidityminted","content":"Calculates the exact amount of liquidity tokens minted from a given amount of token0 and token1.totalSupply is total supply of pair liquidity token.totalSupply must be looked up on-chain.The value returned from this function cannot be used as an input to getLiquidityValue.  pairLiquidityMinted( pair: Pair! totalSupply: TokenAmount! tokenAmount0: TokenAmount! tokenAmount1: TokenAmount! ): TokenAmount Copy "},{"title":"pairLiquidityValue","type":1,"pageTitle":"Pair","url":"demos/uniswapv2/queries/pair#pairliquidityvalue","content":"Calculates the exact amount of token0 or token1 that the given amount of liquidity tokens represent.totalSupply is total supply of pair liquidity token.totalSupply must be looked up on-chain.If the protocol charge is on, feeOn must be set to true, and kLast must be provided from an on-chain lookup.Values returned from this function cannot be used as inputs to getLiquidityMinted.  pairLiquidityValue( pair: Pair! totalSupply: TokenAmount! liquidity: TokenAmount! feeOn: Boolean kLast: BigInt ): [TokenAmount!]! Copy "},{"title":"Token","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/token","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"TokenAmount","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#tokenamount","content":"type TokenAmount { token: Token! amount: String! # UInt256! } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#query-schemas","content":""},{"title":"tokenEquals","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#tokenequals","content":"Checks if the current instance is equal to another (has an identical chainId and address). tokenEquals(token: Token!, other: Token!): Boolean! Copy "},{"title":"tokenAmountEquals","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#tokenamountequals","content":"Compares two TokenAmount types for equality, returning true if they have the same token and same amount. tokenAmountEquals( tokenAmount0: TokenAmount! tokenAmount1: TokenAmount! ): Boolean! Copy "},{"title":"tokenSortsBefore","type":1,"pageTitle":"Token","url":"demos/uniswapv2/queries/token#tokensortsbefore","content":"Checks if the current instance sorts before another, by address. tokenSortsBefore(token: Token!, other: Token!): Boolean! Copy "},{"title":"Router","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/router","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#imported-types","content":""},{"title":"Token","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#token","content":"type Token { chainId: ChainId! address: String! currency: Currency! } Copy "},{"title":"TradeOptions","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#tradeoptions","content":"type TradeOptions { allowedSlippage: String! recipient: String! unixTimestamp: UInt64! ttl: UInt32 deadline: UInt32 feeOnTransfer: Boolean } Copy "},{"title":"SwapParameters","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#swapparameters","content":"type SwapParameters { methodName: String! args: [String!]! value: String! } Copy "},{"title":"TxOverrides","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#txoverrides","content":"type TxOverrides { gasPrice: BigInt gasLimit: BigInt } Copy "},{"title":"ChainId","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#chainid","content":"enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#query-schemas","content":""},{"title":"swapCallParameters","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#swapcallparameters","content":"Returns the parameters for the swap.  swapCallParameters( trade: Trade!, tradeOptions: TradeOptions! ): SwapParameters! Copy "},{"title":"estimateGas","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#estimategas","content":"Estimates the gas being used in the swap.  estimateGas( parameters: SwapParameters! chainId: ChainId ): String! Copy "},{"title":"execCallStatic","type":1,"pageTitle":"Router","url":"demos/uniswapv2/queries/router#execcallstatic","content":"Returns empty string if call would be successful, otherwise returns solidity contract error.  execCallStatic( parameters: SwapParameters! chainId: ChainId! txOverrides: TxOverrides ): String! Copy "},{"title":"Uniswap v2 Polywrap Documentation","type":0,"sectionRef":"#","url":"demos/uniswapv2/uniswapv2-polywrap-intro","content":"","keywords":""},{"title":"Overview","type":1,"pageTitle":"Uniswap v2 Polywrap Documentation","url":"demos/uniswapv2/uniswapv2-polywrap-intro#overview","content":"Welcome to the Uniswap v2 Polywrap documentation! If you haven't seen our demo yet, please take a look at it first! Uniswap v2 Polywrap wrapper Demo The Uniswap Wasm wrapper is written in AssemblyScript, and like the official Uniswap SDK, it has a robust test suite, performs arbitrary precision arithmetic, and supports rounding to significant digits or fixed decimal places. The Uniswap wrapper business logic will be deployed on a decentralized endpoint, like IPFS. Our first Polywrap client is for JavaScript(@polywrap/client-js) and it can run in any environment that can execute JavaScript. In the future, we'll have Polywrap clients for other environments (Python, Go, and more). Developers integrating the Uniswap Wasm wrapper into their app would use GraphQL queries to execute functions provided by the Uniswap Polywrap. This documentation shows you which functions are made available by the Uniswap wrapper and how to use them. "},{"title":"Uniswap Polywrap vs. Existing SDK","type":1,"pageTitle":"Uniswap v2 Polywrap Documentation","url":"demos/uniswapv2/uniswapv2-polywrap-intro#uniswap-polywrap-vs-existing-sdk","content":"The Uniswap Wasm wrapper aims to be a substantial improvement over Uniswap v2’s existing SDK. While the official SDK bundles all classes (e.g. Token), necessary data fields, and helper functions into the application, the Uniswap wrapper does not. Instead, all business logic is deployed on a decentralized endpoint, like IPFS, and is downloaded at runtime when the client application launches. You can learn more about the benefits of using Polywrap here. "},{"title":"Usage","type":1,"pageTitle":"Uniswap v2 Polywrap Documentation","url":"demos/uniswapv2/uniswapv2-polywrap-intro#usage","content":"We've created an interactive tutorial that can help you get started using the Uniswap wrapper here. In general, to use any Polywrap in your app, all you need is the Polywrap Client. npm install --save @polywrap/client-js Copy The Polywrap JavaScript Client works in both Node.js and browser applications. Then, initialize the client. import { Web3ApiClient } from '@web3api/client-js'; const client = new Web3ApiClient(); Copy Now, you're able to send queries to the Uniswap v2 Polywrap wrapper! client.query({ uri: 'ens/v2.uniswap.web3api.eth', query: `{ tokenEquals( token: ${token} other: ${other} ) }`, }); Copy Take a look at more sophisticated tooling, such as our useWeb3ApiQuery hook, in our Create a JS app guide. "},{"title":"Code","type":1,"pageTitle":"Uniswap v2 Polywrap Documentation","url":"demos/uniswapv2/uniswapv2-polywrap-intro#code","content":"The Pre-alpha source code is available on GitHub. "},{"title":"Uniswap v3 Polywrap Documentation","type":0,"sectionRef":"#","url":"demos/uniswapv3/intro","content":"","keywords":""},{"title":"Overview","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"demos/uniswapv3/intro#overview","content":"Welcome to the Uniswap v3 Polywrap documentation! The Uniswap Wasm wrapper is written in AssemblyScript, and like the official Uniswap SDK, it has a robust test suite and performs arbitrary precision arithmetic. The Uniswap Polywrap wrapper business logic will be deployed on a decentralized endpoint, like IPFS. Our first Polywrap client is for JavaScript(@polywrap/client-js) and it can run in any environment that can execute JavaScript. We also have a working Rust implementation. In the future, we'll have Polywrap clients for other environments (Python, Go, and more). Developers integrating the Uniswap Wasm wrapper into their app would use client invocations to execute functions provided by the Uniswap wrapper. This documentation shows you which functions are made available by the Uniswap wrapper and how to use them. "},{"title":"Uniswap wrapper vs. Existing SDK","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"demos/uniswapv3/intro#uniswap-wrapper-vs-existing-sdk","content":"The Uniswap wrapper aims to be a substantial improvement over Uniswap v3’s existing SDK. While the official SDK bundles all classes (e.g. Trade), necessary data fields, and helper functions into the application, the Uniswap wrapper does not. Instead, all business logic is deployed on a decentralized endpoint, like IPFS, and is downloaded at runtime when the client application launches. You can learn more about the benefits of using Polywrap here. "},{"title":"Usage","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"demos/uniswapv3/intro#usage","content":"We've created an interactive tutorial that can help you get started using the Uniswap wrapper here. In general, to use any Polywrap in your application, all you need is the Polywrap Client. npm install --save @polywrap/client-js Copy The Polywrap JavaScript Client works in both Node.js and browser applications. Then, initialize the client. import { Web3ApiClient } from '@polywrap/client-js'; const client = new Web3ApiClient(); Copy Now, you're able to send queries to the Uniswap v3 wrapper! // You can use the familiar GraphQL Query syntax const tokenEqualsQuery: QueryApiResult = client.query(<{ tokenEquals: boolean }>{ uri: 'ens/v3.uniswap.web3api.eth', query: `{ tokenEquals( tokenA: ${tokenA} tokenB: ${tokenB} ) }`, }); const tokenEquals: boolean | undefined = tokenEqualsQuery.data?.tokenEquals; // Or the alternative Invoke syntax const routerQuery: InvokeApiResult<MethodParameters> = await client.invoke<MethodParameters>({ uri: ensUri, module: \"query\", method: \"swapCallParameters\", input: { trades: bestTrades, options: { slippageTolerance: \"0.01\", recipient: recipient, deadline: \"123\", } } }); const swapCallParameters: MethodParameters | undefined = routerQuery.data; Copy Take a look at more sophisticated tooling, such as our useWeb3ApiQuery hook, in our Create a JS App guide. "},{"title":"Code","type":1,"pageTitle":"Uniswap v3 Polywrap Documentation","url":"demos/uniswapv3/intro#code","content":"The Pre-alpha source code is available on GitHub. "},{"title":"Call","type":0,"sectionRef":"#","url":"demos/uniswapv3/mutations/call","content":"","keywords":""},{"title":"approve","type":1,"pageTitle":"Call","url":"demos/uniswapv3/mutations/call#approve","content":"Call the approve(...) function of an ERC20 token contract on-chain, allowing the Uniswap router contract to transfer tokens approve( token: Token! # Token for which to approve the Uniswap router contract to transfer amount: BigInt # The amount to approve for transfer; defaults to maximum amount if null gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"execCall","type":1,"pageTitle":"Call","url":"demos/uniswapv3/mutations/call#execcall","content":"Send an Ethereum transaction to the given address execCall( parameters: MethodParameters! # Transaction calldata and Ether value address: String! # Address of the target Ethereum contract chainId: ChainId! # Id of the chain on which to execute the transaction gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"Trade","type":0,"sectionRef":"#","url":"demos/uniswapv2/queries/trade","content":"","keywords":""},{"title":"Imported types","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#imported-types","content":""},{"title":"Trade","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#trade","content":"type Trade { route: Route! inputAmount: TokenAmount! outputAmount: TokenAmount! tradeType: TradeType! } Copy "},{"title":"TradeOptions","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tradeoptions","content":"type TradeOptions { allowedSlippage: String! recipient: String! unixTimestamp: UInt64! ttl: UInt32 deadline: UInt32 feeOnTransfer: Boolean } Copy "},{"title":"TradeType","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tradetype","content":"enum TradeType { EXACT_INPUT EXACT_OUTPUT } Copy "},{"title":"Query schemas","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#query-schemas","content":""},{"title":"tokenEquals","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tokenequals","content":"Checks if the current instance is equal to another (has an identical chainId and address). tokenEquals(token: Token!, other: Token!): Boolean! Copy "},{"title":"createTrade","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#createtrade","content":"Creates a new trade.  createTrade( route: Route! amount: TokenAmount! tradeType: TradeType! ): Trade! Copy "},{"title":"tradeExecutionPrice","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tradeexecutionprice","content":"Calculates the average price that the trade would execute at.  tradeExecutionPrice( trade: Trade! ): String! Copy "},{"title":"tradeNextMidPrice","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tradenextmidprice","content":"What the new mid price would be if the trade were to execute.  tradeNextMidPrice( trade: Trade! ): String! Copy "},{"title":"tradeSlippage","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#tradeslippage","content":"The slippage incurred by the trade. (strictly > 0.30%) result is a percent like 100.0%  tradeSlippage( trade: Trade! ): String! Copy "},{"title":"tradeMinimumAmountOut","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#trademinimumamountout","content":"Trades the minimum amount out.  tradeMinimumAmountOut( trade: Trade! slippageTolerance: String! # Float32! ): TokenAmount! Copy "},{"title":"tradeMaximumAmountIn","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#trademaximumamountin","content":"Trades the maximum amount in.  tradeMaximumAmountIn( trade: Trade! slippageTolerance: String! # Float32! ): TokenAmount! Copy "},{"title":"bestTradeExactIn","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#besttradeexactin","content":"Given a list of pairs, a fixed amount in, and token out, this methodreturns the best maxNumResults trades that swap an input token amount to anoutput token, making at most maxHops hops. The returned trades are sorted byoutput amount, in decreasing order, and all share the given input amount.  bestTradeExactIn( pairs: [Pair!]! amountIn: TokenAmount! tokenOut: Token! options: BestTradeOptions ): [Trade!]! Copy "},{"title":"bestTradeExactOut","type":1,"pageTitle":"Trade","url":"demos/uniswapv2/queries/trade#besttradeexactout","content":"Similar to the above method, but targets a fixed output token amount. Thereturned trades are sorted by input amount, in increasing order, and all sharethe given output amount.  bestTradeExactOut( pairs: [Pair!]! tokenIn: Token! amountOut: TokenAmount! options: BestTradeOptions ): [Trade!]! Copy "},{"title":"Deploy Pool","type":0,"sectionRef":"#","url":"demos/uniswapv3/mutations/deploy","content":"","keywords":""},{"title":"deployPool","type":1,"pageTitle":"Deploy Pool","url":"demos/uniswapv3/mutations/deploy#deploypool","content":"Deploy a pool contract on-chain deployPool( pool: Pool! # A representation of the pool to deploy gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"deployPoolFromTokens","type":1,"pageTitle":"Deploy Pool","url":"demos/uniswapv3/mutations/deploy#deploypoolfromtokens","content":"Deploy a pool contract on chain for the given tokens and fee amount deployPoolFromTokens( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"Swap","type":0,"sectionRef":"#","url":"demos/uniswapv3/mutations/swap","content":"","keywords":""},{"title":"execSwap","type":1,"pageTitle":"Swap","url":"demos/uniswapv3/mutations/swap#execswap","content":"Perform an on-chain swap with one or more trades in a single transaction execSwap( trades: Trade[]! # Trades to encode into calldata swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"swap","type":1,"pageTitle":"Swap","url":"demos/uniswapv3/mutations/swap#swap","content":"Perform an on-chain swap within a single pool by using token and fee amount information to find the correct pool swap( inToken: Token! # Input token of the pool outToken: Token! # Output token of the pool fee: FeeAmount! # Fee amount of the pool being used for the swap amount: BigInt! # Amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"swapWithPool","type":1,"pageTitle":"Swap","url":"demos/uniswapv3/mutations/swap#swapwithpool","content":"Perform an on-chain swap using a single pool at provided address; requires ERC20-compliant input and output (i.e. no Ether) swapWithPool( address: String! # Ethereum address of the pool used for the swap amount: TokenAmount! # Token amount being swapped in or out, depending on trade type tradeType: TradeType! # Type of trade, either exact input or exact output swapOptions: SwapOptions! # Swap configuration gasOptions: GasOptions # Transaction gas configuration ): Ethereum_TxResponse! Copy "},{"title":"Encode Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/encodeUtils","content":"","keywords":""},{"title":"toHex","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#tohex","content":"Converts a big int to a hex string toHex( value: BigInt! ): String! Copy "},{"title":"encodeRouteToPath","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encoderoutetopath","content":"Converts a route to a hex encoded path encodeRouteToPath( route: Route! # The v3 path to convert to an encoded path exactOutput: Boolean! # Whether the route should be encoded in reverse, for making exact output swaps ): String! Copy "},{"title":"encodePermit","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encodepermit","content":"Encodes arguments and returns transaction calldata to call selfPermit or selfPermitAllowed on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodePermit( token: Token! options: PermitOptions! ): String! Copy "},{"title":"encodeUnwrapWETH9","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encodeunwrapweth9","content":"Encodes arguments and returns transaction calldata to call unwrapWETH9 or unwrapWETH9WithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeUnwrapWETH9( amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String! Copy "},{"title":"encodeSweepToken","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encodesweeptoken","content":"Encodes arguments and returns transaction calldata to call sweepToken or sweepTokenWithFee on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeSweepToken( token: Token! amountMinimum: BigInt! recipient: String! feeOptions: FeeOptions ): String! Copy "},{"title":"encodeRefundETH","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encoderefundeth","content":"Encodes arguments and returns transaction calldata to call refundEth on an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeRefundETH( ): String! Copy "},{"title":"encodeMulticall","type":1,"pageTitle":"Encode Utilities","url":"demos/uniswapv3/queries/encodeUtils#encodemulticall","content":"Encodes multiple calldatas into a single calldata for making multiple calls in one transaction using a contract implementing the necessary interface, such as an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol encodeMulticall( calldatas: String[]! ): String! Copy "},{"title":"Constants","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/constants","content":"","keywords":""},{"title":"FACTORY_ADDRESS","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#factory_address","content":"The address of Uniswap's pool factory contract FACTORY_ADDRESS( ): String! Copy "},{"title":"POOL_INIT_CODE_HASH","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#pool_init_code_hash","content":"POOL_INIT_CODE_HASH( ): String! Copy "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#pool_init_code_hash_optimism","content":"POOL_INIT_CODE_HASH_OPTIMISM( ): String! Copy "},{"title":"POOL_INIT_CODE_HASH_OPTIMISM_KOVAN","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#pool_init_code_hash_optimism_kovan","content":"A historical artifact due to small compiler mismatch POOL_INIT_CODE_HASH_OPTIMISM_KOVAN( ): String! Copy "},{"title":"MIN_TICK","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#min_tick","content":"Smallest valid tick index in a pool MIN_TICK( ): Int32! Copy "},{"title":"MAX_TICK","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#max_tick","content":"Largest valid tick index in a pool MAX_TICK( ): Int32! Copy "},{"title":"MIN_SQRT_RATIO","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#min_sqrt_ratio","content":"Smallest valid sqrtRatioX96 in a pool MIN_SQRT_RATIO( ): BigInt! Copy "},{"title":"MAX_SQRT_RATIO","type":1,"pageTitle":"Constants","url":"demos/uniswapv3/queries/constants#max_sqrt_ratio","content":"Largest valid sqrtRatioX96 in a pool MAX_SQRT_RATIO( ): BigInt! Copy "},{"title":"Fetch","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/fetch","content":"","keywords":""},{"title":"fetchToken","type":1,"pageTitle":"Fetch","url":"demos/uniswapv3/queries/fetch#fetchtoken","content":"Returns token object constructed from the on-chain token contract at the given address fetchToken( address: String! # The Ethereum address of token's ERC20 contract chainId: ChainId! # The id of the chain to be queried ): Token! Copy "},{"title":"fetchPoolFromTokens","type":1,"pageTitle":"Fetch","url":"demos/uniswapv3/queries/fetch#fetchpoolfromtokens","content":"Returns pool object constructed from the on-chain pool contract associated with the tokens and fee amount fetchPoolFromTokens( tokenA: Token! # A token in the pool tokenB: Token! # The other token in the pool fee: FeeAmount! # The pool's fee amount fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool! Copy "},{"title":"fetchPoolFromAddress","type":1,"pageTitle":"Fetch","url":"demos/uniswapv3/queries/fetch#fetchpoolfromaddress","content":"Returns pool object constructed from the on-chain pool contract at the given address fetchPoolFromAddress( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried fetchTicks: Boolean! # If true, the full list of pool ticks will be fetched ): Pool! Copy "},{"title":"fetchTickList","type":1,"pageTitle":"Fetch","url":"demos/uniswapv3/queries/fetch#fetchticklist","content":"Returns array of ticks from the on-chain pool contract at the given address fetchTickList( address: String! # The Ethereum address of the pool contract chainId: ChainId! # The id of the chain to be queried ): Tick[]! Copy "},{"title":"Enum Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/enumUtils","content":"","keywords":""},{"title":"feeAmountToTickSpacing","type":1,"pageTitle":"Enum Utilities","url":"demos/uniswapv3/queries/enumUtils#feeamounttotickspacing","content":"Returns the tick spacing associated with a FeeAmount enum value feeAmountToTickSpacing( feeAmount: FeeAmount! ): Int32! Copy "},{"title":"getFeeAmount","type":1,"pageTitle":"Enum Utilities","url":"demos/uniswapv3/queries/enumUtils#getfeeamount","content":"Returns the fee (in one-hundred-thousandths of a percent) associated with a FeeAmount enum value getFeeAmount( feeAmount: FeeAmount! ): UInt32! Copy "},{"title":"getPermitV","type":1,"pageTitle":"Enum Utilities","url":"demos/uniswapv3/queries/enumUtils#getpermitv","content":"Returns v value associated with a PermitV enum value getPermitV( permitV: PermitV! ): Int32! Copy "},{"title":"Nonfungible Position Manager","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/nfpm","content":"","keywords":""},{"title":"createCallParameters","type":1,"pageTitle":"Nonfungible Position Manager","url":"demos/uniswapv3/queries/nfpm#createcallparameters","content":"Returns calldata for creating a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol createCallParameters( pool: Pool! # An off-chain representation of the pool to create on-chain ): MethodParameters! Copy "},{"title":"addCallParameters","type":1,"pageTitle":"Nonfungible Position Manager","url":"demos/uniswapv3/queries/nfpm#addcallparameters","content":"Returns calldata for minting or adding liquidity to a pool on-chain using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol. Optionally creates the pool if it doesn't exist. addCallParameters( position: Position! # Liquidity position to add to pool options: AddLiquidityOptions! # Required transaction configuration ): MethodParameters! Copy "},{"title":"collectCallParameters","type":1,"pageTitle":"Nonfungible Position Manager","url":"demos/uniswapv3/queries/nfpm#collectcallparameters","content":"Returns calldata for collecting liquidity provider rewards using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol collectCallParameters( options: CollectOptions! # Required transaction configuration ): MethodParameters! Copy "},{"title":"removeCallParameters","type":1,"pageTitle":"Nonfungible Position Manager","url":"demos/uniswapv3/queries/nfpm#removecallparameters","content":"Returns calldata for completely or partially exiting a liquidity position using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol removeCallParameters( position: Position! # The position to exit options: RemoveLiquidityOptions! # Additional information necessary for generating the calldata ): MethodParameters! Copy "},{"title":"safeTransferFromParameters","type":1,"pageTitle":"Nonfungible Position Manager","url":"demos/uniswapv3/queries/nfpm#safetransferfromparameters","content":"Returns calldata for safely transferring an NFT using an instance of Uniswap's NonfungiblePositionManager contract: https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol safeTransferFromParameters( options: SafeTransferOptions! # Required transaction configuration ): MethodParameters! Copy "},{"title":"Math Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/mathUtils","content":"","keywords":""},{"title":"mostSignificantBit","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#mostsignificantbit","content":"Returns the most significant bit of a positive integer, starting with first bit = 0 mostSignificantBit( x: BigInt! ): UInt32! Copy "},{"title":"encodeSqrtRatioX96","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#encodesqrtratiox96","content":"Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0 encodeSqrtRatioX96( amount1: BigInt! # The numerator amount i.e., the amount of token1 amount0: BigInt! # The denominator amount i.e., the amount of token0 ): BigInt! Copy "},{"title":"mulDivRoundingUp","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#muldivroundingup","content":"Returns (a * b) / denominator mulDivRoundingUp( a: BigInt! b: BigInt! denominator: BigInt! ): BigInt! Copy "},{"title":"addDelta","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#adddelta","content":"Returns x + y addDelta( x: BigInt! y: BigInt! ): BigInt! Copy "},{"title":"getAmount0Delta","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#getamount0delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount0Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt! Copy "},{"title":"getAmount1Delta","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#getamount1delta","content":"Used to facilitate liquidity math using sqrtRatioX96 values getAmount1Delta( sqrtRatioAX96: BigInt! sqrtRatioBX96: BigInt! liquidity: BigInt! roundUp: Boolean! ): BigInt! Copy "},{"title":"getNextSqrtPriceFromInput","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#getnextsqrtpricefrominput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromInput( sqrtPX96: BigInt! liquidity: BigInt! amountIn: BigInt! zeroForOne: Boolean! ): BigInt! Copy "},{"title":"getNextSqrtPriceFromOutput","type":1,"pageTitle":"Math Utilities","url":"demos/uniswapv3/queries/mathUtils#getnextsqrtpricefromoutput","content":"Used to facilitate liquidity math using sqrtRatioX96 values getNextSqrtPriceFromOutput( sqrtPX96: BigInt! liquidity: BigInt! amountOut: BigInt! zeroForOne: Boolean! ): BigInt! Copy "},{"title":"Pool Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/poolUtils","content":"","keywords":""},{"title":"computePoolAddress","type":1,"pageTitle":"Pool Utilities","url":"demos/uniswapv3/queries/poolUtils#computepooladdress","content":"Computes a pool address computePoolAddress( factoryAddress: String! # The Uniswap V3 factory address tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String! Copy "},{"title":"Position","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/position","content":"","keywords":""},{"title":"createPosition","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#createposition","content":"Constructs and validates a liquidity Position for a given Pool with the given liquidity createPosition( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): Position! Copy "},{"title":"createPositionFromAmounts","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#createpositionfromamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries createPositionFromAmounts( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The amount of the first token of the pool amount1: BigInt! # The amount of the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position! Copy "},{"title":"createPositionFromAmount0","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#createpositionfromamount0","content":"Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1 createPositionFromAmount0( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount0: BigInt! # The desired amount of token0 useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): Position! Copy "},{"title":"createPositionFromAmount1","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#createpositionfromamount1","content":"Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0. Always uses full precision. createPositionFromAmount1( pool: Pool! # The pool for which the position should be created tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position amount1: BigInt! # The desired amount of token1 ): Position! Copy "},{"title":"positionToken0PriceLower","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#positiontoken0pricelower","content":"Returns the price of token0 at the lower tick positionToken0PriceLower( pool: Pool! # The pool for which the liquidity is assigned tickLower: Int32! # The lower tick of the position ): Price! Copy "},{"title":"positionToken0PriceUpper","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#positiontoken0priceupper","content":"Returns the price of token0 at the upper tick positionToken0PriceUpper( pool: Pool! # The pool for which the liquidity is assigned tickUpper: Int32! # The upper tick of the position ): Price! Copy "},{"title":"positionAmount0","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#positionamount0","content":"Returns the amount of token0 that this position's liquidity could be burned for at the current pool price positionAmount0( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount! Copy "},{"title":"positionAmount1","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#positionamount1","content":"Returns the amount of token1 that this position's liquidity could be burned for at the current pool price positionAmount1( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): TokenAmount! Copy "},{"title":"mintAmounts","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#mintamounts","content":"Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool mintAmounts( pool: Pool! # For which pool the liquidity is assigned tickLower: Int32! # The lower tick of the position tickUpper: Int32! # The upper tick of the position liquidity: BigInt! # The amount of liquidity that is in the position ): MintAmounts! Copy "},{"title":"mintAmountsWithSlippage","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#mintamountswithslippage","content":"Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance mintAmountsWithSlippage( position: Position! # Position for which to calculate mint amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts! Copy "},{"title":"burnAmountsWithSlippage","type":1,"pageTitle":"Position","url":"demos/uniswapv3/queries/position#burnamountswithslippage","content":"Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance burnAmountsWithSlippage( position: Position! # Position for which to calculate burn amounts slippageTolerance: String! # Tolerance of unfavorable slippage from the current price ): MintAmounts! Copy "},{"title":"Pool","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/pool","content":"","keywords":""},{"title":"createPool","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#createpool","content":"Constructs and validates a Pool createPool( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # Fee amount for swaps through the pool sqrtRatioX96: BigInt! # Encoded representation of current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # Current pool tick ticks: Tick[] # A validated list of all ticks in the pool ): Pool! Copy "},{"title":"getPoolAddress","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#getpooladdress","content":"Returns the Ethereum address of the Pool contract getPoolAddress( tokenA: Token! # The first token of the pool, irrespective of sort order tokenB: Token! # The second token of the pool, irrespective of sort order fee: FeeAmount! # The fee tier of the pool initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary ): String! Copy "},{"title":"poolInvolvesToken","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#poolinvolvestoken","content":"Returns true if the token is in the Pool (i.e. pool.token0 or pool.token1) poolInvolvesToken( pool: Pool! token: Token! ): Boolean! Copy "},{"title":"poolToken0Price","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#pooltoken0price","content":"Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 poolToken0Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price! Copy "},{"title":"poolToken1Price","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#pooltoken1price","content":"Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 poolToken1Price( token0: Token! # The first token of the pool, i.e. pool.token0 token1: Token! # The second token of the pool, i.e. pool.token1 sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96 ): Price! Copy "},{"title":"poolPriceOf","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#poolpriceof","content":"Returns the price of the given token in terms of the other token in the pool poolPriceOf( pool: Pool! # Pool that involves the token token: Token! # The token to return the price of ): Price! Copy "},{"title":"poolChainId","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#poolchainid","content":"Returns the chain ID of the tokens in the pool poolChainId( pool: Pool! ): ChainId! Copy "},{"title":"getPoolOutputAmount","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#getpooloutputamount","content":"Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade getPoolOutputAmount( pool: Pool! # Pool that involves input and output tokens inputAmount: TokenAmount! # The input amount for which to quote the output amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit ): PoolChangeResult! Copy "},{"title":"getPoolInputAmount","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#getpoolinputamount","content":"Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade getPoolInputAmount( pool: Pool! # Pool that involves input and output tokens outputAmount: TokenAmount! # The output amount for which to quote the input amount sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap. ): PoolChangeResult! Copy "},{"title":"getPoolTickSpacing","type":1,"pageTitle":"Pool","url":"demos/uniswapv3/queries/pool#getpooltickspacing","content":"Returns the tick spacing of ticks in the pool getPoolTickSpacing( pool: Pool! ): Int32! Copy "},{"title":"Position Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/positionUtils","content":"","keywords":""},{"title":"maxLiquidityForAmounts","type":1,"pageTitle":"Position Utilities","url":"demos/uniswapv3/queries/positionUtils#maxliquidityforamounts","content":"Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries. maxLiquidityForAmounts( sqrtRatioCurrentX96: BigInt! # Encoded representation of the current price sqrtRatioAX96: BigInt! # Encoded representation of the price at lower tick boundary sqrtRatioBX96: BigInt! # Encoded representation of the price at upper tick boundary amount0: BigInt! # Amount for the first token of the pool amount1: BigInt! # Amount for the second token of the pool useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support ): BigInt! Copy "},{"title":"Quoter","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/quoter","content":"","keywords":""},{"title":"quoteCallParameters","type":1,"pageTitle":"Quoter","url":"demos/uniswapv3/queries/quoter#quotecallparameters","content":"Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters. quoteCallParameters( route: Route! # The swap route, a list of pools through which a swap can occur amount: TokenAmount! # The amount of the quote, either an amount in, or an amount out tradeType: TradeType! # The trade type, either exact input or exact output options: QuoteOptions # Optional configuration ): MethodParameters! Copy "},{"title":"Route","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/route","content":"","keywords":""},{"title":"createRoute","type":1,"pageTitle":"Route","url":"demos/uniswapv3/queries/route#createroute","content":"Constructs and validates a Route createRoute( pools: Pool[]! # The ordered list of pools from which to construct the route inToken: Token! # The input token outToken: Token! # The output token ): Route! Copy "},{"title":"routeChainId","type":1,"pageTitle":"Route","url":"demos/uniswapv3/queries/route#routechainid","content":"Returns the chain id of the tokens in the route routeChainId( route: Route! ): ChainId! Copy "},{"title":"routeMidPrice","type":1,"pageTitle":"Route","url":"demos/uniswapv3/queries/route#routemidprice","content":"Returns the mid price of the route routeMidPrice( pools: Pool[]! # The ordered list of pools from which to calculate the mid price inToken: Token! # The input token outToken: Token! # The output token ): Price! Copy "},{"title":"Staker","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/staker","content":"","keywords":""},{"title":"collectRewards","type":1,"pageTitle":"Staker","url":"demos/uniswapv3/queries/staker#collectrewards","content":"Returns transaction calldata for calling 'unstakeToken', 'claimReward', and 'stakeToken' in a single transaction on Uniswap's Staker contract. Note: A tokenId can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake. collectRewards( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys that `tokenId` is staked in; claims rewards for each program. options: ClaimOptions! # ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once. ): MethodParameters! Copy "},{"title":"withdrawToken","type":1,"pageTitle":"Staker","url":"demos/uniswapv3/queries/staker#withdrawtoken","content":"Returns transaction calldata for unstaking, claiming, and withdrawing in a single transaction on Uniswap's Staker contract. withdrawToken( incentiveKeys: IncentiveKey[]! # A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in. options: FullWithdrawOptions! # Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`. ): MethodParameters! Copy "},{"title":"encodeDeposit","type":1,"pageTitle":"Staker","url":"demos/uniswapv3/queries/staker#encodedeposit","content":"Returns an encoded IncentiveKey as a string encodeDeposit( incentiveKeys: IncentiveKey[]! # An array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom` ): String! Copy "},{"title":"Router","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/router","content":"","keywords":""},{"title":"swapCallParameters","type":1,"pageTitle":"Router","url":"demos/uniswapv3/queries/router#swapcallparameters","content":"Encodes arguments and returns transaction calldata to make a swap on an Uniswap's V3 Router contract swapCallParameters( trades: Trade[]! # Trades for which to produce call parameters options: SwapOptions! # Configuration options for the swap call ): MethodParameters! Copy "},{"title":"TickList Data Provider","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/tickProvider","content":"","keywords":""},{"title":"validateTickList","type":1,"pageTitle":"TickList Data Provider","url":"demos/uniswapv3/queries/tickProvider#validateticklist","content":"Validates a tick list, returning true of the tick list is valid. Throws an exception if the tick list is not valid. validateTickList( ticks: Tick[]! # A list of ticks to validate tickSpacing: Int32! # The tick spacing of the list ): Boolean! Copy "},{"title":"getTick","type":1,"pageTitle":"TickList Data Provider","url":"demos/uniswapv3/queries/tickProvider#gettick","content":"Returns the tick at the requested index getTick( tickDataProvider: Tick[]! # A list of ticks to search tickIndex: Int32! # The tick index of the requested tick ): Tick! Copy "},{"title":"nextInitializedTickWithinOneWord","type":1,"pageTitle":"TickList Data Provider","url":"demos/uniswapv3/queries/tickProvider#nextinitializedtickwithinoneword","content":"Returns next initialized tick, or max or min tick. Returns true if a tick is found at index. nextInitializedTickWithinOneWord( tickDataProvider: Tick[]! # Tick list to search tick: Int32! # Current tick index lte: Boolean! # True of returned tick index should be less than or equal to current tick index tickSpacing: Int32! # Tick spacing of tick list ): NextTickResult! Copy "},{"title":"Token","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/token","content":"","keywords":""},{"title":"currencyEquals","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#currencyequals","content":"Returns true if the currencies are equivalent, false otherwise currencyEquals( currencyA: Currency! currencyB: Currency! ): Boolean! Copy "},{"title":"tokenEquals","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#tokenequals","content":"Returns true if the tokens are equivalent, false otherwise tokenEquals( tokenA: Token! tokenB: Token! ): Boolean! Copy "},{"title":"tokenAmountEquals","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#tokenamountequals","content":"Returns true if the token amounts are equivalent, false otherwise tokenAmountEquals( tokenAmountA: TokenAmount! tokenAmountB: TokenAmount! ): Boolean! Copy "},{"title":"tokenSortsBefore","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#tokensortsbefore","content":"Returns true if the address of tokenA would precede the address of token B when sorted alphabetically tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean! Copy "},{"title":"getEther","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#getether","content":"Returns a native token (e.g. Ether) on the specified chain getNative( chainId: ChainId! ): Token! Copy "},{"title":"getWETH","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#getweth","content":"Returns a Wrapped Ether token on the specified chain getWETH( chainId: ChainId! ): Token! Copy "},{"title":"isNative","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#isnative","content":"Returns true if the token is native (e.g. Ether), false otherwise. A token representing Ether must have an empty string in its address field. isNative( token: Token! ): Boolean! Copy "},{"title":"wrapToken","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#wraptoken","content":"If the input token is Ether, the return value is Wrapped Ether; otherwise, the return value is the same as the input value. wrapToken( token: Token! ): Token! Copy "},{"title":"wrapAmount","type":1,"pageTitle":"Token","url":"demos/uniswapv3/queries/token#wrapamount","content":"If the input token amount represents an amount of Ether, the return value represents the same amount in Wrapped Ether; otherwise, the return value is the same as the input value. wrapAmount( amount: TokenAmount! ): TokenAmount! Copy "},{"title":"Tick Utilities","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/tickUtils","content":"","keywords":""},{"title":"nearestUsableTick","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#nearestusabletick","content":"Returns the closest tick that is nearest a given tick and usable for the given tick spacing nearestUsableTick( tick: Int32! # The target tick tickSpacing: Int32! # The spacing of the pool ): Int32! Copy "},{"title":"tickToPrice","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#ticktoprice","content":"Returns a price object corresponding to the input tick and the base/quote token. Inputs must be tokens because the address order is used to interpret the price represented by the tick. tickToPrice( baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price tick: Int32! # The tick for which to return the price ): Price! Copy "},{"title":"priceToClosestTick","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#pricetoclosesttick","content":"Returns the first tick for which the given price is greater than or equal to the tick price. priceToClosestTick( price: Price! # Price for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price. Note that a string price is not used as input here, so the 'price' property of the Price type can have any value without affecting the results. ): Int32! Copy "},{"title":"tickIsBelowSmallest","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#tickisbelowsmallest","content":"Returns true if the tick index is smaller than all tick indices in the list tickIsBelowSmallest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean! Copy "},{"title":"tickIsAtOrAboveLargest","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#tickisatorabovelargest","content":"Returns true if the tick index is greater than or equal to all tick indices in the list tickIsAtOrAboveLargest( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index ): Boolean! Copy "},{"title":"nextInitializedTick","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#nextinitializedtick","content":"Returns next initialized tick following the input tick nextInitializedTick( ticks: Tick[]! # Tick list to check tick: Int32! # Input tick index lte: Boolean! # If true, searches list for next initialized tick that has index less than or equal to the input tick index ): Tick! Copy "},{"title":"tickListIsSorted","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#ticklistissorted","content":"Returns true if a tick list is sorted by tick index tickListIsSorted( ticks: Tick[]! # The tick list ): Boolean! Copy "},{"title":"getSqrtRatioAtTick","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#getsqrtratioattick","content":"Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick getSqrtRatioAtTick( tick: Int32! # The tick for which to compute the sqrt ratio ): BigInt! Copy "},{"title":"getTickAtSqrtRatio","type":1,"pageTitle":"Tick Utilities","url":"demos/uniswapv3/queries/tickUtils#gettickatsqrtratio","content":"Returns the tick corresponding to a given sqrt ratio, such that getSqrtRatioAtTick(tick) <= sqrtRatioX96 and getSqrtRatioAtTick(tick + 1) > sqrtRatioX96 getTickAtSqrtRatio( sqrtRatioX96: BigInt! # The sqrt ratio as a Q64.96 for which to compute the tick ): Int32! Copy "},{"title":"Common Types","type":0,"sectionRef":"#","url":"demos/uniswapv3/types/common-types","content":"","keywords":""},{"title":"BestTradeOptions","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#besttradeoptions","content":"Options used when determining the best trade in bestTradeExactIn(...) and bestTradeExactOut(...) type BestTradeOptions { maxNumResults: UInt32 # Maximum number of results to return maxHops: UInt32 # Maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool } Copy "},{"title":"Currency","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#currency","content":"Describes a token type Currency { decimals: UInt8! # Token decimals symbol: String # Token symbol name: String # Token name } Copy "},{"title":"FeeOptions","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#feeoptions","content":"Fee configuration for encodeUnwrapWETH9(...) and encodeSweepToken(...) type FeeOptions { fee: String! # The percent of the output that will be taken as a fee. recipient: String! # The recipient of the fee. } Copy "},{"title":"Fraction","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#fraction","content":"Represents fraction, typically a percent. type Fraction { numerator: BigInt! # Numerator of fraction denominator: BigInt! # Denominator of fraction quotient: String! # A decimal string representation of the fraction } Copy "},{"title":"MethodParameters","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#methodparameters","content":"Transaction calldata and an ether value to be sent with the transaction type MethodParameters { calldata: String! # The hex encoded calldata to perform the given operation value: String! # The amount of ether (wei) to send in hex. } Copy "},{"title":"MintAmounts","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#mintamounts","content":"The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool type MintAmounts { amount0: BigInt! # Amount of the first token in the pool amount1: BigInt! # Amount of the second token in the pool } Copy "},{"title":"PermitOptions","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#permitoptions","content":"Parameters for a permit allowing the transfer of tokens. Either amount and deadline OR nonce and expiry are required. type PermitOptions { v: PermitV! r: String! s: String! amount: BigInt deadline: BigInt nonce: BigInt expiry: BigInt } Copy "},{"title":"Pool","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#pool","content":"A liquidity pool involving two tokens which can be exchanged for a price determined by a price curve and market dynamics type Pool { token0: Token! # The first token of the pool token1: Token! # The second token of the pool fee: FeeAmount! # The fee amount liquidity providers receive as a share of swaps made in the pool sqrtRatioX96: BigInt! # An encoded representation of the current swap price liquidity: BigInt! # The total liquidity available in the pool tickCurrent: Int32! # The current tick tickDataProvider: Tick[]! # A list of all ticks in the pool token0Price: Price! # The current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0 token1Price: Price! # The current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1 } Copy "},{"title":"Position","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#position","content":"A liquidity position between two ticks in a pool type Position { pool: Pool! # The pool on which the position is held tickLower: Int32! # The lower tick, marking the lower boundary of the position tickUpper: Int32! # The upper tick, marking the upper boundary of the position liquidity: BigInt! # The maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries token0Amount: TokenAmount! # The amount in this position of the first token of the pool token1Amount: TokenAmount! # The amount in this position of the second token of the pool mintAmounts: MintAmounts! # The minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool token0PriceLower: Price! # The price of token0 at the lower tick token0PriceUpper: Price! # The price of token0 at the upper tick } Copy "},{"title":"Price","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#price","content":"Represents price of a token in terms of another token. When used as a function argument, the 'price' property is ignored. type Price { baseToken: Token! # The base token of the price quoteToken: Token! # The quote token of the price denominator: BigInt! # Amount of base token used to calculate price numerator: BigInt! # Amount of quote token used to calculate price price: String! # A decimal string representation of the price } Copy "},{"title":"Route","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#route","content":"An ordered path of pools through which a swap can occur type Route { pools: Pool[]! # A list of pools, wherein each pool in the list has a token in common with its adjacent pool(s) path: Token[]! # The path of tokens that are swapped through the pools input: Token! # The input token, where the route begins output: Token! # The output token, where the route ends midPrice: Price! # The mid price of the output token, in terms of the input token, for this route } Copy "},{"title":"SwapOptions","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#swapoptions","content":"Configuration for creating swap transaction calldata using swapCallParameters(...) type SwapOptions { slippageTolerance: String! # How much the execution price is allowed to move unfavorably from the trade execution price. recipient: String! # The account that should receive the output. deadline: BigInt! # When the transaction expires, in epoch seconds. inputTokenPermit: PermitOptions # The optional permit parameters for spending the input. sqrtPriceLimitX96: BigInt # The optional price limit for the trade. fee: FeeOptions # Optional information for taking a fee on output. } Copy "},{"title":"Tick","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#tick","content":"A pool tick marks a section of the price curve. A liquidity provider may hold a position on a tick, rather than the full curve. type Tick { index: Int32! # Tick index liquidityGross: BigInt! # Gross liquidity in Pool at tick position liquidityNet: BigInt! # Net liquidity in Pool at tick position } Copy "},{"title":"Token","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#token","content":"ERC20-compliant token or Ether type Token { chainId: ChainId! # Id of chain where token exists address: String! # Address of token's ERC20 contract currency: Currency! # Token description } Copy "},{"title":"TokenAmount","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#tokenamount","content":"An amount of a token type TokenAmount { token: Token! # Token amount: BigInt! # Raw amount of the token, not adjusted for the token's decimals } Copy "},{"title":"Trade","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#trade","content":"A trade contains the information necessary to create an on-chain exchange of tokens type Trade { swaps: TradeSwap[]! # A list of swaps to be executed atomically, all of which must have the same input and output tokens tradeType: TradeType! # Type of trade, either exact input or exact output inputAmount: TokenAmount! # The total input amount (sum of input amounts in swaps) outputAmount: TokenAmount! # The total output amount (sum of output amounts in swaps) executionPrice: Price! # The price of the trade, in terms of the input token priceImpact: Fraction! # The percent difference between the route's mid price and the price impact } Copy "},{"title":"TradeSwap","type":1,"pageTitle":"Common Types","url":"demos/uniswapv3/types/common-types#tradeswap","content":"A route, input, and output amount that compose the core elements of a trade type TradeSwap { route: Route! # The route of the trade inputAmount: TokenAmount! # The amount being passed in outputAmount: TokenAmount! # The amount returned by the trade when executed } Copy "},{"title":"Trade","type":0,"sectionRef":"#","url":"demos/uniswapv3/queries/trade","content":"","keywords":""},{"title":"createTradeExactIn","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createtradeexactin","content":"Constructs an exact in trade with the given amount in and route createTradeExactIn( tradeRoute: TradeRoute! # The route of the exact in trade and the amount being passed in ): Trade! Copy "},{"title":"createTradeExactOut","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createtradeexactout","content":"Constructs an exact out trade with the given amount out and route createTradeExactOut( tradeRoute: TradeRoute! # The route of the exact out trade and the amount returned ): Trade! Copy "},{"title":"createTradeFromRoute","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createtradefromroute","content":"Constructs a trade by simulating swaps through the given route createTradeFromRoute( tradeRoute: TradeRoute! # The route to swap through and the amount specified, either input or output, depending on the trade type tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade! Copy "},{"title":"createTradeFromRoutes","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createtradefromroutes","content":"Constructs a trade by simulating swaps through the given routes createTradeFromRoutes( tradeRoutes: TradeRoute[]! # The routes to swap through and how much of the amount should be routed through each tradeType: TradeType! # Whether the trade is an exact input or exact output swap ): Trade! Copy "},{"title":"createUncheckedTrade","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createuncheckedtrade","content":"Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTrade( swap: TradeSwap! # The route to swap through, the amount being passed in, and the amount returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade! Copy "},{"title":"createUncheckedTradeWithMultipleRoutes","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#createuncheckedtradewithmultipleroutes","content":"Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data createUncheckedTradeWithMultipleRoutes( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed tradeType: TradeType! # The type of the trade, either exact in or exact out ): Trade! Copy "},{"title":"tradeInputAmount","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#tradeinputamount","content":"The input amount for the trade assuming no slippage tradeInputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount! Copy "},{"title":"tradeOutputAmount","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#tradeoutputamount","content":"The output amount for the trade assuming no slippage tradeOutputAmount( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed ): TokenAmount! Copy "},{"title":"tradeExecutionPrice","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#tradeexecutionprice","content":"The price expressed in terms of output amount/input amount tradeExecutionPrice( inputAmount: TokenAmount! # The trade input amount, e.g. from Trade object or tradeInputAmount(...) outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Price! Copy "},{"title":"tradePriceImpact","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#tradepriceimpact","content":"Returns the percent difference between the route's mid price and the price impact tradePriceImpact( swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...) ): Fraction! Copy "},{"title":"tradeMinimumAmountOut","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#trademinimumamountout","content":"Get the minimum amount that must be received from the trade for the given slippage tolerance tradeMinimumAmountOut( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountOut: TokenAmount! # The output amount of the trade, before slippage, e.g. from Trade object or tradeOutputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount! Copy "},{"title":"tradeMaximumAmountIn","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#trademaximumamountin","content":"Get the maximum amount in that can be spent via the trade for the given slippage tolerance tradeMaximumAmountIn( slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage amountIn: TokenAmount! # The input amount of the trade, before slippage, e.g. from Trade object or tradeInputAmount(...) tradeType: TradeType! # The type of the trade, either exact in or exact out ): TokenAmount! Copy "},{"title":"tradeWorstExecutionPrice","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#tradeworstexecutionprice","content":"Return the execution price after accounting for slippage tolerance tradeWorstExecutionPrice( trade: Trade! # Trade for which to calculate execution price slippageTolerance: String! # The allowed tolerated slippage ): Price! Copy "},{"title":"bestTradeExactIn","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#besttradeexactin","content":"Given a list of pools, and a fixed amount in, returns the top maxNumResults trades that go from an input token amount to an output token, making at most maxHops hops. Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactIn( pools: Pool[]! # The pools to consider in finding the best trade amountIn: TokenAmount! # Exact amount of input currency to spend tokenOut: Token! # The desired currency out options: BestTradeOptions # Options used when determining the best trade ): Trade[]! Copy "},{"title":"bestTradeExactOut","type":1,"pageTitle":"Trade","url":"demos/uniswapv3/queries/trade#besttradeexactout","content":"similar to bestTradeExactIn(...) but instead targets a fixed output amount given a list of pools, and a fixed amount out, returns the top maxNumResults trades that go from an input token to an output token amount, making at most maxHops hops note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting the amount in among multiple routes. bestTradeExactOut( pools: Pool[]! # The pools to consider in finding the best trade tokenIn: Token! # The currency to spend amountOut: TokenAmount! # The desired currency amount out options: BestTradeOptions # Options used when determining the best trade ): Trade[]! Copy "},{"title":"Mutation Types","type":0,"sectionRef":"#","url":"demos/uniswapv3/types/mutation-types","content":"","keywords":""},{"title":"GasOptions","type":1,"pageTitle":"Mutation Types","url":"demos/uniswapv3/types/mutation-types#gasoptions","content":"Transaction gas configuration type GasOptions { gasPrice: BigInt # The gas price to set for the transaction gasLimit: BigInt # The gas limit to set for the transaction } Copy "},{"title":"Enum Types","type":0,"sectionRef":"#","url":"demos/uniswapv3/types/enum-types","content":"","keywords":""},{"title":"ChainId","type":1,"pageTitle":"Enum Types","url":"demos/uniswapv3/types/enum-types#chainid","content":"Ethereum chain supported by the wrapper enum ChainId { MAINNET ROPSTEN RINKEBY GOERLI KOVAN OPTIMISM OPTIMISTIC_KOVAN ARBITRUM_ONE ARBITRUM_RINKEBY POLYGON POLYGON_MUMBAI } Copy "},{"title":"FeeAmount","type":1,"pageTitle":"Enum Types","url":"demos/uniswapv3/types/enum-types#feeamount","content":"Pool swap fee amount enum FeeAmount { LOWEST LOW MEDIUM HIGH } Copy "},{"title":"PermitV","type":1,"pageTitle":"Enum Types","url":"demos/uniswapv3/types/enum-types#permitv","content":"Valid v value of Permit enum PermitV { v_0 v_1 v_27 v_28 } Copy "},{"title":"TradeType","type":1,"pageTitle":"Enum Types","url":"demos/uniswapv3/types/enum-types#tradetype","content":"Type of trade, either exact input or exact output enum TradeType { EXACT_INPUT EXACT_OUTPUT } Copy "},{"title":"Configure Polywrap build pipeline","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline","content":"","keywords":""},{"title":"Build pipeline","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#build-pipeline","content":"The build process begins by running the build command from the polywrap CLI. The command will first search for the Polywrap Manifest, find the wrapper schema and implementation, and move these files into a Docker image. Within the docker image, the wrapper schema is parsed and its contents are extracted into an ABI. The ABI is used to generate binding code for the wrapper. The wrapper is then compiled into a Wasm module. The ABI and the Polywrap Manifest are merged into a Wrap Manifest file called wrap.info. While the default build settings work well for many projects, the toolchain offers a highly configurable build pipeline for those who need more customization. "},{"title":"Build Manifest","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#build-manifest","content":"The Build Manifest polywrap.build.yaml file is the entry point to build pipeline configuration. "},{"title":"Declaration","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#declaration","content":"The location of the Build Manifest must be declared in your Polywrap Manifest with a field labeled build. If a custom build manifest is not declared, the default build configuration will be used. build: ./polywrap.build.yaml Copy "},{"title":"Content","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#content","content":"SchemaExampleDefault Configuration format: # Polywrap YAML Format version docker: # (Optional) Custom Docker configuration name: # (Optional) Docker image name dockerfile: # (Optional) Docker image file name buildx: # (Optional) Configuration options for Docker Buildx, set to true for default value. cache: # (Optional) Path to cache directory, set to true for default value, set to false to disable caching remove builder: # (Optional) Remove the builder instance removeImage: # (Optional) Remove the image config: # (Optional) Custom build image configurations node_version: # (Optional) Node version include: # (Optional) Files to include in build linked_packages: # (Optional) Array of locally linked packages into docker build image - name: # Package name path: # Path to linked package directory filter: # (Optional) Ignore files matching this regex in linked package directory Copy "},{"title":"Customizing the Dockerfile","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#customizing-the-dockerfile","content":"Those who need to fully customize the Docker image build steps can customize the Dockerfile. The Dockerfile is a text file containing instructions for Docker to build images. You can learn more about it at Docker's Dockerfile documentation. To begin, either copy the default Dockerfile from the .polywrap/wasm/build/image folder or create your own. Then, in the polywrap.build.yaml file, add a key called dockerfile with the path of the newly created Dockerfile as the value. That's it! Now, you can customize the Dockerfile to your heart's content. format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile Copy "},{"title":"Mustache support","type":1,"pageTitle":"Configure Polywrap build pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/build-pipeline#mustache-support","content":"Mustache is a logic-less template system that can be used for HTML, config files, and more. You can learn more about writing Mustache templates here. To enable Mustache capabilities for your Dockerfile, name your custom Dockerfile with a .mustache file extension: dockerfile: ./Dockerfile.mustache Copy With Mustache, your Dockerfile will be able to recognize variable tags set within the config field of the Build Manifest. For example, in your Build Manifest file, you could have a key such as foo with the value hey like so: format: 0.1.0 docker: name: build-env dockerfile: ./Dockerfile.mustache config: foo: hey Copy To use this variable in your Mustache-enabled Dockerfile, simply reference the variable with curly braces like so: {{ foo }} Copy "},{"title":"Query Types","type":0,"sectionRef":"#","url":"demos/uniswapv3/types/query-types","content":"","keywords":""},{"title":"AddLiquidityOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#addliquidityoptions","content":"Union of MintOptions and IncreaseOptions; one of either recipient or tokenId is required. type AddLiquidityOptions { recipient: String # The account that should receive the minted NFT. createPool: Boolean # Creates pool if not initialized before mint. Ignored if recipient is not null. tokenId: BigInt # Indicates the ID of the position to increase liquidity for. Ignored if recipient is not null. slippageTolerance: String! deadline: BigInt! useNative: Token token0Permit: PermitOptions token1Permit: PermitOptions } Copy "},{"title":"ClaimOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#claimoptions","content":"Options to specify when claiming rewards. type ClaimOptions { tokenId: BigInt! # The id of the NFT recipient: String! # Address to send rewards to. amount: BigInt # The amount of `rewardToken` to claim. 0 claims all. } Copy "},{"title":"CollectOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#collectoptions","content":"Options to specify when calling collectCallParameters(...) to collect liquidity provider rewards or removeCallParameters(...) to exit a liquidity position. type CollectOptions { tokenId: BigInt! # Indicates the ID of the position to collect for. Ignored when CollectOptions is as property of RemoveLiquidityOptions for use in removeCallParameters(...). expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned recipient: String! # The account that should receive the tokens. } Copy "},{"title":"CommonAddLiquidityOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#commonaddliquidityoptions","content":"Options for producing the calldata to add liquidity. type CommonAddLiquidityOptions { slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false token0Permit: PermitOptions # The optional permit parameters for spending token0 token1Permit: PermitOptions # The optional permit parameters for spending token1 } Copy "},{"title":"FullWithdrawOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#fullwithdrawoptions","content":"Options to specify when withdrawing tokens type FullWithdrawOptions { owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw. data: String # Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner. tokenId: BigInt! recipient: String! amount: BigInt } Copy "},{"title":"IncentiveKey","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#incentivekey","content":"Represents a unique staking program. type IncentiveKey { rewardToken: Token! # The token rewarded for participating in the staking program. pool: Pool! # The pool that the staked positions must provide in. startTime: BigInt! # The time when the incentive program begins. endTime: BigInt! # The time that the incentive program ends. refundee: String! # The address which receives any remaining reward tokens at `endTime`. } Copy "},{"title":"NextTickResult","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#nexttickresult","content":"Return value of nextInitializedTickWithinOneWord(...) type NextTickResult { index: Int32! # Tick index of returned next tick found: Boolean! # True if the returned tick index represents an initialized tick, or false if max or min tick are returned instead } Copy "},{"title":"NFTPermitOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#nftpermitoptions","content":"Permission parameters for NFT transfers, in case the transaction is being sent by an account that does not own the NFT type NFTPermitOptions { v: PermitV! r: String! s: String! deadline: BigInt! spender: String! } Copy "},{"title":"PoolChangeResult","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#poolchangeresult","content":"Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...) type PoolChangeResult { amount: TokenAmount! # input or output amount resulting from simulated swap nextPool: Pool! # Pool state after simulated swap } Copy "},{"title":"QuoteOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#quoteoptions","content":"Optional arguments to send to the quoter. type QuoteOptions { sqrtPriceLimitX96: BigInt # The optional price limit for the trade. } Copy "},{"title":"RemoveLiquidityOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#removeliquidityoptions","content":"Options for producing the calldata to exit a position. type RemoveLiquidityOptions { tokenId: BigInt! # The ID of the token to exit liquidityPercentage: String! # The percentage of position liquidity to exit. slippageTolerance: String! # How much the pool price is allowed to move. deadline: BigInt! # When the transaction expires, in epoch seconds. burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false. permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT collectOptions: CollectOptions! # Parameters to be passed on to collect; tokenId is ignored. } Copy "},{"title":"SafeTransferOptions","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#safetransferoptions","content":"Options to specify when calling safeTransferFrom(...) to transfer an NFT type SafeTransferOptions { sender: String! # The account sending the NFT. recipient: String! # The account that should receive the NFT. tokenId: BigInt! # The id of the token being sent. data: String # The optional parameter that passes data to the `onERC721Received` call for the staker } Copy "},{"title":"TradeRoute","type":1,"pageTitle":"Query Types","url":"demos/uniswapv3/types/query-types#traderoute","content":"Input used to create a trade type TradeRoute { route: Route! # The route of the trade amount: TokenAmount! # The amount being passed in or out, depending on the trade type } Copy "},{"title":"Deploy to IPFS","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs","content":"","keywords":""},{"title":"polywrap CLI","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"wrappers CLI","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#wrappers-cli","content":"wrappers is the deprecated (but working) prototype for the polywrap CLI's deploy command. It is a command-line tool for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. > Step-By-Step Guide "},{"title":"Fleek","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#fleek","content":"Fleek makes it easy to build websites and apps on the new open web. > Step-By-Step Guide "},{"title":"Pinata","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#pinata","content":"Pinata provides tools and infrastructure for all creators to easily create and manage content on IPFS. > Step-By-Step Guide "},{"title":"Crust Network","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#crust-network","content":"Crust Network provides a Web3.0 decentralized storage network for the Metaverse. > Step-By-Step Guide "},{"title":"Aleph","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#aleph","content":"Aleph allows your blockchain enabled app to securely access trusted off-chain data or computation within a couple lines of code. "},{"title":"Arweave","type":1,"pageTitle":"Deploy to IPFS","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-to-ipfs#arweave","content":"Arweave enables you to store documents and applications forever. "},{"title":"Deploying to CRUST Files","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrapper using the Crust Files. so that other apps could integrate it into their apps! "},{"title":"Table of Contents","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to Crust NetworkStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 👛 Metamask🥐 Crust Network🐳 Docker🧶Yarn Versions: node >=10.0.0 or yarn >=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git Copy "},{"title":"Step 2. Git pull metadata","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata Copy "},{"title":"Step 3. Build the wrapper","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build Copy "},{"title":"Step 4. Upload the build folder to Crust Network","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#step-4-upload-the-build-folder-to-crust-network","content":"Make sure you signin using a wallet Metamask.  Click Public  Click Upload   Upload the build folder then Click Upload   Click Sign and Upload   Your wallet will ask for a signature request Click Sign  The page should look like this:   "},{"title":"Step 5. Verifying the package on IPFS","type":1,"pageTitle":"Deploying to CRUST Files","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/crust#step-5-verifying-the-package-on-ipfs","content":"You will get an IPFS hash! This will lead you to IPFS link: https://gw.crustapps.net/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq?filename=build  🎉 Congratulations 🎉 on deploying using the Crust Files! "},{"title":"Configure Polywrap deployment pipeline","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline","content":"","keywords":""},{"title":"Declaration","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#declaration","content":"The location of the deployment manifest should be declared in your Polywrap Manifest polywrap.yaml with a field labeled deploy. deploy: ./polywrap.deploy.yaml Copy "},{"title":"Content","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#content","content":"The concents of a Deploy Manifest consists of one or more stages, each of which has some common fields and a set of configuration options particular to the module. The result of a stage can be passed as input to a later stage. SchemaExample format: # The manifest format version stages: # Each stage describes an event in the pipeline [name]: # Name of stage, set by the user package: # Deployment module uri: # The wrap URI of source content depends_on: # (Optional) Use prior stage's output config: # Configuration for the deployment module Copy "},{"title":"Deployment Modules","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#deployment-modules","content":"Polywrap currently supports three types of deployment modules: ipfs: pins a folder's contents to IPFS and returns the content hash (CID)ens: points an ENS domain to an IPFS content hashlocal-dev-ens: registers a domain on a local test environment and points the domain to an IPFS content hash "},{"title":"IPFS","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#ipfs","content":"The IPFS module pins a folder's contents to IPFS and returns the content hash (CID). It can be used to deploy a wrapper by pinning the contents of your project's build folder to the IPFS network. The IPFS module's custom configuration requires an IPFS gateway URI so the CLI knows where to send the files. Example: ipfs configuration config: gatewayUri: 'ipfs.wrappers.io' # IPFS gateway URI Copy "},{"title":"ENS","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#ens","content":"The ENS module accepts an IPFS content hash (CID) as input and points an ENS domain name to it. The ENS module's custom configuration requires three arguments and accepts an optional fourth: domainName: the ENS domain name owned by your Ethereum accountprovider: an Ethereum JSON RPC providerensRegistryAddress: the Ethereum address of the ENS Registry smart contractprivateKey: (optional) your Ethereum account's private key, used when the Ethereum provider cannot produce an account signer Example: ens configuration config: domainName: 'wrapper.eth' # ENS domain name provider: 'http://localhost:4545' # an Ethereum JSON RPC provider URI ensRegistryAddress: '0x...' # The ENS Registry contract address privateKey: '' # a private key may be required to sign ethereum transactions Copy "},{"title":"Local Dev ENS","type":1,"pageTitle":"Configure Polywrap deployment pipeline","url":"quick-start/build-and-deploy-wasm-wrappers/deploy-pipeline#local-dev-ens","content":"The Local Dev ENS module accepts an IPFS content hash (CID) as input, registers an ENS domain name, and points the domain name to the IPFS CID. The Local Dev ENS module was created with Polywrap's default test environment infrastructure in mind. tip Polywrap's default test environment can be started with the polywrap infra up CLI command and stopped with the polywrap infra down CLI command. The module assumes ENS infrastructure is set up on a local Ethereum network with the ENS smart contracts deployed at the following addresses: ENS Registry: 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8AbENS Resolver: 0x5b1869D9A4C187F2EAa108f3062412ecf0526b24ENS Registrar: 0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bbENS Reverse Lookup: 0xe982E462b094850F12AF94d21D470e21bE9D0E9C The Local Dev ENS module's custom configuration requires two arguments: domainName: the desired ENS domain name to be registeredports: contains the port of the local Ethereum test network Example: local-dev-ens configuration config: domainName: 'wrapper.eth' # ENS domain name ports: ethereum: 4545 Copy "},{"title":"Deploying to Fleek","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Fleek so that other apps could integrate it into their apps! "},{"title":"Table of Contents","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to FleekStep 5. Verifying the package on IPFS  "},{"title":"What is Fleek?","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#what-is-fleek","content":"Fleek is the easiest way to build, deploy, and host websites & apps on IPFSFleek provides one seamless workflow with everything you need to build fast, modern sites & web apps hosted on IPFS. "},{"title":"What you need to get started:","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js ⚡ Fleek🐳 Docker🧶Yarn Versions: node >=10.0.0 or yarn >=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git Copy "},{"title":"Step 2. Git pull metadata","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata Copy "},{"title":"Step 3. Build the wrapper","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build Copy Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Fleek","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#step-4--upload-the-build-folder-to-fleek","content":"Make sure you signup for a Fleek account. On the left-hand side menu of your Fleek. Account page, click on the \"Storage\" link.  Then, click \"Create Folder\" Example: Gm-Polywrap  Click Confirm to create the folder   Click the Folder After that, click \"Upload\"   Select the contents of your build folder onto Fleek.  Click Confirm.  tip Due to the current Filecoin deal size limitation, files are batched together across Fleek products and uploaded as one Filecoin So it might take 24-48 hours, depending on Fleek usage, for content to appear in ipfs "},{"title":"Step 5. Verifying the package on IPFS","type":1,"pageTitle":"Deploying to Fleek","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/fleek#step-5--verifying-the-package-on-ipfs","content":"Click the \"Verify on IPFS\" button. You will get an IPFS hash! For an example of what you should see, visit this IPFS link. Now that you have the IPFS hash, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. You can also register an ENS domain and have it resolved to this IPFS content. 🎉 Congratulations 🎉 on deploying to Fleek! "},{"title":"Deployment using the \"wrappers\" CLI","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#introduction","content":"In this 5 step guide, we'll walk you how to deploy your Polywrap wrapper using the CLI. so that other apps could integrate it into their apps! "},{"title":"Table of Contents","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to CLIStep 5. Verifying the package on IPFS  "},{"title":"What you need to get started:","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🖥️📦 CLI🐳 Docker🧶Yarn Versions: node >=10.0.0 or yarn >=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git Copy "},{"title":"Step 2. Git pull metadata","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata Copy "},{"title":"Step 3. Build the wrapper","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build Copy "},{"title":"Step 4. Upload the build folder to CLI","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#step-4--upload-the-build-folder-to-cli","content":"Upload build results to an IPFS node (default: dev-server's node) npx polywrap build --ipfs http://localhost:5001 Copy "},{"title":"Step 5.","type":1,"pageTitle":"Deployment using the \"wrappers\" CLI","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/wrappers-cli#step-5","content":"🎉 Congratulations 🎉 on deploying using the Polywrap CLI! "},{"title":"Publish to ENS","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/publish-to-ens","content":"","keywords":""},{"title":"polywrap CLI","type":1,"pageTitle":"Publish to ENS","url":"quick-start/build-and-deploy-wasm-wrappers/publish-to-ens#polywrap-cli","content":"The polywrap command-line tool has a deploy command for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. For more information, see Configure Polywrap deployment pipeline and the deploy command reference documentation. "},{"title":"wrappers CLI","type":1,"pageTitle":"Publish to ENS","url":"quick-start/build-and-deploy-wasm-wrappers/publish-to-ens#wrappers-cli","content":"wrappers is the deprecated (but working) prototype for the polywrap CLI's deploy command. It is a command-line tool for publishing Wasm wrappers to IPFS and ENS. IPFS publishing is done via a wrap-persistence-node endpoint. By default it publishes to the public https://ipfs.wrappers.io endpoint. > Step-By-Step Guide "},{"title":"The ENS App","type":1,"pageTitle":"Publish to ENS","url":"quick-start/build-and-deploy-wasm-wrappers/publish-to-ens#the-ens-app","content":"ENS App is a distributed, open, and extensible naming system based on the Ethereum blockchain. "},{"title":"Deploying to Pinata","type":0,"sectionRef":"#","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#introduction","content":"In this 5 step guide, we'll walk you through how to deploy your Polywrap wrapper to Pinata so that other apps could integrate it into their apps! "},{"title":"Table of Contents","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#table-of-contents","content":"Click to expand IntroductionWhat you need to get startedStep 1. Clone the polywrap demo projectStep 2. Pull the polywrap metadataStep 3. Build the wrapper Step 4. Upload the build folder to PinataStep 5. Verifying the package on IPFS  "},{"title":"What is Pinata?","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#what-is-pinata","content":"Pinata is building the largest pinning service on IPFS! Pinata gives users the ability to upload, manage, and share their content whenever, wherever and, with whomever they want. "},{"title":"What you need to get started:","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#what-you-need-to-get-started","content":"We'll be using the Polywrap Demos repo for this guide. 💚 Node. js 🪅 Pinata🐳 Docker🧶Yarn Versions: node >=10.0.0 or yarn >=1.0.0 🔸 Git "},{"title":"Step 1. Clone the polywrap demo project","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#step-1-clone-the-polywrap-demo-project","content":"git clone https://github.com/polywrap/demos.git Copy "},{"title":"Step 2. Git pull metadata","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#step-2-git-pull-metadata","content":"Then, we will check out the demo branch with the metafiles already set up: git pull origin polywrap-metadata Copy "},{"title":"Step 3. Build the wrapper","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#step-3-build-the-wrapper","content":"Now, we can build the sample wrapper with the following commands: nvm use yarn yarn build Copy Your build folder should be generated now. Copy and paste the ./polywrap.meta.yaml and ./meta files into the build folder. "},{"title":"Step 4. Upload the build folder to Pinata","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#step-4--upload-the-build-folder-to-pinata","content":"Make sure you signup for a Pinata account. Click \"Upload\"  Click \"Folder\"  Click Select for a folder to upload should be the build folder   Give your file or folder a name. Example: Gm-Polywrap  Click \"Upload\" from the alert message  "},{"title":"Step 5. Verifying the package on IPFS","type":1,"pageTitle":"Deploying to Pinata","url":"quick-start/build-and-deploy-wasm-wrappers/deployment/pinata#step-5--verifying-the-package-on-ipfs","content":"You will get an IPFS hash! Click the name of the folder   This will lead you to IPFS link:https://gateway.pinata.cloud/ipfs/QmVtFE8ScFUv6b4vUrfrNsEGuUunF4rFckjaRcDxb6xayq Now that you have the IPFS hash located in the CID column in the pinata manager, you can use it as a value in the URI property of your Polywrap queries to access the functions in this wrapper. 🎉 Congratulations 🎉 on deploying to Pinata! "},{"title":"Get Wrapper Metadata","type":0,"sectionRef":"#","url":"quick-start/create-js-app/get-wrapper-metadata","content":"Some application developers may be interested adding or retrieving wrapper metadata. Wrapper developers can add metadata to their wrappers by writing a Meta Manifest file. Application developers can obtain the Meta Manifest as an object or class in the client's native language. More information about the contents of the Meta Manifest can be found in Add Metadata. The client's getFile method can be used to retrieve a file from a wrapper. It uses the wrapper URI as the root path. const manifestString = await client.getFile(uri, { path: \"./polywrap.meta.json\", encoding: \"utf-8\" }) as string; const manifest: MetaManifest = JSON.parse(manifestString); Copy To obtain icons from paths listed in a wrapper's Meta Manifest, use getFile again. The return type of getFile will be a string if the encoding option is used, and an ArrayBuffer otherwise. const isBuffer = await client.getFile(uri, { path: manifest.icon }); const isString = await client.getFile(uri, { path: manifest.icon, encoding: \"utf-8\" }); Copy We wrote a React app to demo fetching and displaying wrapper metadata.You can view the source code here.","keywords":""},{"title":"Creating the Polywrap client instance","type":0,"sectionRef":"#","url":"quick-start/create-js-app/create-client-instance","content":"Once the Polywrap JS client has been installed, the next step is to create a PolywrapClient instance: import { PolywrapClient } from \"@polywrap/client-js\"; const client = new PolywrapClient(); Copy At this point, you can already invoke wrappers. In the simple example below, we send one to the \"hello world\" wrapper. client.invoke({ uri: \"ens/rinkeby/helloworld.dev.polywrap.eth\", method: \"logMessage\", args: { message: \"Hello World!\" } }); Copy","keywords":""},{"title":"Installing the Polywrap JS client","type":0,"sectionRef":"#","url":"quick-start/create-js-app/install-client","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Installing the Polywrap JS client","url":"quick-start/create-js-app/install-client#introduction","content":"If you're a JavaScript developer building Browser, Node.js, or React based apps, this guide is for you. tip In the future, JavaScript will be one of many supported languages. Our goal is to enable the use of Polywrap in every major programming language. By the end of this document, you'll gain the following skills: How to instantiate the Polywrap client in your JavaScript AppInvoke any wrapper using the Polywrap clientConfigure custom Polywrap URI redirectsBuild React apps with ease If you get stuck during this guide, send us a message on our Discord! "},{"title":"Prerequisites","type":1,"pageTitle":"Installing the Polywrap JS client","url":"quick-start/create-js-app/install-client#prerequisites","content":"As prerequisites for this guide, we recommend having familiarity with TypeScript. React will also be used in the latter sections. "},{"title":"Installation","type":1,"pageTitle":"Installing the Polywrap JS client","url":"quick-start/create-js-app/install-client#installation","content":"To use wrappers in your app, all you need is the Polywrap Client! npm install --save @polywrap/client-js Copy The Polywrap JavaScript Client works in both Node.js, and browser applications. "},{"title":"Examples","type":1,"pageTitle":"Installing the Polywrap JS client","url":"quick-start/create-js-app/install-client#examples","content":"Some example projects that integrate the JS client can be found here. The next section assumes that you're integrating Polywrap into an existing app project. If you want a quick start with our template project, simply run: npx polywrap create app typescript-react <project-name> Copy Where <project-name> is replaced with a custom name of your choosing. For example my-wrapper. This command will create a new project folder with a \"Hello World\" app that lets you interact with a simple Wasm wrapper at ens/rinkeby/helloworld.dev.polywrap.eth. "},{"title":"React integration","type":0,"sectionRef":"#","url":"quick-start/create-js-app/react-integration","content":"","keywords":""},{"title":"PolywrapProvider","type":1,"pageTitle":"React integration","url":"quick-start/create-js-app/react-integration#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () => { return ( <PolywrapProvider> <HelloWorld /> </PolywrapProvider> ); }; Copy PolywrapProvider Props# The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: <PolywrapProvider redirects={ [] }/> Copy Multiple PolywrapProviders# If you need to use multiple providers, you can do so using the createPolywrapProvider(\"...\") method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) => { return ( <CustomPolywrapProvider> {children} </CustomPolywrapProvider> ); }; Copy "},{"title":"usePolywrapClient","type":1,"pageTitle":"React integration","url":"quick-start/create-js-app/react-integration#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient(); Copy "},{"title":"usePolywrapInvoke","type":1,"pageTitle":"React integration","url":"quick-start/create-js-app/react-integration#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wrappers! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/api.helloworld.polywrap.eth', method: \"logMessage\", args: { message: \"Hello World!\", }, }); Copy tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, errors, loading } = usePolywrapInvoke({ provider: \"custom\", uri: 'ens/api.helloworld.polywrap.eth', method: \"logMessage\", args: { message: \"Hello World!\", }, }); Copy "},{"title":"usePolywrapQuery","type":1,"pageTitle":"React integration","url":"quick-start/create-js-app/react-integration#usepolywrapquery","content":"The usePolywrapQuery hook works the same as the usePolywrapInvoke hook, but uses the client's query syntax instead. const { execute, data, errors, loading } = usePolywrapQuery({ uri: 'ens/api.helloworld.polywrap.eth', query: `{ logMessage(message: \"Hello World!\") }`, }); Copy "},{"title":"Plugin an existing JS SDK","type":0,"sectionRef":"#","url":"quick-start/create-plugin-wrappers/create-js-plugin","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#introduction","content":"In this guide, we'll walk you through creating your own JavaScript-based plugin wrapper that can be added to the JavaScript Polywrap Client. caution Plugins do not retain all of Polywrap's benefits. We recommend re-writing your existing JavaScript SDKs as Wasm wrappers if possible. As always, if you need any help, message us on Discord! "},{"title":"Prerequisites","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#prerequisites","content":"You'll need the following installed before building your plugin: nvmyarn You'll be using TypeScript to implement your Polywrap plugin. tip In the future, TypeScript will be one of many supported languages for implementing plugins. As more Polywrap Clients are released in various languages, implementing plugins in those languages will be supported as well. "},{"title":"Getting started","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#getting-started","content":"To get started, use the following command to spin up a project folder for your plugin. npx polywrap create plugin typescript <project-name> Copy Where <project-name> is replaced with a custom name of your choosing. For example my-plugin. Once complete, you'll see a new folder appear, named after the custom name you've chosen. Please navigate into this new directory (using cd for example). "},{"title":"Installation","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#installation","content":"Let's ensure all of your project's dependencies are installed. From inside your project's directory, simply run: nvm install && nvm useyarn "},{"title":"Overview of project files","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#overview-of-project-files","content":"Your project should look something like this: polywrap.plugin.yaml # Plugin Manifest src/ | index.ts # Entry File │ schema.graphql # Schema Copy "},{"title":"polywrap.plugin.yaml","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#polywrappluginyaml","content":"The Plugin Manifest describes the layout of a plugin. "},{"title":"schema.graphql","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the plugin's logic. Learn more about the plugin's code architecture by reading Plugin Architecture "},{"title":"Building the plugin","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#building-the-plugin","content":"To build your plugin, all you need is the following command: yarn build # alias for \"npx polywrap build\" Copy "},{"title":"Example Plugins","type":1,"pageTitle":"Plugin an existing JS SDK","url":"quick-start/create-plugin-wrappers/create-js-plugin#example-plugins","content":"For inspiration, please refer to these existing JavaScript plugins: Sample PluginToolchain PluginsDemo PluginsIntegration Plugins "},{"title":"Configure a Plugin Manifest","type":0,"sectionRef":"#","url":"quick-start/create-plugin-wrappers/plugin-manifest","content":"","keywords":""},{"title":"Content","type":1,"pageTitle":"Configure a Plugin Manifest","url":"quick-start/create-plugin-wrappers/plugin-manifest#content","content":"The Plugin Manifest contains the name of the plugin, programming language used to write the plugin, the location of the plugin's entry file (i.e. the file that exports the plugin contents), and the GraphQl schema that declares the plugin's interface. It can optionally contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # (Optional) Name of plugin language: # Plugin programming language module: # Entry file schema: # Wrapper schema import_redirects: # Array of URI redirects - uri: # Source URI to be redirected schema: # Path to schema of the module to which URI will be redirected Copy "},{"title":"Plugin Architecture","type":0,"sectionRef":"#","url":"quick-start/create-plugin-wrappers/plugin-architecture","content":"","keywords":""},{"title":"Required Exports","type":1,"pageTitle":"Plugin Architecture","url":"quick-start/create-plugin-wrappers/plugin-architecture#required-exports","content":"A plugin must export a PluginFactory to be used by the Polywrap Client. A PluginFactory is a function that returns a PluginPackageManifest and a factory method that generates an instance of the plugin. "},{"title":"TypeScript Support","type":1,"pageTitle":"Plugin Architecture","url":"quick-start/create-plugin-wrappers/plugin-architecture#typescript-support","content":"The Polywrap CLI's plugin and build commands will generate a wrap folder containing useful types. The generated types will save you time and energy. You won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs. You can forget about boilerplate code and focus on your plugin's logic. While the types are not strictly required, we recommend them as a best practice. The generated types include: Module - An interface containing the methods declared in the plugin's schemaArgs_* - An interface for each method, containing the method arguments declared in the schemaCustom Types - An interface for each custom type declared in the schemamanifest - A PluginPackageManifest for the plugin (also useful for JavaScript developers!) "},{"title":"Example","type":1,"pageTitle":"Plugin Architecture","url":"quick-start/create-plugin-wrappers/plugin-architecture#example","content":"import { Module, Args_sampleMethod, manifest } from \"./wrap\"; // imports from generated \"wrap\" folder import { PluginFactory } from \"@polywrap/core-js\"; // plugin must export a PluginFactory export interface SamplePluginConfig { defaultValue: string; } export class SamplePlugin extends Module<SamplePluginConfig> { // Plugin inherits from Module constructor(config: SamplePluginConfig) { super(config); } public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument return args.data + this.config.defaultValue; } } export const samplePlugin: PluginFactory<SamplePluginConfig> = ( // exported PluginFactory is used by Polywrap client config: SamplePluginConfig ) => { return { factory: () => new SamplePlugin(config), // factory method produces a Module manifest, // imported from ./wrap }; }; export const plugin = samplePlugin; // PluginFactory is exported with name \"plugin\" Copy "},{"title":"Add Metadata","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/add-metadata","content":"","keywords":""},{"title":"Declaration","type":1,"pageTitle":"Add Metadata","url":"quick-start/create-wasm-wrappers/add-metadata#declaration","content":"Its location must be referenced in the Polywrap Manifest with a field labeled meta. meta: ./polywrap.meta.yaml Copy "},{"title":"Content","type":1,"pageTitle":"Add Metadata","url":"quick-start/create-wasm-wrappers/add-metadata#content","content":"The Meta Manifest contains titles, descriptions, images, tags, and links that application developers can display when presenting or discussing your wrapper. SchemaExample format: # The manifest format version displayName: # (Optional) Name of the wrapper that users should use for presentation subtext: # (Optional) Subtext of display name; brief description of the wrapper description: # (Optional) Detailed description repository: # (Optional) Repository URL icon: # (Optional) Path to wrapper icon or log tags: # (Optional) Array of terms that can help find your wrapper in search links: # (Optional) Array of links relevant to your wrapper - name: # Name of link icon: # (Optional) Icon associated with link url: # (Optional) Link URL Copy "},{"title":"Default plugins","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/default-plugins","content":"","keywords":""},{"title":"Import to schema","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#import-to-schema","content":"We'll use one of the default plugins, Ethereum, to show how you can import its modules into your wrapper's schema (schema.graphql file). #import { Module, Connection } into Ethereum from \"wrap://ens/ethereum.polywrap.eth\" Below, we explain what each part of this code means. #import Imports specific modules from a deployed or local plugin { Module, Connection } These are specific modules that we're unpacking from the one of Polywrap's default plugins, Ethereum. into Ethereum This is a namespace, enabling you to use the modules in your schema e.g. Ethereum_Module or Ethereum_Connection from \"wrap://ens/ethereum.polywrap.eth\" wrap:// is the Polywrap URI schema.ens is the URI authority. It tells the Polywrap client what kind of URI it needs to resolve. The ens authority tells the Polywrap client that what follows is an ENS address that resolves to a decentralized storage hosting a wrapper. Other valid authorities include ipfs for IPFS content hashes, fs for wrappers located on your local filesystem (often used while testing wrappers), or a custom authority that may be handled by a custom URI resolver.ethereum.polywrap.eth is the URI path, which in this case is an ENS address.Note: The client redirects queries from the URI of a plugin wrapper to the plugin object that exists in memory. While plugins typically use an ENS URI for readability, the client does not need to query the ENS registry or an external storage location. See our section on URI redirects for more information. "},{"title":"Use in Wasm Wrapper","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#use-in-wasm-wrapper","content":"Once types have been imported, the functionality of these imported modules can be used in wrapper development. Upon yarn build, the imported types and modules will be made available to you in the src/wrap folder. To use them, you simply need to import the specific modules that you'd like to use. If you're building an AssemblyScript-based wrapper, the import might look like this: import { Ethereum_Module, Ethereum_Connection } from './wrap'; Copy The Ethereum_Module will contain the methods shown here, under the Module type. Once imported, you can access methods like so: Ethereum_Module.callContractMethod({ ... }) "},{"title":"Commonly used default plugins","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#commonly-used-default-plugins","content":"This section contains guides on commonly used default plugins: Ethereum, Subgraph, HTTP, and Logger. "},{"title":"Ethereum","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#ethereum","content":"The Ethereum plugin enables wrappers to query the ethereum blockchain. Schema: Link Example: export function getData(input: Input_getData): u32 { const res = Ethereum_Module.callContractView({ address: input.address, method: 'function get() view returns (uint256)', args: null, connection: input.connection, }).unwrap(); return U32.parseInt(res); } Copy "},{"title":"Subgraph","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#subgraph","content":"The subgraph plugin enables wrappers to query The Graph's subgraphs. Schema: Link Example Implementation:# In our ./src/schema.graphql file, we'll write the schema for our wrapper. At the top of this file, import the GraphNode module into your wrapper: #import { Module } into GraphNode from \"wrap://ens/graph-node.polywrap.eth\" Copy Then, define the types and fields on the querySubgraph method.  querySubgraph( subgraphAuthor: String! subgraphName: String! query: String! ): JSON! Copy We'll now implement the querySubgraph method in AssemblyScript. At the top of index.ts, include these import statements: import { GraphNode_Module, Args_querySubgraph } from './wrap'; import { JSON } from '@polywrap/wasm-as'; Copy Then, implement the querySubgraph method: export function querySubgraph(args: Args_querySubgraph): JSON.Value { const response = GraphNode_Module.querySubgraph({ subgraphAuthor: args.subgraphAuthor, subgraphName: args.subgraphName, query: args.query, }).unwrap(); const json = JSON.parse(response); const obj = json as JSON.Obj; return obj.valueOf().get('data') as JSON.Value; } Copy Example query to test your method: subgraphAuthor: 'ensdomains', subgraphName: 'ens', query: '{\\ndomains(first: 5){\\nid\\nname\\nlabelName\\nlabelhash\\n}\\n}', Copy "},{"title":"HTTP","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#http","content":"The HTTP plugin enables wrappers to perform HTTP queries in JavaScript applications. Schema: Link Example Implementation# In this example, we will implement a simple Ping method which pings CoinGecko to see their server status using an HTTP Get request from your wrapper. In our ./src/schema.graphql file, we’ll write the schema for our wrapper. At the top of this file, import the HTTP module into your wrapper: #import { Module, Request, Response } into HTTP from \"wrap://ens/http.polywrap.eth\" Copy Then, define the types and fields on the Ping method. First, add a new Ping type at the bottom of the schema. type Ping { gecko_says: String! } Copy Then, add an argument-less method called ping that returns a non-nullable Ping to the Module type. Our completed schema looks like this: #import { Module, Request, Response } into HTTP from \"wrap://ens/http.polywrap.eth\" type Module { ping: Ping! } type Ping { gecko_says: String! } Copy Now, we'll implement the ping method in ./src/index.ts At the top of the file, we'll import the HTTP/Ping methods and types. import { HTTP_Module, HTTP_ResponseType, Ping, } from './wrap'; Copy Then, implement Ping function: export function ping(): Ping { // Writing the HTTP request / response const response = HTTP_Module.get({ url: 'https://api.coingecko.com/api/v3/ping', request: { headers: [], urlParams: [], body: '', responseType: HTTP_ResponseType.TEXT, }, }).unwrap(); // Error handling for the response if (!response || response.status !== 200 || !response.body) { const errorMsg = response && response.statusText ? (response.statusText as string) : 'An error occurred while fetching data from Coingecko API'; throw new Error(errorMsg); } const json = <JSON.Obj>JSON.parse(response.body); // Response from Coingecko with field `geckoSays` const geckoSays = json.getString('gecko_says'); if (geckoSays) { return { gecko_says: geckoSays.valueOf(), }; } throw new Error('Invalid response body!'); } Copy "},{"title":"Logger","type":1,"pageTitle":"Default plugins","url":"quick-start/create-wasm-wrappers/default-plugins#logger","content":"The Logger plugin enables logging in a Wasm wrapper, which can be useful for debugging. In our ./src/schema.graphql file, import the Logger module into your wrapper: #import { Module } into Logger from \"wrap://ens/js-logger.polywrap.eth\" Copy Then in your implementation file ./src/index.ts, import the Logger function: import { Logger_Module, Logger_Logger_LogLevel, } from './wrap'; Copy And use it like so:  Logger_Module.log({ level: Logger_Logger_LogLevel.INFO, message: `Insert useful log message here`, }); Copy When you run your test e.g. yarn test:e2e, you will see the logged message in the console. "},{"title":"Configure a Polywrap Manifest","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/polywrap-manifest","content":"","keywords":""},{"title":"Content","type":1,"pageTitle":"Configure a Polywrap Manifest","url":"quick-start/create-wasm-wrappers/polywrap-manifest#content","content":"The Polywrap Manifest contains the name of the wrapper, programming language used to write it, and the location of the wrapper schema that declares the wrapper's interface. It optionally includes a path to the wrapper's entry file (e.g. src/index.ts, src/lib.rs) and paths to other manifests that can be used to configure the build and deploy process. It can also contain an array of URI Redirects. SchemaExample format: # The manifest format version name: # Name of wrapper language: # Wrapper programming language schema: # Path to wrapper schema module: # (Optional) Path to entry file build: # (Optional) Path to Build Manifest file meta: # (Optional) Path to Meta Manifest file deploy: # (Optional) Path to wrapper Deploy Manifest file import_redirects: # (Optional) Array of URI redirects - uri: # Source URI to be redirected schema: # Path to schema of the module to which URI will be redirected Copy "},{"title":"Adding new Methods","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods","content":"","keywords":""},{"title":"Custom functionality: IPFS SimpleStorage","type":1,"pageTitle":"Adding new Methods","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods#custom-functionality-ipfs-simplestorage","content":"It's time to build and customize your own Polywrap Wasm wrapper! We'll be adding IPFS support to the SimpleStorage API. "},{"title":"Update the schema","type":1,"pageTitle":"Adding new Methods","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods#update-the-schema","content":"The first step to adding new wrapper functionality is defining the method we want our users to invoke. Add the following method & custom data types to your ./src/schema.graphql schema file: ./src/schema.graphql type Module { ... setIpfsData( options: SetIpfsDataOptions! connection: Ethereum_Connection ): SetIpfsDataResult! } type SetIpfsDataOptions { address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! } Copy "},{"title":"Import IPFS' Polywrap wrapper","type":1,"pageTitle":"Adding new Methods","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods#import-ipfs-polywrap-wrapper","content":"Since we'll be making use of IPFS in our Wasm wrapper, let's import the IPFS plugin wrapper. Then we will be able to call its methods from our code, allowing us to upload content: ./src/schema.graphql #import { Module } into Ipfs from \"wrap://ens/ipfs.polywrap.eth\" type Module { ... Copy "},{"title":"Implement the setIpfsData method","type":1,"pageTitle":"Adding new Methods","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods#implement-the-setipfsdata-method","content":"In the ./src/index.ts file, import the new types we've defined: ./src/index.ts import { Ethereum_Module, Args_deployContract, Args_setData, Args_getData, Ipfs_Module, Args_getIpfsData, Args_setIpfsData, SetIpfsDataResult, } from \"./wrap\"; Copy These new types will not exist yet, but don't worry, they'll be generated in the ./src/wrap/* folder once the yarn build command is run. Next, we'll implement the setIpfsData method. Add this function to the bottom of your ./src/index.ts file: ./src/index.ts export function setIpfsData(args: Args_setIpfsData): SetIpfsDataResult { // 1. Upload the data to IPFS const ipfsHash = Ipfs_Module.addFile({ data: String.UTF8.encode(args.options.data), }).unwrap(); // 2. Add the data's IPFS hash to SimpleStorage using `setHash(...)` const txReceipt = Ethereum_Module.callContractMethodAndWait({ address: args.options.address, method: 'function setHash(string value)', args: [ipfsHash], connection: args.connection, txOverrides: null, }).unwrap(); // 3. Return the result return { ipfsHash, txReceipt: txReceipt.transactionHash, }; } Copy As you can see, the SimpleStorage.sol smart contract already exposes a setHash() method. In steps 1 and 2, our SimpleStorage Wasm wrapper is sending a \"sub-invocation\" to the IPFS and Ethereum plugin wrappers we imported in our schema. Wrappers can be implemented as a WebAssembly-based wrapper, or a plugin wrapper in the client's language (ex: JavaScript). For more information on plugins, see the \"Plugin an Existing JS SDK\" documentation. The Ethereum_Module.callContractMethodAndWait function also accepts an optional argument, connection. This option allows you to select the network which you're transacting with, by specifying a node's endpoint, or a network (name or chain ID) (e.g. \"rinkeby\"). To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Adding more methods","type":1,"pageTitle":"Adding new Methods","url":"quick-start/create-wasm-wrappers/tutorial/adding-new-methods#adding-more-methods","content":"With our first method implementation complete, it's now time to add more. The steps are the same as above. Update the ./src/schema.graphql file like so: ./src/schema.graphql type Module { ... getIpfsData( address: String! connection: Ethereum_Connection ): String! ... } Copy Implement the getIpfsData(...) method like so in ./src/index.ts: ./src/index.ts export function getIpfsData(args: Args_getIpfsData): string { const hash = Ethereum_Module.callContractView({ address: args.address, method: 'function getHash() view returns (string)', args: null, connection: args.connection }).unwrap(); return String.UTF8.decode( Ipfs_Module.cat({ cid: hash, options: null }).unwrap() ); } Copy To verify everything is implemented correctly, try running yarn build and see if the Polywrap build succeeds. "},{"title":"Deploy locally & run tests","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/deploy-locally-and-test","content":"","keywords":""},{"title":"Deploy","type":1,"pageTitle":"Deploy locally & run tests","url":"quick-start/create-wasm-wrappers/tutorial/deploy-locally-and-test#deploy","content":"With our workflow complete, let's test the Wasm wrapper on our local environment! First, let's set up our test environment with the following command in your terminal: yarn test:env:up Copy tip This command starts up a test environment with a local Ethereum network using Ganache, an ENS smart contract, and a local IPFS node. To close the test environment, simply run: yarn test:env:down Copy Next, we will deploy our both our SimpleStorage.sol smart contract as well as our wrapper with the following command: yarn deploy Copy tip Behind the scenes, yarn deploy will run the following commands: yarn deploy:api && yarn deploy:contract Copy Let's break down each of these commands, starting with yarn deploy:api, which itself runs this command: npx polywrap deploy Copy The polywrap CLI's deploy command executes a deployment pipeline defined in a polywrap.deploy.yaml manifest. Our deployment pipeline builds and deploys our wrapper to our local test environment. The wrapper is assigned to an Ethereum Name Service (ENS) domain registered in the test environment that is set to resolve to our local IPFS node. We next deploy the SimpleStorage smart contract to the Ethereum test network using a script we've written for you: node ./scripts/deploy-contract.js Copy We'll be interacting with this deployed smart contract using our Wasm wrapper. "},{"title":"Test","type":1,"pageTitle":"Deploy locally & run tests","url":"quick-start/create-wasm-wrappers/tutorial/deploy-locally-and-test#test","content":"Now, we'll use the following command to check whether our wrapper and smart contract are working properly: yarn test:workflow Copy This command uses the Polywrap CLI's run command, which will execute a series of Polywrap invocations and return the result to you. "},{"title":"Conclusion","type":1,"pageTitle":"Deploy locally & run tests","url":"quick-start/create-wasm-wrappers/tutorial/deploy-locally-and-test#conclusion","content":"🎉 Congratulations! You've create a custom Wasm wrapper! Hopefully this article has given you a clear understanding of the Polywrap toolchain's primary features. If at any time in this process you get stuck or have questions, please don't hesitate to reach out on Discord. "},{"title":"Build, deploy and test","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/build-deploy-test","content":"","keywords":""},{"title":"Build","type":1,"pageTitle":"Build, deploy and test","url":"quick-start/create-wasm-wrappers/tutorial/build-deploy-test#build","content":"Let's start building our project! Simply run: yarn build Copy In the output window, you'll see that our smart contract was compiled, and our Polywrap wrapper was built and output to the ./build/* folder. It contains the following files: build/ |── wrap.wasm # Wrapper Logic └── wrap.info # Wrapper Manifest Copy This directory's contents will be uploaded to decentralized storage, and enable any Polywrap Client to download, and execute your wrapper's functionality within the application. The wrap.wasm file is the WebAssembly file that was compiled from AssemblyScript. Lastly, the wrap.info file describes the layout of the package, as well as its methods and custom types. "},{"title":"Deploy","type":1,"pageTitle":"Build, deploy and test","url":"quick-start/create-wasm-wrappers/tutorial/build-deploy-test#deploy","content":"To deploy our Polywrap wrapper and associated smart contracts for testing, let's first setup a test environment. Simply run: yarn test:env:up Copy This will stand-up an Ethereum node, as well as an IPFS node. tip In the future, test environments will be easily configurable to include any nodes your Polywrap wrapper requires. Next, let's deploy the SimpleStorage.sol smart contract, and the simplestorage.eth wrapper URI by running: yarn deploy Copy "},{"title":"Test","type":1,"pageTitle":"Build, deploy and test","url":"quick-start/create-wasm-wrappers/tutorial/build-deploy-test#test","content":"With our Polywrap wrapper live at simplestorage.eth on our test network, it's now time to test it out! This is where our workflows come in handy. Run yarn test to see this in action. In the output window, you'll see a combination of jobs and returned results from the Polywrap wrapper. In this workflow, we send a combination of setData and getData queries which modify the SimpleStorage.sol contract's stored value. Now that we've built the SimpleStorage Wasm wrapper, let's add custom functionality to it in the next section! "},{"title":"The Polywrap project folder","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/project-folder","content":"","keywords":""},{"title":"polywrap.yaml","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#polywrapyaml","content":"The polywrap.yaml is a manifest file describing the layout of a Polywrap Wasm wrapper. "},{"title":"schema.graphql","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#schemagraphql","content":"Each wrapper project has a Wrapper Schema. The schema defines the wrapper's dependencies, methods, and custom types. In short, it's an interface describing how to use the wrapper. "},{"title":"src/index.ts","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#srcindexts","content":"The index.ts file exports the wrapper's method's implementations, which contain the wrapper's logic. "},{"title":"src/contracts/*","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#srccontracts","content":"The src/contracts directory contains our protocol's Ethereum-based smart contracts. "},{"title":"workflows/*","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#workflows","content":"Workflows provide a simple way to test your Polywrap without having to write custom testing logic (with JavaScript and Jest, for example). We'll be using this functionality further down in this guide with the polywrap run command, allowing us to easily send test queries against our API. "},{"title":"scripts/*","type":1,"pageTitle":"The Polywrap project folder","url":"quick-start/create-wasm-wrappers/tutorial/project-folder#scripts","content":"We've defined some simple build & deployment scripts for our Solidity smart contracts. These are basic utilities, and can be replaced entirely by a Truffle or Hardhat project. In the next section, we'll build this example Wasm wrapper and see what gets outputted in the build folder! "},{"title":"Project setup","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/project-setup","content":"","keywords":""},{"title":"Prerequisites","type":1,"pageTitle":"Project setup","url":"quick-start/create-wasm-wrappers/tutorial/project-setup#prerequisites","content":"You'll need the following installed before building your wrapper: nvmyarndockerdocker-compose You'll be using AssemblyScript to implement your wrapper's logic. AssemblyScript compiles to WebAssembly. tip For now, AssemblyScript and Rust are the only languages with which you can implement your wrapper. In the future, we will support additional languages that compile to WebAssembly, such as Go. If you have experience programming in TypeScript, you'll feel at home with AssemblyScript since the language's syntax is very similar. 👋 This guide is meant for those who want to build and deploy their own wrappers. If you're interested in integrating deployed wrappers into your own app, see our Integrate into a JS App guide. "},{"title":"Create your project","type":1,"pageTitle":"Project setup","url":"quick-start/create-wasm-wrappers/tutorial/project-setup#create-your-project","content":"Let's begin by downloading the Polywrap demos repository, which contains the SimpleStorage Wasm wrapper we will be using in this guide: git clone https://github.com/polywrap/demos.git Copy From the root of this new directory, navigate to simple-storage/wrapper/assemblyscript. tip The best way to start a new wrapper project is with a project template generated using our CLI. npx polywrap create api assemblyscript <project-name> Copy Where <project-name> is replaced with a custom name of your choice. For example my-wrapper. After running this command, you'll see a new folder appear with the custom name you've chosen. The folder will contain everything you need to get started! "},{"title":"Installation","type":1,"pageTitle":"Project setup","url":"quick-start/create-wasm-wrappers/tutorial/project-setup#installation","content":"Let's ensure all of your project's dependencies are installed. From inside the project's directory, simply run: nvm install && nvm useyarn The Polywrap CLI is now installed locally to your project's directory. Going forward we'll use this local installation by running npx polywrap. We recommend not installing the polywrap package globally to avoid future version conflicts, and maximize reproducibility for the other developers you're working with. Let's head over to the next section to see what's in this new directory! "},{"title":"Writing tests with workflows","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/tutorial/writing-tests-with-workflows","content":"","keywords":""},{"title":"Testing","type":1,"pageTitle":"Writing tests with workflows","url":"quick-start/create-wasm-wrappers/tutorial/writing-tests-with-workflows#testing","content":"In order to test this new functionality, we'll update the existing ./workflows/e2e.yaml workflow file to include the new methods we've added (setIpfsData, and getIpfsData). Add the following case to the e2e.yaml workflow in the ./workflows folder. ./workflows/e2e.yaml case2: steps: - uri: fs/build method: setIpfsData input: options: address: \"$cases.0.data\" data: \"Hello from IPFS!\" - uri: fs/build method: getIpfsData input: address: \"$cases.0.data\" Copy Once our workflow has been defined, we may want to be able to validate our actual results against our expectations. Workflow validation uses CUE, a flexible and expressive data validation language. CUE must be installed to complete this step. If you don't want to install anything right now, don't worry! Our results will be easy to verify with manually. To continue with automated testing, let's add our expected output to a new file in the workflows folder. We will call the file validator.cue. ./workflows/validator.cue package e2e case1: { $0: { data: 100, error?: _|_, } }, case2: { $0: { data: \"QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis\", error?: _|_, } } Copy With our workflow complete, we'll deploy and test our Wasm wrapper locally in the next section! "},{"title":"Case study: Uniswap v3 Wrapper","type":0,"sectionRef":"#","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap","content":"","keywords":""},{"title":"Project scaffolding","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#project-scaffolding","content":"The best way to set up a Polywrap project is to start with one of the project templates available in the Polywrap CLI. The polywrap create command lets you bootstrap your project structure without effort. The initial project setup includes a mutation folder and a query folder within src, which correspond to the two types of modules a wrapper can have. It also includes a polywrap.yaml manifest file, a polywrap.build.yaml Build Manifest file, and a polywrap.meta.yaml Meta Manifest file. The polywrap.yaml manifest tells the Polywrap CLI what language your wrapper is in, where your module schemas are located, and more. Our polywrap.yaml looked like this: format: 0.0.1-prealpha.5 build: ./polywrap.build.yaml meta: ./polywrap.meta.yaml language: wasm/assemblyscript modules: mutation: schema: ./src/mutation/schema.graphql module: ./src/mutation/index.ts query: schema: ./src/query/schema.graphql module: ./src/query/index.ts Copy The Build Manifest lets you customize the build process. The Meta Manifest lets you add meta-data to your project, like a description and a link to your repo. For the Uniswap v3 wrapper, we left the polywrap.yaml manifest and the Build Manifest unchanged. We added detail to the Meta Manifest much later, when wrapper development was largely complete. "},{"title":"Writing the interface in a GraphQL Schema","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#writing-the-interface-in-a-graphql-schema","content":"We started by reading through the entire Uniswap v3 JavaScript SDK repo on GitHub to record all the types and methods we would reproduce, and to take note of their interactions. The interface of a Polywrap API is declared in a GraphQL schema. We wrote a schema type for each externally-facing class in the SDK, with properties that matched those in the class with public access. We wrote a method declaration in the schema for each externally-facing function and class method in the SDK. We even copied over the SDK's inline documentation to fill the schema with context. #An abridged look at our schema \"\"\"ERC20-compliant token or Ether\"\"\" type Token { \"\"\"Id of chain where token exists\"\"\" chainId: ChainId! \"\"\"Address of token's ERC20 contract\"\"\" address: String! \"\"\"Token description\"\"\" currency: Currency! } type Query { \"\"\"Returns true if the tokens are equivalent, false otherwise\"\"\" tokenEquals( tokenA: Token! tokenB: Token! ): Boolean! \"\"\"Returns true if the address of tokenA would precede the address of token B when sorted alphabetically\"\"\" tokenSortsBefore( tokenA: Token! tokenB: Token! ): Boolean! } Copy A wrapper can have two modules: a query module and a mutation module. Each module has its own schema that, along with a an optional common schema for shared types, are combined at build time. The difference between mutations and queries is simple: mutations modify state--this typically means blockchain state in web3 applications--while queries do not. The Uniswap v3 SDK does not modify on-chain state, so all of its functionality was placed in the query module schema. The first draft of the Uniswap v3 wrapper's schema was written in just a few hours, though it was revised during development to fix mistakes and improve the user experience. "},{"title":"Implementing the first functions","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#implementing-the-first-functions","content":"When porting an SDK, it's important to understand its project structure. The organization of the SDK's source code can indicate how wrapper development should proceed. Development should allow for iterative changes and testing. The Unsiwap v3 SDK can be mentally modularized into a roughly linear set of dependent components. We can start with the concept of a Token, which is the component of a CurrencyAmount and a Pool. A Route is a set of pools and currencies. A Trade is constructed from two currency amounts and one or more routes. Based on this pattern, it made sense for us to start with Token. In Uniswap's JavaScript SDK, Token has properties like chainId and address, as well as two class methods: equals and sortsBefore. // Methods found in the Token class in Uniswap's SDK Core package public equals(other: Currency): boolean { return other.isToken && this.chainId === other.chainId && this.address === other.address } public sortsBefore(other: Token): boolean { invariant(this.chainId === other.chainId, 'CHAIN_IDS') invariant(this.address !== other.address, 'ADDRESSES') return this.address.toLowerCase() < other.address.toLowerCase() } Copy Using the Polywrap CLI's codegen command, we generated AssemblyScript classes corresponding to each type we defined in the schema. This was as simple as typing polywrap codegen. The classes work like TypeScript interfaces (statically typed JavaScript objects) that include some boilerplate serialization logic. When you declare a function in your schema that returns a custom type or accepts one as an argument, these generated classes are used as the AssemblyScript analogs. The codegen command simultaneously generates another flavor of AssemblyScript class: function inputs. An Input_* class is generated for each function, where * is the name of the function. The classes have properties corresponding to the arguments defined in the schema. These Input_* classes are used as inputs to the functions declared in the GraphQL schema. The Polywrap CLI places the generated files in directories named w3, which can be found within each module folder (as declared in your polywrap.yaml manifest). From there you can implement and use them. Once we generated the classes, we imported the generated types and implemented the functions just as we found them in the Uniswap SDK. The function signatures match the schema definitions we declared earlier. // An abridged copy of src/query/token.ts in the Uniswap v3 wrapper import { Input_tokenEquals, Input_tokenSortsBefore, Token, } from \"./w3\"; // Checks if the current instance is equal to another (has an identical chainId and address). export function tokenEquals(input: Input_tokenEquals): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; return tokenA.chainId == tokenB.chainId && tokenA.address == tokenB.address; } // Checks if the current instance sorts before another, by address. export function tokenSortsBefore(input: Input_tokenSortsBefore): boolean { const tokenA: Token = input.tokenA; const tokenB: Token = input.tokenB; const tokenAddress: string = tokenA.address.toLowerCase(); const otherAddress: string = tokenB.address.toLowerCase(); return tokenAddress.localeCompare(otherAddress) < 0; } Copy After implementing the token functions, it was possible to build the project (after commenting out methods in the schema that had not yet been implemented) and write the first automated tests. "},{"title":"Importing plugins and wrappers","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#importing-plugins-and-wrappers","content":"The Uniswap v3 wrapper imports external dependencies to help it with certain tasks. A wrapper can import other wrappers or plugins. One of the most important dependencies we used is Polywrap's Ethereum plugin. The Ethereum plugin is based on the popular ethers.js package. It can be used to prepare and send Ethereum transactions in much the same way. Although the Uniswap v3 JavaScript SDK does not include methods that mutate state on the Ethereum blockchain, several of its functions do return encoded Ethereum transaction calldata that can be sent to Uniswap's on-chain smart contracts. The SDK uses ethers.js to encode calldata. We can do the same with the Ethereum plugin. Our src/query/schema.graphql schema declares several imports at the top of the file. Among these is the Ethereum plugin, which is included in the Polywrap client by default. #import { Query } into Ethereum from \"wrap://ens/ethereum.polywrap.eth\" #import { Query } into SHA3 from \"wrap://ens/sha3.polywrap.eth\" #import { Query } into ERC20 from \"wrap://ipfs/QmeiPWHe2ixfitcgjRwP5AaJD5R7DbsGhQNQwT4rFNyxx8\" #import { Query } into Subgraph from \"wrap://ipfs/QmcnrHegojMFqHkRhixazY67Zb9mSbMLv6sSxyDpUtnrQS\" #import { ChainId, TradeType, Currency, Token, Price, TokenAmount, Tick, Pool, FeeAmount, Route, TradeSwap, Trade, BestTradeOptions, Position, PermitOptions, FeeOptions, SwapOptions, MethodParameters, MintAmounts } from \"../common/schema.graphql\" Copy Wrappers and plugins are queried at URIs. When a user wants to call an API function with the Polywrap Client, they use a URI to tell the Client which API they are calling. The URI's are also used to import wrapper dependencies. Even though the Ethereum plugin is a JavaScript package that gets loaded into memory, it is still queried at a URI that is redirected and resolved to the in-memory instance. Once imports are declared, we can run the codegen command of the Polywrap CLI to generate imported modules and types. The imported module class includes all of the methods declared in its own GraphQL schema. If we want to know what's in it, we might look there first. We used the Ethereum plugin's encodeFunction method to encode calldata for Uniswap's Multicall smart contract. // An abridged copy of src/query/routerUtils.ts in the Uniswap v3 wrapper import { Ethereum_Query, Input_encodeMulticall, } from \"./w3\"; export function encodeMulticall(input: Input_encodeMulticall): string { const calldatas: string[] = input.calldatas; return calldatas.length == 1 ? calldatas[0] : Ethereum_Query.encodeFunction({ method: \"function multicall(bytes[] calldata data) external payable returns (bytes[] memory results)\", args: ['[\"' + calldatas.join('\", \"') + '\"]'], }).unwrap(); } Copy "},{"title":"Using base schema types","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#using-base-schema-types","content":"Polywrap schemas support additional default types beyond those found in standard GraphQL. The BigInt type is used in the Uniswap v3 wrapper to represent integers larger than 32 bits. Since Ethereum supports unsigned integers as large as 256 bits, we needed to support them as well. \"\"\"An amount of a token\"\"\" type TokenAmount { \"\"\"Token\"\"\" token: Token! \"\"\"Raw amount of the token, not adjusted for the token's decimals\"\"\" amount: BigInt! } Copy The BigInt type looks like a standard GraphQL type in the schema. In AssemblyScript, the type is received as an instance of the BigInt class from in the as-bigint AssemblyScript package. // compares two TokenAmount types for equality, returning true if they have the // same token and same amount export function tokenAmountEquals(input: Input_tokenAmountEquals): boolean { const amtA: TokenAmount = input.tokenAmountA; const amtB: TokenAmount = input.tokenAmountB; return ( tokenEquals({ tokenA: amtA.token, tokenB: amtB.token }) && amtA.amount.eq(amtB.amount) ); } Copy Other base schema types include BigNumber, JSON, and Map<T,U>. These types, along with BigInt, can be imported directly into AssemblyScript modules from the polywrap/wasm package. "},{"title":"Testing","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#testing","content":"We adapted all of the tests in Uniswap's SDK to work with the wrapper. This ensured that the wrapper met at least the same standards of quality the Uniswap team expected of their SDK. The Uniswap team tested their SDK with artificial data that allowed them to calculate the expected results and compare those results to the outputs of their code. We used the same test cases and expected the same results from our wrapper. We also wrote tests based on real-world data, using a fork of the Ethereum Mainnet network, to compare the results of our wrapper queries with results produced by the SDK. This helped us test the wrapper with input of greater complexity. We wrote automated tests using two different testing frameworks: as-pect and jest. "},{"title":"AssemblyScript tests with as-pect","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#assemblyscript-tests-with-as-pect","content":"as-pect is an AssemblyScript testing framework, and that is why we used it. Unit tests written in the native language of the wrapper can be used to test classes and functions that are written to support the main wrapper code. This reduces the layers of complexity that would be associated with testing only the functions declared in our GraphQL schema. For example, we wrote a PriorityQueue class to sort trades for the bestTradeExactIn and bestTradeExactOut functions. We used as-pect to test it. This simplified testing and debugging forbestTradeExactIn and bestTradeExactOut. We wrote many of our other tests in as-pect as well, in part because it was straightforward to copy and paste test scripts from the Uniswap v3 SDK repo and adapt the syntax. One quirk with as-pect is that the following must be added to its configuration file to get it working with Polywrap. imports: { w3: { __w3_invoke_args: () => {}, __w3_invoke_result: () => {}, __w3_invoke_error: () => {}, __w3_subinvoke: () => {}, __w3_subinvoke_result: () => {}, __w3_subinvoke_result_len: () => {}, __w3_subinvoke_error: () => {}, __w3_subinvoke_error_len: () => {}, __w3_abort: () => {}, } }, Copy "},{"title":"End-to-end tests in JavaScript with Jest","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#end-to-end-tests-in-javascript-with-jest","content":"Not all tests can be written in the wrapper's native language, nor should they be. Code that depends on other wrappers or plugins must be tested by making calls to the Polywrap Client. The Client coordinates inter-API communication. We wrote many of our most important tests in the popular JavaScript framework jest. Were we to write the Uniswap v3 wrapper again, we would actually use a lot less as-pect and a lot more jest. One advantage of testing with jest is that it requires developers to make calls in the same way users of their wrappers are likely to make them. A disadvantage is that it requires developers to set up the Polywrap client and a test environment, which is easy but takes more time. You can learn how to set up a Polywrap test environment in JavaScript by reading Write an end to end test. "},{"title":"Other tips for testing in JavaScript","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#other-tips-for-testing-in-javascript","content":"The Polywrap CLI can automatically generate TypeScript types using the polywrap app command. The types mirror those declared in your GraphQL schema. If you love brevity, you can write functions that \"wrap\" your wrapper calls. This can make your tests a bit easier to read. // This function lets us call the createRoute function in the Uniswap v3 wrapper with one line of code export async function createRoute(client: PolywrapClient, ensUri: string, pools: Pool[], inToken: Token, outToken: Token): Promise<Route> { const query = await client.invoke<Route>({ uri: ensUri, module: \"query\", method: \"createRoute\", input: { pools, inToken, outToken, }, }); if (query.error) { throw query.error; } return query.data!; } // example usage const route_0_1: Route = await createRoute(client, ensUri, [pool_0_1], token0, token1); Copy "},{"title":"Documentation","type":1,"pageTitle":"Case study: Uniswap v3 Wrapper","url":"quick-start/create-wasm-wrappers/uniswapv3-to-polywrap#documentation","content":"As a final touch, we generated ample documentation for the Uniswap v3 wrapper. Polywrap's GraphQL parser can read documentation comments (comments with triple quotes) from the wrapper's GraphQL schema. Using this capability, Polywrap built a tool to help developers create documentation for their wrappers. The Polywrap CLI will soon be able to use GraphQL schemas to automatically generate markdown that is compatible with popular documentation tools like Docusaurus. We tested the tool to generate the reference documentation for the Uniswap v3 wrapper. "},{"title":"Writing tests with TypeScript","type":0,"sectionRef":"#","url":"quick-start/test-wasm-wrappers/end-to-end-test","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#introduction","content":"Here we discuss the process of writing end to end (e2e) tests for your Wasm wrapper using TypeScript. By end-to-end, we mean tests that make calls to the wrapper through a Polywrap Client. E2e testing is both necessary and useful. It is necessary because calls between wrappers depend on the Polywrap Client, and therefore cannot always be made in a Wasm wrapper's native language. It is useful because such tests can more accurately represent the user experience of your wrapper when it is integrated into an application. We will focus on setting up a test environment and a Polywrap Client. Once these tasks are completed, testing a Wasm wrapper is similar to testing a traditional SDK. "},{"title":"Prerequisites","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#prerequisites","content":"This guide uses TypeScript to implement the Polywrap test environment. We will also use the Jest testing framework, though you can use any framework and follow without difficulty. tip In the future, TypeScript will be one of many supported languages with a Polywrap client. As more Polywrap Clients are released in various languages, implementing plugin wrappers in those languages will be supported as well. You'll need the following installed as developer dependencies before testing your wrapper: polywrap@polywrap/test-env-js@polywrap/client-jsjest@types/jest These can be added to your TypeScript project using the npm or yarn package managers: npm install --save-dev polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest Copy yarn add -D polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest Copy "},{"title":"The Polywrap Test Environment","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#the-polywrap-test-environment","content":"An ideal Polywrap test environment will integrate everything you need to test your wrapper. In the case of this guide, we will need an IPFS node and an Ethereum test network. tip Polywrap makes it easy to create a custom test environment that you can start and stop with the Polywrap CLI. See Configure Polywrap infrastructure pipeline for more information. This guide will use the @polywrap/test-env-js package. The @polywrap/test-env-js package uses the default infrastructure module included with the polywrap CLI. We can use @polywrap/test-env-js to start and stop the test environment programmatically. The package also exports the ethereum provider, ipfs provider, and ens addresses used by the default infrastructure module. "},{"title":"Starting and stopping a Polywrap Test environment with @polywrap/test-env-js","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js","content":"If you're unfamiliar with @polywrap/test-env-js, feel free to check out the reference documentation before we continue. Let's start a new file where we will write our first test. Like many testing frameworks in JavaScript, the Jest framework includes hooks that run before and after all tests. I've added a call to initTestEnvironment in the beforeAll hook, so we can start our test environment before running our tests. I added a call to stopTestEnvironment in the afterAll hook to make sure the test environment does not continue running on our system after we finish testing. import { initTestEnvironment, stopTestEnvironment } from \"@polywrap/test-env-js\"; jest.setTimeout(360000); describe('Wrapper Test', () => { beforeAll(async () => { // initialize test environment await initTestEnvironment(); }); afterAll(async () => { // stop test environment await stopTestEnvironment(); }); test(\"\", async () => { }); }); Copy "},{"title":"Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js","content":"To invoke a Wasm wrapper in a test, we first need to build it. In this guide, we will do this with@polywrap/test-env-js using the buildWrapper function. tip Alternatively, we could have used the @polywrap/test-env-js function buildAndDeployWrapper. The buildAndDeployWrapper function will build a wrapper, deploy it to IPFS, point an ENS domain to it. It returns both the IPFS content hash and the ENS domain, either of which could be used to invoke the wrapper. The buildWrapper function requires an absolute path to the directory containing the wrapper's polywrap manifest. We will obtain the absolute path to our wrapper project in three steps. First we get the directory of the folder containing our test script, using the node.js __dirname global variable. We then append the path from our test script file to the manifest directory. Finally, we import the node.js feature path, and use path.resolve to get direct absolute path to our wrapper project. We will invoke our wrapper using the path to our build folder. We prefix the path with wrap://fs/ to conform to the WRAP URI standard, though prefixing the path with fs/ alone would work just as well. See Understanding URIs to learn more. import { buildWrapper, initTestEnvironment, stopTestEnvironment } from \"@polywrap/test-env-js\"; import path from \"path\"; jest.setTimeout(360000); describe('Wrapper Test', () => { // path to the wrapper's build folder let wrapperPath: string; beforeAll(async () => { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + \"/../../../\"); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` }); afterAll(async () => { // stop test environment await stopTestEnvironment(); }); test(\"\", async () => { }); }); Copy "},{"title":"Setting up a Polywrap Client","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#setting-up-a-polywrap-client","content":"Now that we have deployed our Wasm wrapper to a local test environment, we need to set up a Polywrap Client that can invoke it. We can make sure our client is ready to invoke the wrapper by configuring two of the default plugin wrappers. The ipfsResolverPlugin can be configured using the test environment's local IPFS node.The ethereumPlugin can be configured with an Ethereum provider for the Ganache Ethereum test network. "},{"title":"Configure the IPFS Resolver Plugin","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#configure-the-ipfs-resolver-plugin","content":"The ipfsResolverPlugin can be configured with a default IPFS provider and an array of fallback providers that will be tried if the default provider fails. import { ipfsPlugin, IpfsPluginConfig } from \"@polywrap/ipfs-plugin-js\"; const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; Copy "},{"title":"Configure the Ethereum Plugin","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#configure-the-ethereum-plugin","content":"The ethereumPlugin can be configured with Ethereum providers and signers. It accepts JSON RPC provider strings, Providers from the ethers.js package, and providers from the web3.js package. To configure the plugin, we need to provide it with an object containing network names along with a provider. We can optionally provide a signer as well, but by default the plugin will attempt to obtain a signer from the provider if it is needed. We can give networks any name we want in our configuration. We can later use these names to choose which network to query. Here we will use the name \"testnet\" for our local Ethereum test network. We also need to tell the Ethereum plugin which network should be used when a network is not specified. We do this by setting the value of the defaultNetwork property to one of our network names. import { ethereumPlugin, EthereumPluginConfig } from \"@polywrap/ethereum-plugin-js\"; const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: \"testnet\", }; Copy "},{"title":"Create the Polywrap Client Instance","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#create-the-polywrap-client-instance","content":"Now we are ready to add the plugins to our Polywrap Client configuration and create the client. The URI's we assign in our client configuration will redirect to the plugin instances when queried. import { ClientConfig, PolywrapClient } from \"@polywrap/client-js\"; import { ethereumPlugin, EthereumPluginConfig } from \"@polywrap/ethereum-plugin-js\"; import { ipfsPlugin, IpfsPluginConfig } from \"@polywrap/ipfs-plugin-js\"; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from \"@polywrap/test-env-js\"; import path from \"path\"; jest.setTimeout(360000); describe('Wrapper Test', () => { // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () => { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + \"/../../../\"); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: \"testnet\", }; // configure the client const clientConfig: Partial<ClientConfig> = { plugins: [ { uri: \"wrap://ens/ipfs.polywrap.eth\", plugin: ipfsPlugin(ipfsConfig), }, { uri: \"wrap://ens/ethereum.polywrap.eth\", plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); }); afterAll(async () => { // stop test environment await stopTestEnvironment(); }); test(\"\", async () => { }); }); Copy "},{"title":"Deploy the Smart Contract","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#deploy-the-smart-contract","content":"The SimpleStorage wrapper is designed to interact with a SimpleStorage smart contract. We need to deploy an instance of the contract to work with. While there are many tools developers can use to deploy a smart contract on a local network, the SimpleStorage API has a method deployContract we can use to get the job done. We'll call it before running our test to make sure the contract is ready. import { ClientConfig, PolywrapClient } from \"@polywrap/client-js\"; import { ethereumPlugin, EthereumPluginConfig } from \"@polywrap/ethereum-plugin-js\"; import { ipfsPlugin, IpfsPluginConfig } from \"@polywrap/ipfs-plugin-js\"; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from \"@polywrap/test-env-js\"; import path from \"path\"; jest.setTimeout(360000); describe('Wrapper Test', () => { // the Ethereum address of the SimpleStorage smart contract let simpleStorageAddress: string; // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () => { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + \"/../../../\"); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: \"testnet\", }; // configure the client const clientConfig: Partial<ClientConfig> = { plugins: [ { uri: \"wrap://ens/ipfs.polywrap.eth\", plugin: ipfsPlugin(ipfsConfig), }, { uri: \"wrap://ens/ethereum.polywrap.eth\", plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); // deploy simple storage contract const { data, error } = await client.invoke<string>({ uri: wrapperPath, method: \"deployContract\", }); if (error) throw error; simpleStorageAddress = data as string; }); afterAll(async () => { // stop test environment await stopTestEnvironment(); }); test(\"\", async () => { }); }); Copy "},{"title":"Generate TypeScript Types","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#generate-typescript-types","content":"Since we are using TypeScript, we will want types to work with. It is possible to automatically generate TypeScript types from a GraphQL schema using the Polywrap CLI's app command. Let's set up a polywrap.app.yaml manifest in a new folder called types. We will provide the manifest with the path to the composed schema in our build folder. polywrap.app.yaml format: 0.1.0 name: generate-typescript-types language: app/typescript schema: ../../../build/schema.graphql Copy We can then call the app command of the Polywrap CLI. yarn polywrap app codegen -m ./src/__tests__/types/polywrap.app.yaml -g ./src/__tests__/types/wrap Copy The generated output includes TypeScript types for the SimpleStorage wrapper and its imports. types.ts ... export type String = string; export type Boolean = boolean; export interface SetIpfsDataOptions { address: Types.String; data: Types.String; } export interface SetIpfsDataResult { ipfsHash: Types.String; txReceipt: Types.String; } /// Imported Objects START /// /* URI: \"wrap://ens/ethereum.polywrap.eth\" */ export interface Ethereum_Connection { node?: Types.String | null; networkNameOrChainId?: Types.String | null; } ... Copy "},{"title":"Testing a Wrapper Method","type":1,"pageTitle":"Writing tests with TypeScript","url":"quick-start/test-wasm-wrappers/end-to-end-test#testing-a-wrapper-method","content":"From this point, testing a function in your wrapper is no different from testing a traditional SDK. Instead of calling a method in a traditional SDK, you will invoke your wrapper. We will test the setIpfsData method we added to the SimpleStorage API in Adding new functions. For arguments, the setIpfsData method takes the Ethereum address of a deployed SimpleStorage contract and the data the user wants to add to IPFS. It returns the IPFS hash of the data. We will test the setIpfsData method using the string \"Hello from IPFS!\" as the data for our test case. To be sure our method returns the correct IPFS hash, we can compare the method's return value to the value we get from the freeFile CID Checker service provided by Pinata. Final test file import { ClientConfig, PolywrapClient } from \"@polywrap/client-js\"; import { ethereumPlugin, EthereumPluginConfig } from \"@polywrap/ethereum-plugin-js\"; import { ipfsPlugin, IpfsPluginConfig } from \"@polywrap/ipfs-plugin-js\"; import { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from \"@polywrap/test-env-js\"; import path from \"path\"; import { SetIpfsDataResult } from '../types/wrap'; jest.setTimeout(360000); describe('Wrapper Test', () => { // the Ethereum address of the SimpleStorage smart contract let simpleStorageAddress: string; // path to the wrapper's build folder let wrapperPath: string; // an instance of the Polywrap Client let client: PolywrapClient; beforeAll(async () => { // initialize test environment await initTestEnvironment(); // absolute path to directory with polywrap.yaml const wrapperDirectory: string = path.resolve(__dirname + \"/../../../\"); // build the wrapper await buildWrapper(wrapperDirectory); wrapperPath = `wrap://fs/${wrapperDirectory}/build` console.log(wrapperPath); // configure the ipfs plugin const ipfsConfig: IpfsPluginConfig = { provider: providers.ipfs, fallbackProviders: undefined, }; // configure the ethereum plugin const ethereumConfig: EthereumPluginConfig = { networks: { testnet: { provider: providers.ethereum // Ganache test network }, }, defaultNetwork: \"testnet\", }; // configure the client const clientConfig: Partial<ClientConfig> = { plugins: [ { uri: \"wrap://ens/ipfs.polywrap.eth\", plugin: ipfsPlugin(ipfsConfig), }, { uri: \"wrap://ens/ethereum.polywrap.eth\", plugin: ethereumPlugin(ethereumConfig), }, ], }; // create client client = new PolywrapClient(clientConfig); // deploy simple storage contract const { data, error } = await client.invoke<string>({ uri: wrapperPath, method: \"deployContract\", }); if (error) throw error; simpleStorageAddress = data as string; console.log(simpleStorageAddress); }); afterAll(async () => { // stop test environment await stopTestEnvironment(); }); test(\"setIpfsData\", async () => { // invoke setIpfs method const { data, error } = await client.invoke<SetIpfsDataResult>({ uri: wrapperPath, method: \"setIpfsData\", args: { options: { address: simpleStorageAddress, data: \"Hello from IPFS!\", }, } }); // check for errors expect(error).toBeFalsy(); // will be undefined if no exception is thrown in the wrapper expect(data).toBeTruthy(); // will be undefined if an exception is thrown in the wrapper // compare results expect(data?.ipfsHash).toEqual(\"QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis\"); }); }); Copy "},{"title":"Configure Polywrap infrastructure pipeline","type":0,"sectionRef":"#","url":"quick-start/test-wasm-wrappers/infra-pipeline","content":"","keywords":""},{"title":"Declaration","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#declaration","content":"Unlike some manifests, the Infra Manifest does not need to be declared in your Polywrap manifest. "},{"title":"Content","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#content","content":"The Infra Manifest consists of environmental variable declarations and one or more infrastructure modules. Each module points to a local, remote, or default docker-compose file. SchemaExample format: # The manifest format version env: # Declare environmental variables here modules: myRemote: # A remote package with a docker-compose file package: # Package name version: # Package version registry: # Package registry name dockerComposePath: # (Optional) Path to docker-compose file in the package directory myLocal: # A local package with a docker-compose file path: # Path to the package eth-ens-ipfs: default # A module available by default Copy "},{"title":"Infrastructure Modules","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#infrastructure-modules","content":"An Infra Manifest can declare any number of infrastructure modules. Polywrap currently supports three types of infrastructure modules: A local module exists on your local filesystem.A remote module is a package hosted by a package registry.The default module is included with the CLI. "},{"title":"Local","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#local","content":"A local infrastructure module is a path from the Infra Manifest to a local folder with a docker-compose file. Example: local module configuration format: 0.1.0 modules: myLocal: path: ../local-packages/myLocal Copy "},{"title":"Remote","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#remote","content":"A remote infrastructure module is a package hosted at a package registry. The package must contain a docker-compose file. The path to the docker-compose file must be declared in the Infra Manifest if the file is not located in the package root. Remote packages can be shared. Users can add remote packages to their manifest to replicate the infrastructure modules defined by other users or projects. Example: remote module configuration format: 0.1.0 modules: myIpfsNode: package: \"@namestys/ipfs-node\" version: \"1.0.2\" registry: npm dockerComposePath: ./config/docker-compose.yaml Copy "},{"title":"Default","type":1,"pageTitle":"Configure Polywrap infrastructure pipeline","url":"quick-start/test-wasm-wrappers/infra-pipeline#default","content":"A default infrastructure module is included with the polywrap CLI. It is declared in the Infra Manifest as a module named eth-ens-ipfs and the value default. If an Infra Manifest is not found, the Polywrap CLI infra command can still use this module. To use the default module without an Infra Manifest, pass eth-ens-ipfs as an argument to the infra command's modules option: npx polywrap infra up --modules=eth-ens-ipfs Copy The default infrastructure module defines a docker container with: A test server at http://localhost:4040A Ganache Ethereum test network at http://localhost:8545An IPFS node at http://localhost:5001 It also sets up ENS smart contracts at initialization, so you can build wrappers and deploy them to an ENS registry on your locally hosted testnet. The Ethereum address of the ENS registry is 0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab. Example: local module configuration format: 0.1.0 modules: eth-ens-ipfs: default Copy "},{"title":"Workflow Validation","type":0,"sectionRef":"#","url":"quick-start/workflows/workflow-validation","content":"","keywords":""},{"title":"CUE","type":1,"pageTitle":"Workflow Validation","url":"quick-start/workflows/workflow-validation#cue","content":"Validation files are written in CUE, an open-source data validation language. It has a simple syntax and is easy to use. CUE provides flexible data validation, including: matching exact valuesmatching typesmatching bounds (e.g. result > 2)matching regular expressions To validate a workflow, you must have CUE installed on your computer. "},{"title":"Writing a validation script","type":1,"pageTitle":"Workflow Validation","url":"quick-start/workflows/workflow-validation#writing-a-validation-script","content":"A validation script should match the structure of the workflow it seeks to validate. It is compared against the output of the workflow. tip To validate a particular job in a workflow, your validation file should be modified to match the output of that particular job. The json-rpc demo uses aworkflow andvalidator to replicate its full integration test suite. We've provided a sample workflow and validation script based on the json-rpc demo here: workflow.yamlvalidator.cue name: json-rpc jobs: case1: steps: - uri: fs/build method: query args: url: \"https://archival-rpc.testnet.near.org\" request: method: \"gas_price\" params: \"[93019381]\" id: \"1\" Copy "},{"title":"Running Workflows","type":0,"sectionRef":"#","url":"quick-start/workflows/running-workflows","content":"","keywords":""},{"title":"Writing workflows","type":1,"pageTitle":"Running Workflows","url":"quick-start/workflows/running-workflows#writing-workflows","content":"A workflow consists of a tree of Jobs and Steps. A Job is an independent, named unit that can contain an array of Steps named steps and/or a set of sub-Jobs named jobs. Each Job runs asynchronously, and therefore Jobs may run in any order. Although all the sub-jobs are guaranteed to be executed after the parent job completes. Outputs of the parent jobs can be referenced as the input of any of its sub-jobs. By default, run will run all jobs in a workflow. A Job index can be provided to run to execute a specific job. A Step is a wrapper invocation. An array of Steps runs synchronously--i.e. in the order defined in the workflow. The result of a Job or Step can be passed as an input argument to a Job or Step that is its child in the tree hierarchy. SchemaExample name: # name of the workflow jobs: # a set of one or more jobs case1: # a job, named by the user steps: # an array of steps - uri: fs/build # uri of invocation method: query # method to invoke args: # method arguments config: # (Optional) modified client configuration for this call Copy "},{"title":"Configuring the Client","type":1,"pageTitle":"Running Workflows","url":"quick-start/workflows/running-workflows#configuring-the-client","content":"Users can configure the Polywrap client used to execute a workflow. This is done by providing the Polywrap CLI's run command with the path to a custom configuration file. The configuration file can be a JavaScript or TypeScript module. It must implement and export a function named getClientConfig. The getClientConfig function accepts the default PolywrapClientConfig as an argument and returns the custom Polywrap client configuration. It must be implemented with the following signature: TypeScriptJavaScript // asynchronous option export async function getClientConfig( defaultConfigs: Partial<PolywrapClientConfig> ): Promise<Partial<PolywrapClientConfig>> // synchronous option export function getClientConfig( defaultConfigs: Partial<PolywrapClientConfig> ): Partial<PolywrapClientConfig> Copy "},{"title":"Workflow output","type":1,"pageTitle":"Running Workflows","url":"quick-start/workflows/running-workflows#workflow-output","content":"The output of a workflow can be written as a file in the JSON or YAML format with the output-file option of the Polywrap CLI'srun command. Workflow output is printed to the console by default. Console output can be suppressed with the quiet option of the Polywrap CLI's run command. "},{"title":"App","type":0,"sectionRef":"#","url":"reference/cli/commands/app","content":"Usage: polywrap app|a [options] [command] Build/generate types for your app Options: -h, --help display help for command Commands: codegen [options] Generate code for the app help [command] display help for command Copy","keywords":""},{"title":"Build","type":0,"sectionRef":"#","url":"reference/cli/commands/build","content":"Usage: polywrap build|b [options] Builds a wrapper Options: -m, --manifest-file <path> Path to the Polywrap Build manifest file (default: polywrap.yaml | polywrap.yml) -o, --output-dir <path> Output directory for build results (default: build/) -c, --client-config <config-path> Add custom configuration to the PolywrapClient -w, --watch Automatically rebuild when changes are made (default: false) -v, --verbose Verbose output (default: false) -h, --help display help for command Copy","keywords":""},{"title":"Wrapper Schema","type":0,"sectionRef":"#","url":"quick-start/wrapper-schema","content":"","keywords":""},{"title":"Declaration","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#declaration","content":"A wrapper project's schema must be declared in the project manifest (Polywrap Manifest or Plugin Manifest). schema: ./src/schema.graphql Copy "},{"title":"Codegen","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#codegen","content":"The wrapper schema tells the Polywrap compiler which types and serialization logic to generate. Generated types are updated every time you build the wrapper. The polywrap CLI also provides a codegen command to quickly update the generated wrap folder where generated types are stored. The Polywrap compiler generates types for method arguments and custom schema types. Wrapper developers must use the generated method arguments for methods declared in the schema, and generated types for method return values when the return value is of a custom type. The generated types come with serialization logic that allows Wrappers to communicate with the client. The following example demonstrates this practice. DeclarationImplementation type Module { foo( bar: String! arg: Int! ): ReturnType! } type ReturnType { prop: Int! } Copy "},{"title":"Language Syntax","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#language-syntax","content":"Wrapper schemas are written in Polywrap's variant of the GraphQL schema definition language (SDL). Polywrap's GraphQL variant is simpler than standard GraphQL and easy to learn. "},{"title":"Custom Types","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#custom-types","content":"Custom types are declared with the type keyword. They can be given any number of properties. Properties can be of any supported type, including other custom types. type CustomType { myString: String! myObject: AnotherType! } type AnotherType { myInt: Int! } Copy "},{"title":"Nullability","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#nullability","content":"As in standard GraphQL, properties, method arguments, and method return values are declared non-nullable by appending a ! at the end of the type name. The absence of a ! indicates that a value is nullable. type CustomType { nullable: String # can be String or null nonNullable: String! # must be String } Copy "},{"title":"Methods","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#methods","content":"Methods are declared within the Module type. Methods must return a value. type Module { foo( arg: CustomType! bar: CustomType ): ReturnType! } Copy Custom types and modules can be imported from other wrappers by placing an import statement at the top of the schema. Imports become available in the schema immediately and in the wrapper following codegen. "},{"title":"Imports","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#imports","content":"Imported types and modules must be assigned a namespace. References to them are prepended with the namespace. #import { Module, CustomType } into Namespace from \"wrap://authority/path\" type CustomType { prop: Namespace_CustomType! } Copy "},{"title":"Example","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#example","content":"The following example uses all of the elements we've discussed so far. #import { Module, Connection } into Ethereum from \"wrap://ens/ethereum.polywrap.eth\" #import { Module } into Ipfs from \"wrap://ens/ipfs.polywrap.eth\" type Module { # methods are declared in type Module getIpfsData( address: String! # types ending with ! are non-nullable connection: Ethereum_Connection # imported types are used like local types ): String! setIpfsData( options: SetIpfsDataOptions! # custom types can be arguments connection: Ethereum_Connection ): SetIpfsDataResult! # custom types can be return values } type SetIpfsDataOptions { # custom types are declared with \"type\" keyword address: String! data: String! } type SetIpfsDataResult { ipfsHash: String! txReceipt: String! } Copy "},{"title":"Default Types","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#default-types","content":"Polywrap's schema definition language supports three kinds of default types: Basic types like integers and stringsComplex types like BigInt and JSONGeneric types like Array and Map These types may be implemented differently in different programming languages. The language-specific implementations are clarified in each of the following sections. "},{"title":"Basic Types","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#basic-types","content":"Basic types include primitive types like integers and boolean values, as well as Strings and Bytes. SchemaClientWasm wrapper Schema Type\tDescriptionUInt\t32-bit unsigned integer UInt8\t8-bit unsigned integer UInt16\t16-bit unsigned integer UInt32\t32-bit unsigned integer Int\t32-bit signed integer Int8\t8-bit signed integer Int16\t16-bit signed integer Int32\t32-bit signed integer String\tUTF-8 string Boolean\tTrue or false stored as 1 byte Bytes\tArray of 8-bit unsigned integers "},{"title":"Complex Types","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#complex-types","content":"Complex types are represented as basic types to the Polywrap client and plugin wrappers. Within Wasm wrappers, they are implemented as classes or structs with behavior. For example, consider an application developer invoking a Wasm wrapper with the JavaScript client. If the invoked method requires an argument of type BigInt, the application developer will provide a stringrepresentation of an integer number to satisfy the argument. Within the wrapper, the string is deserialized into an instantion of the wrapper language's implementation of a BigInt. If the invoked method returns a BigInt, the wrapper will serialize the returned BigInt, which the client will then deserialize into a string before returning it to the application developer. SchemaClientWasm wrapper Schema Type\tDescriptionBigInt\tMultiple precision integer BigNumber\tMultiple precision float JSON\tJSON object "},{"title":"Generic Types","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#generic-types","content":"When using a generic type, with the exception of arrays, schema writers must add a directive annotation declaring its subtype(s). The directive takes the form @annotate(type: \"TypeName<T\\>\"), where T is the type of the subtype. The generic type and its subtype(s) can be independently nullable or non-nullable. The following example illustrates use of the generic type directive with the Map type. type Module { getKey( key: String! map: Map! @annotate(type: \"Map<String!, Int!\\>!\") ): Int! returnMap( map: Map! @annotate(type: \"Map<String!, Int!\\>!\") ): Map! @annotate(type: \"Map<String!, Int!\\>!\") } Copy Like complex types, the implementation of generic types can differ by language. SchemaClientWasm wrapper Schema Type\tDescription[Type]\tArray of elements. Map\tMap of key-value pairs. "},{"title":"Interfaces","type":1,"pageTitle":"Wrapper Schema","url":"quick-start/wrapper-schema#interfaces","content":"A module can inherit the method declarations of any other module by using the implements keyword. A module that implements an interface in this manner is required to implement and export the interface module's declared methods. Similarly, a type can inherit the property declarations of any other type by using the implements keyword. If a type implements an interface, it inherits the interface type's property declarations as though the properties were declared explicitly. #import { Module, InterfaceType } into Interface from \"wrap://ens/interface.eth\" type Module implements Interface_Module { # declares methods of Interface_Module } type ImplementationType implements Interface_InterfaceType { # declares properties of Interface_InterfaceType } Copy "},{"title":"Codegen","type":0,"sectionRef":"#","url":"reference/cli/commands/codegen","content":"Usage: polywrap codegen|g [options] Auto-generate Wrapper Types Options: -m, --manifest-file <path> Path to the Polywrap manifest file (default: polywrap.yaml | polywrap.yml) -g, --codegen-dir <path> Output directory for the generated code (default: ./wrap) -s, --script <path> Path to a custom generation script (JavaScript | TypeScript) -c, --client-config <config-path> Add custom configuration to the PolywrapClient -h, --help display help for command Copy","keywords":""},{"title":"Create","type":0,"sectionRef":"#","url":"reference/cli/commands/create","content":"Usage: polywrap create|c [options] [command] Create a new project with polywrap CLI Options: -h, --help display help for command Commands: wasm [options] <language> <name> Create a Polywrap wasm wrapper langs: assemblyscript, rust, interface app [options] <language> <name> Create a Polywrap application langs: typescript-node, typescript-react plugin [options] <language> <name> Create a Polywrap plugin langs: typescript help [command] display help for command Copy","keywords":""},{"title":"Deploy","type":0,"sectionRef":"#","url":"reference/cli/commands/deploy","content":"Usage: polywrap deploy|d [options] Deploys/Publishes a Polywrap Options: -m, --manifest-file <path> Path to the Polywrap Deploy manifest file (default: polywrap.yaml | polywrap.yml) -v, --verbose Verbose output (default: false) -h, --help display help for command Copy","keywords":""},{"title":"Infra","type":0,"sectionRef":"#","url":"reference/cli/commands/infra","content":"Usage: polywrap infra|i <action> [options] Manage infrastructure for your wrapper Arguments: action Infra allows you to execute the following commands: up Start Polywrap infrastructure down Stop Polywrap infrastructure config Validate and display Polywrap infrastructure's bundled docker-compose manifest vars Show Polywrap infrastructure's required .env variables (choices: \"up\", \"down\", \"vars\", \"config\") Options: --manifest <manifest> Infra Manifest path (default: \"polywrap.infra.yaml\") -m, --modules <module-name,module-name> Use only specified modules -v, --verbose Verbose output (default: false) -h, --help display help for command Copy","keywords":""},{"title":"Plugin","type":0,"sectionRef":"#","url":"reference/cli/commands/plugin","content":"Usage: polywrap plugin|p [options] [command] Build/generate types for the plugin Options: -h, --help display help for command Commands: codegen [options] help [command] display help for command Copy","keywords":""},{"title":"Run","type":0,"sectionRef":"#","url":"reference/cli/commands/run","content":"Usage: polywrap run|r [options] <workflow> Runs workflow script Arguments: workflow Path to workflow script Options: -c, --client-config <config-path> Add custom configuration to the PolywrapClient -v, --validate-script <cue-file> Validate the output of the workflow jobs -o, --output-file <output-file-path> Output file path for the workflow result -j, --jobs <jobs...> Specify ids of jobs that you want to run -q, --quiet Suppress output -h, --help display help for command Copy","keywords":""},{"title":"Client","type":0,"sectionRef":"#","url":"reference/clients/js/client-js","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"Client","url":"reference/clients/js/client-js#installation","content":"npm install @polywrap/client-js Copy "},{"title":"Usage","type":1,"pageTitle":"Client","url":"reference/clients/js/client-js#usage","content":"Use an import or require statement, depending on which your environment supports. import { PolywrapClient } from \"@polywrap/client-js\"; Copy Then, you will be able to use the PolywrapClient like so: // Simply instantiate the PolywrapClient. const client = new PolywrapClient(); // ...And then you'll be able to use the `invoke` // method to execute methods within the wrapper // located at the specified URI. const result = await client.invoke({ uri: 'ens/api.example.eth', method: \"doSomething\", args: { variable: 555, value: \"important value\" } }); Copy "},{"title":"Polywrap CLI","type":0,"sectionRef":"#","url":"reference/cli/polywrap-cli","content":"","keywords":""},{"title":"Prerequisites","type":1,"pageTitle":"Polywrap CLI","url":"reference/cli/polywrap-cli#prerequisites","content":"Docker is required to perform some tasks, including to build Wasm wrappers. Linux users will also need to install Docker Compose. Docker is free for personal use. Once Docker is installed and enabled, you're ready to go! "},{"title":"Installation","type":1,"pageTitle":"Polywrap CLI","url":"reference/cli/polywrap-cli#installation","content":"npmyarn npm install polywrap Copy tip Node v16 and above is recommended. "},{"title":"Usage","type":1,"pageTitle":"Polywrap CLI","url":"reference/cli/polywrap-cli#usage","content":"To list available commands, run the help command: polywrap --help Copy The following menu will appear in your terminal window: Usage: polywrap [options] [command] Options: -h, --help display help for command Commands: app|a Build/generate types for your app build|b [options] Builds a wrapper codegen|g [options] Auto-generate Wrapper Types create|c Create a new project with polywrap CLI deploy|d [options] Deploys/Publishes a Polywrap plugin|p Build/generate types for the plugin infra|i [options] <action> Manage infrastructure for your wrapper run|r [options] <workflow> Runs workflow script help [command] display help for command Copy To learn about each command, simply add --help after the command name to be given a full description of the options available: polywrap build --help Copy "},{"title":"@polywrap/react","type":0,"sectionRef":"#","url":"reference/clients/js/libraries/react","content":"","keywords":""},{"title":"Installation","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#installation","content":"npm install @polywrap/react Copy "},{"title":"Usage","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#usage","content":""},{"title":"PolywrapProvider","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#polywrapprovider","content":"Once installed, the first step is to add the PolywrapProvider to your DOM. This will instantiate an instance of the PolywrapClient for all queries within the nested DOM hierarchy to use. To use the provider, simply wrap it around whatever DOM hierarchy you'd like to use Polywrap within: import React from 'react'; import { PolywrapProvider } from '@polywrap/react'; export const App: React.FC = () => { return ( <PolywrapProvider> <HelloWorld /> </PolywrapProvider> ); }; Copy PolywrapProvider Props# The PolywrapProvider component's props are the same as the PolywrapClient constructor's arguments. For example, you can configure URI redirects like so: <PolywrapProvider redirects={ [] }/> Copy Multiple PolywrapProviders# If you need to use multiple providers, you can do so using the createPolywrapProvider(\"...\") method, which accepts the name of your provider as an argument. For example: import { createPolywrapProvider } from '@polywrap/react'; const CustomPolywrapProvider = createPolywrapProvider('custom'); export const CustomProvider = ({ children }: { children: JSX.Element }) => { return ( <CustomPolywrapProvider> {children} </CustomPolywrapProvider> ); }; Copy "},{"title":"usePolywrapClient","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#usepolywrapclient","content":"You can obtain a copy of the client instance from your PolywrapProvider using the usePolywrapClient hook. const client = usePolywrapClient(); Copy "},{"title":"usePolywrapInvoke","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#usepolywrapinvoke","content":"After enabling your React application with the PolywrapProvider, you may now use the usePolywrapInvoke hook to call into wrappers! const { execute, data, error, loading } = usePolywrapInvoke({ uri: 'ens/api.helloworld.polywrap.eth', method: \"logMessage\", args: { message: \"Hello World!\", }, }); Copy tip By default, the usePolywrapInvoke hook uses the first PolywrapProvider found in the DOM's hierarchy. If you'd like to specify a specific provider to be used, simply set the provider: property: const { execute, data, errors, loading } = usePolywrapInvoke({ provider: \"custom\", uri: 'ens/api.helloworld.polywrap.eth', method: \"logMessage\", args: { message: \"Hello World!\", }, }); Copy "},{"title":"usePolywrapQuery","type":1,"pageTitle":"@polywrap/react","url":"reference/clients/js/libraries/react#usepolywrapquery","content":"The usePolywrapQuery hook works the same as the usePolywrapInvoke hook, but uses the client's query syntax instead. const { execute, data, errors, loading } = usePolywrapQuery({ uri: 'ens/api.helloworld.polywrap.eth', query: `{ logMessage(message: \"Hello World!\") }`, }); Copy "},{"title":"@polywrap/test-env-js","type":0,"sectionRef":"#","url":"reference/clients/js/libraries/test-env-js","content":"","keywords":""},{"title":"Constants","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#constants","content":""},{"title":"providers","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#providers","content":"export const providers = { ipfs: \"http://localhost:5001\", ethereum: \"http://localhost:8545\", }; Copy The providers object contains the URIs for the default infrastructure module's local Ethereum network provider and IPFS provider. "},{"title":"ensAddresses","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#ensaddresses","content":"export const ensAddresses = { ensAddress: \"0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab\", // ENS Registry resolverAddress: \"0x5b1869D9A4C187F2EAa108f3062412ecf0526b24\", // ENS Resolver registrarAddress: \"0xD833215cBcc3f914bD1C9ece3EE7BF8B14f841bb\", // ENS Registrar reverseAddress: \"0xe982E462b094850F12AF94d21D470e21bE9D0E9C\", // ENS Reverse Lookup } as const; Copy The ensAddresses object contains the Ethereum addresses of the default infrastructure module's locally-deployed ENS smart contracts. "},{"title":"Methods","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#methods","content":""},{"title":"initTestEnvironment","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#inittestenvironment","content":"export const initTestEnvironment = async (cli?: string): Promise<void> Copy The initTestEnvironment function starts a local test environment using the default infrastructure module. It optionally accepts a path to a polywrap CLI binary. "},{"title":"stopTestEnvironment","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#stoptestenvironment","content":"export const stopTestEnvironment = async (cli?: string): Promise<void> Copy The stopTestEnvironment function tears down the local test environment (default infrastructure module) if one is running. It optionally accepts a path to a polywrap CLI binary. "},{"title":"buildWrapper","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#buildwrapper","content":"export async function buildWrapper(wrapperAbsPath: string): Promise<void> Copy The buildWrapper function builds the wrapper located at the given path wrapperAbsPath. "},{"title":"buildAndDeployWrapper","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#buildanddeploywrapper","content":"export async function buildAndDeployWrapper({ wrapperAbsPath, ipfsProvider, ethereumProvider, ensName, }: { wrapperAbsPath: string; // Absolute path of folder containing wrapper's Polywrap Manifest (polywrap.yaml) ipfsProvider: string; // IPFS provider ethereumProvider: string; // Ethereum provider ensName?: string; // (Optional) ENS domain name }): Promise<{ ensDomain: string; // ENS domain for invoking wrapper ipfsCid: string; // IPFS content hash for invoking wrapper }> Copy Like buildWrapper, the buildAndDeployWrapper function builds the wrapper located at the given path wrapperAbsPath. After building the wrapper, buildAndDeployWrapper deploys it to IPFS using the given provider ipfsProvider. It next registers the ENS domain ensName and points the domain to the IPFS deployment using the Ethereum provider ethereumProvider. If an ENS domain is not provided, a randomly selected human-readable ENS domain name is used. The buildAndDeployWrapper function returns a Promise containing the ENS domain and IPFS content hash of the wrapper deployment, either of which can be used to invoke the wrapper. Example: buildAndDeployWrapper with default infrastructure module import { buildAndDeployWrapper, providers } from \"@polywrap/test-env-js\"; const api = await buildAndDeployWrapper({ wrapperAbsPath: \"...\", ipfsProvider: providers.ipfs, ethereumProvider: providers.ethereum, }); const ensUri = `ens/testnet/${api.ensDomain}`; Copy "},{"title":"runCLI","type":1,"pageTitle":"@polywrap/test-env-js","url":"reference/clients/js/libraries/test-env-js#runcli","content":"export const runCLI = async (options: { args: string[]; // Command and arguments cwd?: string; // (Optional) Current working directory cli?: string; // (Optional) Path to CLI binary env?: Record<string, string>; // (Optional) Environmental variables to set }): Promise<{ exitCode: number; // CLI exit code stdout: string; // CLI standard output stderr: string; // CLI standard error }> Copy The runCLI function can be used to run the polywrap CLI programmatically. It requires an array of command line arguments args, which should include the CLI command to be run. An alternative current working directory cwd can be provided to change the context from which the CLI is invoked. It also optionally accepts a path to a polywrap CLI binary. The optional map of environmental variables env will be set before running the CLI. Example: runCLI calling the 'infra' command const { exitCode, stderr, stdout } = await runCLI({ args: [\"infra\", \"up\", \"--modules=eth-ens-ipfs\", \"--verbose\"] }); Copy "},{"title":"Reference Documentation","type":0,"sectionRef":"#","url":"reference/glossary","content":"","keywords":""},{"title":"Command-line Interface (CLI)","type":1,"pageTitle":"Reference Documentation","url":"reference/glossary#command-line-interface-cli","content":"CLI\tDescriptionPolywrap CLI\tThe main CLI for Polywrap "},{"title":"Clients","type":1,"pageTitle":"Reference Documentation","url":"reference/glossary#clients","content":"Client\tDescriptionTypeScript / JavaScript\tUsable in node.js and the browser. Rust\tComing soon... "},{"title":"Manifests","type":1,"pageTitle":"Reference Documentation","url":"reference/glossary#manifests","content":"Coming soon... "},{"title":"Specifications","type":1,"pageTitle":"Reference Documentation","url":"reference/glossary#specifications","content":"Coming soon... "},{"title":"Developer Tools","type":0,"sectionRef":"#","url":"resources/developer-tooling","content":"","keywords":""},{"title":"Introduction","type":1,"pageTitle":"Developer Tools","url":"resources/developer-tooling#introduction","content":"We offer an extensive set of developer tools to build wrappers. If the platform or language you need to use isn't listed here, send us a note on Discord! "},{"title":"Developer Tools","type":1,"pageTitle":"Developer Tools","url":"resources/developer-tooling#developer-tools","content":"Developer Tool\tDescriptionpolywrap\tCommand line interface @polywrap/client-js\tJavaScript client @polywrap/core-js\tStandard JavaScript implementation @polywrap/react\tReact wrapper @polywrap/schema-parse\tSchema parser @polywrap/schema-compose\tSchema Composer @polywrap/schema-bind\tSchema binding @polywrap/wasm-as\tAssemblyScript runtime "},{"title":"Ecosystem Tooling","type":0,"sectionRef":"#","url":"resources/ecosystem-tooling","content":"Check out the amazing projects Polywrap DAO contributors have made: Ethereum ABI -> Wrapper Generator: is a node.js console app that can read an Ethereum smart contract abi file and generate Polywrap wrapper code for schema and AssemblyScript modules..Defiwrapper is a collection of different DeFi related wrappers like defi-sdk, coingecko, etc. With Defiwrapper, the ambition is to create a cross-chain multi-platform suite of DeFi related wrappers.","keywords":""},{"title":"Talks, Podcasts, and Videos","type":0,"sectionRef":"#","url":"resources/talks-podcasts-and-videos","content":"","keywords":""},{"title":"Introduction to Polywrap","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#introduction-to-polywrap","content":" "},{"title":"EthCC Presentation","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#ethcc-presentation","content":" "},{"title":"ETHDenver Presentation","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#ethdenver-presentation","content":" "},{"title":"ETHGlobal Presentation","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#ethglobal-presentation","content":" "},{"title":"Dev Podcasts","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#dev-podcasts","content":""},{"title":"Episode 1 The Polywrap WASM Runtime","type":1,"pageTitle":"Talks, Podcasts, and Videos","url":"resources/talks-podcasts-and-videos#episode-1-the-polywrap-wasm-runtime","content":" "},{"title":"The Polywrap Technical Standard","type":0,"sectionRef":"#","url":"resources/the-polywrap-technical-standard","content":"","keywords":""},{"title":"Polywrap Architecture","type":1,"pageTitle":"The Polywrap Technical Standard","url":"resources/the-polywrap-technical-standard#polywrap-architecture","content":" "}]