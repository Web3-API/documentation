(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{106:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return a})),n.d(t,"toc",(function(){return p})),n.d(t,"default",(function(){return s}));var i=n(3),o=(n(0),n(194));const r={id:"query-types",title:"Query Types"},a={unversionedId:"demos/uniswapv3/types/query-types",id:"demos/uniswapv3/types/query-types",isDocsHomePage:!1,title:"Query Types",description:"AddLiquidityOptions",source:"@site/docs/demos/uniswapv3/types/queryTypes.md",slug:"/demos/uniswapv3/types/query-types",permalink:"/demos/uniswapv3/types/query-types",editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/demos/uniswapv3/types/queryTypes.md",version:"current"},p=[{value:"AddLiquidityOptions",id:"addliquidityoptions",children:[]},{value:"ClaimOptions",id:"claimoptions",children:[]},{value:"CollectOptions",id:"collectoptions",children:[]},{value:"CommonAddLiquidityOptions",id:"commonaddliquidityoptions",children:[]},{value:"FullWithdrawOptions",id:"fullwithdrawoptions",children:[]},{value:"IncentiveKey",id:"incentivekey",children:[]},{value:"NextTickResult",id:"nexttickresult",children:[]},{value:"NFTPermitOptions",id:"nftpermitoptions",children:[]},{value:"PoolChangeResult",id:"poolchangeresult",children:[]},{value:"QuoteOptions",id:"quoteoptions",children:[]},{value:"RemoveLiquidityOptions",id:"removeliquidityoptions",children:[]},{value:"SafeTransferOptions",id:"safetransferoptions",children:[]},{value:"TradeRoute",id:"traderoute",children:[]}],l={toc:p};function s(e){let{components:t,...n}=e;return Object(o.b)("wrapper",Object(i.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h3",{id:"addliquidityoptions"},"AddLiquidityOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Union of MintOptions and IncreaseOptions; one of either recipient or tokenId is required.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type AddLiquidityOptions {\n  recipient: String # The account that should receive the minted NFT.\n  createPool: Boolean # Creates pool if not initialized before mint. Ignored if recipient is not null.\n  tokenId: BigInt # Indicates the ID of the position to increase liquidity for. Ignored if recipient is not null.\n  slippageTolerance: String! \n  deadline: BigInt! \n  useNative: Token \n  token0Permit: PermitOptions \n  token1Permit: PermitOptions \n}\n")),Object(o.b)("h3",{id:"claimoptions"},"ClaimOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options to specify when claiming rewards.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type ClaimOptions {\n  tokenId: BigInt! # The id of the NFT\n  recipient: String! # Address to send rewards to.\n  amount: BigInt # The amount of `rewardToken` to claim. 0 claims all.\n}\n")),Object(o.b)("h3",{id:"collectoptions"},"CollectOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options to specify when calling collectCallParameters(...) to collect liquidity provider rewards or removeCallParameters(...) to exit a liquidity position.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type CollectOptions {\n  tokenId: BigInt! # Indicates the ID of the position to collect for. Ignored when CollectOptions is as property of RemoveLiquidityOptions for use in removeCallParameters(...).\n  expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n  expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n  recipient: String! # The account that should receive the tokens.\n}\n")),Object(o.b)("h3",{id:"commonaddliquidityoptions"},"CommonAddLiquidityOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options for producing the calldata to add liquidity.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type CommonAddLiquidityOptions {\n  slippageTolerance: String! # How much the pool price is allowed to move.\n  deadline: BigInt! # When the transaction expires, in epoch seconds.\n  useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false\n  token0Permit: PermitOptions # The optional permit parameters for spending token0\n  token1Permit: PermitOptions # The optional permit parameters for spending token1\n}\n")),Object(o.b)("h3",{id:"fullwithdrawoptions"},"FullWithdrawOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options to specify when withdrawing tokens")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type FullWithdrawOptions {\n  owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw.\n  data: String # Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.\n  tokenId: BigInt! \n  recipient: String! \n  amount: BigInt \n}\n")),Object(o.b)("h3",{id:"incentivekey"},"IncentiveKey"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Represents a unique staking program.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type IncentiveKey {\n  rewardToken: Token! # The token rewarded for participating in the staking program.\n  pool: Pool! # The pool that the staked positions must provide in.\n  startTime: BigInt! # The time when the incentive program begins.\n  endTime: BigInt! # The time that the incentive program ends.\n  refundee: String! # The address which receives any remaining reward tokens at `endTime`.\n}\n")),Object(o.b)("h3",{id:"nexttickresult"},"NextTickResult"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Return value of nextInitializedTickWithinOneWord(...)")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type NextTickResult {\n  index: Int32! # Tick index of returned next tick\n  found: Boolean! # True if the returned tick index represents an initialized tick, or false if max or min tick are returned instead\n}\n")),Object(o.b)("h3",{id:"nftpermitoptions"},"NFTPermitOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Permission parameters for NFT transfers, in case the transaction is being sent by an account that does not own the NFT")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type NFTPermitOptions {\n  v: PermitV! \n  r: String! \n  s: String! \n  deadline: BigInt! \n  spender: String! \n}\n")),Object(o.b)("h3",{id:"poolchangeresult"},"PoolChangeResult"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...)")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type PoolChangeResult {\n  amount: TokenAmount! # input or output amount resulting from simulated swap\n  nextPool: Pool! # Pool state after simulated swap\n}\n")),Object(o.b)("h3",{id:"quoteoptions"},"QuoteOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Optional arguments to send to the quoter.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type QuoteOptions {\n  sqrtPriceLimitX96: BigInt # The optional price limit for the trade.\n}\n")),Object(o.b)("h3",{id:"removeliquidityoptions"},"RemoveLiquidityOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options for producing the calldata to exit a position.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type RemoveLiquidityOptions {\n  tokenId: BigInt! # The ID of the token to exit\n  liquidityPercentage: String! # The percentage of position liquidity to exit.\n  slippageTolerance: String! # How much the pool price is allowed to move.\n  deadline: BigInt! # When the transaction expires, in epoch seconds.\n  burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false.\n  permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT\n  collectOptions: CollectOptions! # Parameters to be passed on to collect; tokenId is ignored.\n}\n")),Object(o.b)("h3",{id:"safetransferoptions"},"SafeTransferOptions"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Options to specify when calling safeTransferFrom(...) to transfer an NFT")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type SafeTransferOptions {\n  sender: String! # The account sending the NFT.\n  recipient: String! # The account that should receive the NFT.\n  tokenId: BigInt! # The id of the token being sent.\n  data: String # The optional parameter that passes data to the `onERC721Received` call for the staker\n}\n")),Object(o.b)("h3",{id:"traderoute"},"TradeRoute"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Input used to create a trade")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type TradeRoute {\n  route: Route! # The route of the trade\n  amount: TokenAmount! # The amount being passed in or out, depending on the trade type\n}\n")))}s.isMDXComponent=!0},194:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var i=n(0),o=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),c=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},d=function(e){var t=c(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,a=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,b=d["".concat(a,".").concat(m)]||d[m]||u[m]||r;return n?o.a.createElement(b,p(p({ref:t},s),{},{components:n})):o.a.createElement(b,p({ref:t},s))}));function b(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:i,a[1]=p;for(var s=2;s<r;s++)a[s]=n[s];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);