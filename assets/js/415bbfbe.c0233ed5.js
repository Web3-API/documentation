"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[8881],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),s=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),u=s(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||r;return n?i.createElement(h,a(a({ref:t},d),{},{components:n})):i.createElement(h,a({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[u]="string"==typeof e?e:o,a[1]=p;for(var s=2;s<r;s++)a[s]=n[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5319:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>s});var i=n(7462),o=(n(7294),n(3905));const r={id:"query-types",title:"Query Types"},a=void 0,p={unversionedId:"demos/uniswapv3/types/query-types",id:"demos/uniswapv3/types/query-types",title:"Query Types",description:"AddLiquidityOptions",source:"@site/docs/demos/uniswapv3/types/queryTypes.md",sourceDirName:"demos/uniswapv3/types",slug:"/demos/uniswapv3/types/query-types",permalink:"/demos/uniswapv3/types/query-types",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/demos/uniswapv3/types/queryTypes.md",tags:[],version:"current",frontMatter:{id:"query-types",title:"Query Types"}},l={},s=[{value:"AddLiquidityOptions",id:"addliquidityoptions",level:3},{value:"ClaimOptions",id:"claimoptions",level:3},{value:"CollectOptions",id:"collectoptions",level:3},{value:"CommonAddLiquidityOptions",id:"commonaddliquidityoptions",level:3},{value:"FullWithdrawOptions",id:"fullwithdrawoptions",level:3},{value:"IncentiveKey",id:"incentivekey",level:3},{value:"NextTickResult",id:"nexttickresult",level:3},{value:"NFTPermitOptions",id:"nftpermitoptions",level:3},{value:"PoolChangeResult",id:"poolchangeresult",level:3},{value:"QuoteOptions",id:"quoteoptions",level:3},{value:"RemoveLiquidityOptions",id:"removeliquidityoptions",level:3},{value:"SafeTransferOptions",id:"safetransferoptions",level:3},{value:"TradeRoute",id:"traderoute",level:3}],d={toc:s},u="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"addliquidityoptions"},"AddLiquidityOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Union of MintOptions and IncreaseOptions; one of either recipient or tokenId is required.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type AddLiquidityOptions {\n  recipient: String # The account that should receive the minted NFT.\n  createPool: Boolean # Creates pool if not initialized before mint. Ignored if recipient is not null.\n  tokenId: BigInt # Indicates the ID of the position to increase liquidity for. Ignored if recipient is not null.\n  slippageTolerance: String! \n  deadline: BigInt! \n  useNative: Token \n  token0Permit: PermitOptions \n  token1Permit: PermitOptions \n}\n")),(0,o.kt)("h3",{id:"claimoptions"},"ClaimOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options to specify when claiming rewards.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type ClaimOptions {\n  tokenId: BigInt! # The id of the NFT\n  recipient: String! # Address to send rewards to.\n  amount: BigInt # The amount of `rewardToken` to claim. 0 claims all.\n}\n")),(0,o.kt)("h3",{id:"collectoptions"},"CollectOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options to specify when calling collectCallParameters(...) to collect liquidity provider rewards or removeCallParameters(...) to exit a liquidity position.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type CollectOptions {\n  tokenId: BigInt! # Indicates the ID of the position to collect for. Ignored when CollectOptions is as property of RemoveLiquidityOptions for use in removeCallParameters(...).\n  expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n  expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned\n  recipient: String! # The account that should receive the tokens.\n}\n")),(0,o.kt)("h3",{id:"commonaddliquidityoptions"},"CommonAddLiquidityOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options for producing the calldata to add liquidity.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type CommonAddLiquidityOptions {\n  slippageTolerance: String! # How much the pool price is allowed to move.\n  deadline: BigInt! # When the transaction expires, in epoch seconds.\n  useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false\n  token0Permit: PermitOptions # The optional permit parameters for spending token0\n  token1Permit: PermitOptions # The optional permit parameters for spending token1\n}\n")),(0,o.kt)("h3",{id:"fullwithdrawoptions"},"FullWithdrawOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options to specify when withdrawing tokens")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type FullWithdrawOptions {\n  owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw.\n  data: String # Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.\n  tokenId: BigInt! \n  recipient: String! \n  amount: BigInt \n}\n")),(0,o.kt)("h3",{id:"incentivekey"},"IncentiveKey"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Represents a unique staking program.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type IncentiveKey {\n  rewardToken: Token! # The token rewarded for participating in the staking program.\n  pool: Pool! # The pool that the staked positions must provide in.\n  startTime: BigInt! # The time when the incentive program begins.\n  endTime: BigInt! # The time that the incentive program ends.\n  refundee: String! # The address which receives any remaining reward tokens at `endTime`.\n}\n")),(0,o.kt)("h3",{id:"nexttickresult"},"NextTickResult"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Return value of nextInitializedTickWithinOneWord(...)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type NextTickResult {\n  index: Int32! # Tick index of returned next tick\n  found: Boolean! # True if the returned tick index represents an initialized tick, or false if max or min tick are returned instead\n}\n")),(0,o.kt)("h3",{id:"nftpermitoptions"},"NFTPermitOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Permission parameters for NFT transfers, in case the transaction is being sent by an account that does not own the NFT")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type NFTPermitOptions {\n  v: PermitV! \n  r: String! \n  s: String! \n  deadline: BigInt! \n  spender: String! \n}\n")),(0,o.kt)("h3",{id:"poolchangeresult"},"PoolChangeResult"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type PoolChangeResult {\n  amount: TokenAmount! # input or output amount resulting from simulated swap\n  nextPool: Pool! # Pool state after simulated swap\n}\n")),(0,o.kt)("h3",{id:"quoteoptions"},"QuoteOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Optional arguments to send to the quoter.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type QuoteOptions {\n  sqrtPriceLimitX96: BigInt # The optional price limit for the trade.\n}\n")),(0,o.kt)("h3",{id:"removeliquidityoptions"},"RemoveLiquidityOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options for producing the calldata to exit a position.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type RemoveLiquidityOptions {\n  tokenId: BigInt! # The ID of the token to exit\n  liquidityPercentage: String! # The percentage of position liquidity to exit.\n  slippageTolerance: String! # How much the pool price is allowed to move.\n  deadline: BigInt! # When the transaction expires, in epoch seconds.\n  burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false.\n  permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT\n  collectOptions: CollectOptions! # Parameters to be passed on to collect; tokenId is ignored.\n}\n")),(0,o.kt)("h3",{id:"safetransferoptions"},"SafeTransferOptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Options to specify when calling safeTransferFrom(...) to transfer an NFT")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type SafeTransferOptions {\n  sender: String! # The account sending the NFT.\n  recipient: String! # The account that should receive the NFT.\n  tokenId: BigInt! # The id of the token being sent.\n  data: String # The optional parameter that passes data to the `onERC721Received` call for the staker\n}\n")),(0,o.kt)("h3",{id:"traderoute"},"TradeRoute"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Input used to create a trade")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type TradeRoute {\n  route: Route! # The route of the trade\n  amount: TokenAmount! # The amount being passed in or out, depending on the trade type\n}\n")))}c.isMDXComponent=!0}}]);