"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[1971],{3905:(e,o,t)=>{t.d(o,{Zo:()=>c,kt:()=>h});var n=t(7294);function r(e,o,t){return o in e?Object.defineProperty(e,o,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[o]=t,e}function l(e,o){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);o&&(n=n.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),t.push.apply(t,n)}return t}function a(e){for(var o=1;o<arguments.length;o++){var t=null!=arguments[o]?arguments[o]:{};o%2?l(Object(t),!0).forEach((function(o){r(e,o,t[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(t,o))}))}return e}function p(e,o){if(null==e)return{};var t,n,r=function(e,o){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],o.indexOf(t)>=0||(r[t]=e[t]);return r}(e,o);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],o.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),u=function(e){var o=n.useContext(i),t=o;return e&&(t="function"==typeof e?e(o):a(a({},o),e)),t},c=function(e){var o=u(e.components);return n.createElement(i.Provider,{value:o},e.children)},s="mdxType",k={inlineCode:"code",wrapper:function(e){var o=e.children;return n.createElement(n.Fragment,{},o)}},d=n.forwardRef((function(e,o){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),s=u(t),d=r,h=s["".concat(i,".").concat(d)]||s[d]||k[d]||l;return t?n.createElement(h,a(a({ref:o},c),{},{components:t})):n.createElement(h,a({ref:o},c))}));function h(e,o){var t=arguments,r=o&&o.mdxType;if("string"==typeof e||r){var l=t.length,a=new Array(l);a[0]=d;var p={};for(var i in o)hasOwnProperty.call(o,i)&&(p[i]=o[i]);p.originalType=e,p[s]="string"==typeof e?e:r,a[1]=p;for(var u=2;u<l;u++)a[u]=t[u];return n.createElement.apply(null,a)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},787:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>i,contentTitle:()=>a,default:()=>k,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var n=t(7462),r=(t(7294),t(3905));const l={id:"pool",title:"Pool"},a=void 0,p={unversionedId:"demos/uniswapv3/queries/pool",id:"demos/uniswapv3/queries/pool",title:"Pool",description:"createPool",source:"@site/docs/demos/uniswapv3/queries/pool.md",sourceDirName:"demos/uniswapv3/queries",slug:"/demos/uniswapv3/queries/pool",permalink:"/demos/uniswapv3/queries/pool",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/demos/uniswapv3/queries/pool.md",tags:[],version:"current",frontMatter:{id:"pool",title:"Pool"}},i={},u=[{value:"createPool",id:"createpool",level:3},{value:"getPoolAddress",id:"getpooladdress",level:3},{value:"poolInvolvesToken",id:"poolinvolvestoken",level:3},{value:"poolToken0Price",id:"pooltoken0price",level:3},{value:"poolToken1Price",id:"pooltoken1price",level:3},{value:"poolPriceOf",id:"poolpriceof",level:3},{value:"poolChainId",id:"poolchainid",level:3},{value:"getPoolOutputAmount",id:"getpooloutputamount",level:3},{value:"getPoolInputAmount",id:"getpoolinputamount",level:3},{value:"getPoolTickSpacing",id:"getpooltickspacing",level:3}],c={toc:u},s="wrapper";function k(e){let{components:o,...t}=e;return(0,r.kt)(s,(0,n.Z)({},c,t,{components:o,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"createpool"},"createPool"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Constructs and validates a Pool")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"createPool(\n  tokenA: Token! # The first token of the pool, irrespective of sort order\n  tokenB: Token! # The second token of the pool, irrespective of sort order\n  fee: FeeAmount! # Fee amount for swaps through the pool\n  sqrtRatioX96: BigInt! # Encoded representation of current swap price\n  liquidity: BigInt! # The total liquidity available in the pool\n  tickCurrent: Int32! # Current pool tick\n  ticks: Tick[] # A validated list of all ticks in the pool\n): Pool!\n")),(0,r.kt)("h3",{id:"getpooladdress"},"getPoolAddress"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the Ethereum address of the Pool contract")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"getPoolAddress(\n  tokenA: Token! # The first token of the pool, irrespective of sort order\n  tokenB: Token! # The second token of the pool, irrespective of sort order\n  fee: FeeAmount! # The fee tier of the pool\n  initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary\n): String!\n")),(0,r.kt)("h3",{id:"poolinvolvestoken"},"poolInvolvesToken"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns true if the token is in the Pool (i.e. pool.token0 or pool.token1)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"poolInvolvesToken(\n  pool: Pool! \n  token: Token! \n): Boolean!\n")),(0,r.kt)("h3",{id:"pooltoken0price"},"poolToken0Price"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"poolToken0Price(\n  token0: Token! # The first token of the pool, i.e. pool.token0\n  token1: Token! # The second token of the pool, i.e. pool.token1\n  sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96\n): Price!\n")),(0,r.kt)("h3",{id:"pooltoken1price"},"poolToken1Price"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"poolToken1Price(\n  token0: Token! # The first token of the pool, i.e. pool.token0\n  token1: Token! # The second token of the pool, i.e. pool.token1\n  sqrtRatioX96: BigInt! # Encoded representation of the current price in the pool, i.e. pool.sqrtRatioX96\n): Price!\n")),(0,r.kt)("h3",{id:"poolpriceof"},"poolPriceOf"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the price of the given token in terms of the other token in the pool")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"poolPriceOf(\n  pool: Pool! # Pool that involves the token\n  token: Token! # The token to return the price of\n): Price!\n")),(0,r.kt)("h3",{id:"poolchainid"},"poolChainId"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the chain ID of the tokens in the pool")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"poolChainId(\n  pool: Pool! \n): ChainId!\n")),(0,r.kt)("h3",{id:"getpooloutputamount"},"getPoolOutputAmount"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"getPoolOutputAmount(\n  pool: Pool! # Pool that involves input and output tokens\n  inputAmount: TokenAmount! # The input amount for which to quote the output amount\n  sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit\n): PoolChangeResult!\n")),(0,r.kt)("h3",{id:"getpoolinputamount"},"getPoolInputAmount"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"getPoolInputAmount(\n  pool: Pool! # Pool that involves input and output tokens\n  outputAmount: TokenAmount! # The output amount for which to quote the input amount\n  sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap.\n): PoolChangeResult!\n")),(0,r.kt)("h3",{id:"getpooltickspacing"},"getPoolTickSpacing"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Returns the tick spacing of ticks in the pool")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"getPoolTickSpacing(\n  pool: Pool! \n): Int32!\n")))}k.isMDXComponent=!0}}]);