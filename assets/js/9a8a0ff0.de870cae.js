"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[4559],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(a),d=n,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return a?r.createElement(h,l(l({ref:t},u),{},{components:a})):r.createElement(h,l({ref:t},u))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:n,l[1]=i;for(var p=2;p<o;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>l});var r=a(7294),n=a(6010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:a,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,n.Z)(o.tabItem,l),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>v});var r=a(7462),n=a(7294),o=a(6010),l=a(2466),i=a(6550),s=a(1980),p=a(7392),u=a(12);function c(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:r,default:n}}=e;return{value:t,label:a,attributes:r,default:n}}))}function m(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function d(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const r=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,o=m(e),[l,i]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=a.find((e=>e.default))??a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[s,p]=h({queryString:a,groupId:r}),[c,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,u.Nk)(a);return[r,(0,n.useCallback)((e=>{a&&o.set(e)}),[a,o])]}({groupId:r}),y=(()=>{const e=s??c;return d({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{y&&i(y)}),[y]);return{selectedValue:l,selectValue:(0,n.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),p(e),f(e)}),[p,f,o]),tabValues:o}}var y=a(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:a,selectedValue:i,selectValue:s,tabValues:p}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.o5)(),m=e=>{const t=e.currentTarget,a=u.indexOf(t),r=p[a].value;r!==i&&(c(t),s(r))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},p.map((e=>{let{value:t,label:a,attributes:l}=e;return n.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:d,onClick:m},l,{className:(0,o.Z)("tabs__item",b.tabItem,l?.className,{"tabs__item--active":i===t})}),a??t)})))}function w(e){let{lazy:t,children:a,selectedValue:r}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function k(e){const t=f(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},n.createElement(g,(0,r.Z)({},e,t)),n.createElement(w,(0,r.Z)({},e,t)))}function v(e){const t=(0,y.Z)();return n.createElement(k,(0,r.Z)({key:String(t)},e))}},8805:(e,t,a)=>{a.d(t,{f:()=>o});var r=a(9960),n=a(7294);const o=e=>n.createElement(r.Z,{to:e.to},n.createElement("button",{className:"tutorial-nav-button"},e.text," \u2794"))},260:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>f,frontMatter:()=>s,metadata:()=>u,toc:()=>m});var r=a(7462),n=(a(7294),a(3905)),o=a(4866),l=a(5162),i=a(8805);const s={id:"project-manifest",title:"Project Manifest"},p=void 0,u={unversionedId:"tutorials/create-wraps/part-one/project-manifest",id:"tutorials/create-wraps/part-one/project-manifest",title:"Project Manifest",description:"You're reading Part One of the Create Wraps tutorial, where we learn everything you need to know to productively develop Polywrap wraps.",source:"@site/docs/tutorials/create-wraps/part-one/project-manifest.mdx",sourceDirName:"tutorials/create-wraps/part-one",slug:"/tutorials/create-wraps/part-one/project-manifest",permalink:"/tutorials/create-wraps/part-one/project-manifest",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/create-wraps/part-one/project-manifest.mdx",tags:[],version:"current",frontMatter:{id:"project-manifest",title:"Project Manifest"},sidebar:"docs",previous:{title:"Project Setup",permalink:"/tutorials/create-wraps/part-one/project-setup"},next:{title:"Schema and Codegen",permalink:"/tutorials/create-wraps/part-one/schema-and-codegen"}},c={},m=[{value:"Manifest Content",id:"manifest-content",level:2},{value:"<strong>Project</strong>",id:"project",level:3},{value:"<strong>Source</strong>",id:"source",level:3},{value:"<strong>Extensions</strong>",id:"extensions",level:3},{value:"<strong>Resources</strong>",id:"resources",level:3},{value:"<strong>Next Steps</strong>",id:"next-steps",level:2}],d={toc:m},h="wrapper";function f(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"You're reading Part One of the ",(0,n.kt)("a",{parentName:"p",href:"../introduction"},"Create Wraps")," tutorial, where we learn everything you need to know to productively develop Polywrap wraps.")),(0,n.kt)("p",null,"Each wrap package is described by a ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.yaml")," project manifest file. The project manifest provides the Polywrap CLI with basic information it needs to ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/polywrap/cli/tree/origin-dev/packages/cli#build--b"},(0,n.kt)("inlineCode",{parentName:"a"},"build"))," the wrap, such as where to find the ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.graphql")," schema that we'll review in the next section."),(0,n.kt)("h2",{id:"manifest-content"},"Manifest Content"),(0,n.kt)("p",null,"Let's open the ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.yaml")," manifest, located in the root of our new project folder. The only item you need to change for now is the project name, but we'll briefly discuss each manifest property here since we'll make more changes later on."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="Project Manifest v0.6.0"',title:'"Project',Manifest:!0,'v0.6.0"':!0},"format: 0.6.0   # The manifest format version\nproject:\n  name:         # Name of wrap\n  type:         # Type/language of project\nsource:\n  schema:       # Path to wrap schema\n  module:       # (Optional) Path to module entry file; absent for interface wraps\n  import_abis:  # (Optional) Array of URI redirects used to resolve imports in the schema\n    - uri:      # One of the schema's import URI\n      abi:      # Path to a local ABI or schema. Supported file formats: [*.graphql, *.info, *.json, *.yaml]\nextensions:\n  build:        # (Optional) Path to Build Manifest file\n  docs:         # (Optional) Path to Docs Manifest file\nresources:      # (Optional) Path to Resources directory\n")),(0,n.kt)("h3",{id:"project"},(0,n.kt)("strong",{parentName:"h3"},"Project")),(0,n.kt)("p",null,"As previously suggested, let's ",(0,n.kt)("inlineCode",{parentName:"p"},"name"),' our project "oracle-wrap".'),(0,n.kt)("p",null,"The project ",(0,n.kt)("inlineCode",{parentName:"p"},"type")," is used to determine how to generate code and build the project. It follows the syntax: ",(0,n.kt)("inlineCode",{parentName:"p"},"(wasm|app|plugin)/language"),". So a Rust wrap will have the type ",(0,n.kt)("inlineCode",{parentName:"p"},"wasm/rust"),", and a Rust plugin would have the type ",(0,n.kt)("inlineCode",{parentName:"p"},"plugin/rust"),". The languages that can be used for a ",(0,n.kt)("inlineCode",{parentName:"p"},"wasm")," wrap project are different from the languages used in ",(0,n.kt)("inlineCode",{parentName:"p"},"plugin")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"app")," projects."),(0,n.kt)(o.Z,{groupId:"project-manifest-project",mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"format: 0.6.0\nproject:\n  name: oracle-wrap\n  type: wasm/rust\n"))),(0,n.kt)(l.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"format: 0.6.0\nproject:\n  name: oracle-wrap\n  type: wasm/golang\n"))),(0,n.kt)(l.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"format: 0.6.0\nproject:\n  name: oracle-wrap\n  type: wasm/typescript\n"))),(0,n.kt)(l.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"format: 0.6.0\nproject:\n  name: oracle-wrap\n  type: wasm/assemblyscript\n")))),(0,n.kt)("p",null,'There is one additional type of project called an "interface wrap" (with type ',(0,n.kt)("inlineCode",{parentName:"p"},"interface"),"), which is used to define a wrap interface that can be implemented by other wraps or plugins. We'll discuss interface wraps in greater detail later on in the tutorial."),(0,n.kt)("h3",{id:"source"},(0,n.kt)("strong",{parentName:"h3"},"Source")),(0,n.kt)("p",null,"The project source tells the Polywrap CLI where to find:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The project schema--i.e. the module and types the wrap exports"),(0,n.kt)("li",{parentName:"ul"},"The module entry file that implements the Wrap Schema in code and exports its module"),(0,n.kt)("li",{parentName:"ul"},"The location of a locally-stored Wrap Schema or ",(0,n.kt)("inlineCode",{parentName:"li"},"wrap.info")," ABI file, and an arbitrary URI you'd like to point to it")),(0,n.kt)(o.Z,{groupId:"project-manifest-source",mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  module: ./Cargo.toml\n  schema: ./polywrap.graphql\n"))),(0,n.kt)(l.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  schema: ./polywrap.graphql\n  module: ./go.mod\n"))),(0,n.kt)(l.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  schema: ./polywrap.graphql\n  module: ./bundled/wrap.js\n"))),(0,n.kt)(l.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  module: ./src/index.ts\n  schema: ./polywrap.graphql\n")))),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"The ",(0,n.kt)("inlineCode",{parentName:"p"},"import_abis"),' item is useful during wrap development. Let\'s say you need to import another wrap, "interface wrap", or plugin. All the relevant information is captured in its schema or ',(0,n.kt)("inlineCode",{parentName:"p"},"wrap.info")," ABI. You need the ",(0,n.kt)("inlineCode",{parentName:"p"},"wrap.wasm")," web assembly module to invoke the wrap's methods at runtime, but not to import its module or types at build time. This means you can start building your new wrap without first deploying its dependency."),(0,n.kt)("p",{parentName:"admonition"},"For example, the ",(0,n.kt)("inlineCode",{parentName:"p"},"import_abis"),' feature can be used in a monorepo that contains one "interface wrap" and a set of Wasm wraps or plugins that implement the interface. Each Wasm wrap project might contain an ',(0,n.kt)("inlineCode",{parentName:"p"},"import_abis")," entry with a temporary URI that points to the interface ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.graphql")," schema. The wrap projects would use the temporary URI to import the interface in their own ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.graphql")," schemas, as though the interface were already published.")),(0,n.kt)("h3",{id:"extensions"},(0,n.kt)("strong",{parentName:"h3"},"Extensions")),(0,n.kt)("p",null,"There are two types of manifest extensions you can register in the project manifest: ",(0,n.kt)("inlineCode",{parentName:"p"},"build")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"docs"),". The ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.build.yaml")," build manifest enables developers to customize the wrap build process. The ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap.docs.yaml")," manifest allows you to provide metadata for package registries and include common documentation files such as a ",(0,n.kt)("inlineCode",{parentName:"p"},"README.md"),"."),(0,n.kt)("p",null,"We will use the ",(0,n.kt)("inlineCode",{parentName:"p"},"docs")," manifest extensions later on to include a ",(0,n.kt)("inlineCode",{parentName:"p"},"README.md")," file in our package. We won't be using the ",(0,n.kt)("inlineCode",{parentName:"p"},"build")," extension in Part One of this tutorial, but we'll dive into it in Part Two."),(0,n.kt)("h3",{id:"resources"},(0,n.kt)("strong",{parentName:"h3"},"Resources")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"resources")," attribute allows you to provide a path to a directory that contains arbitrary files you'd like included in the wrap package when deploying the wrap."),(0,n.kt)("h2",{id:"next-steps"},(0,n.kt)("strong",{parentName:"h2"},"Next Steps")),(0,n.kt)("p",null,"Next we'll review the Wrap Schema, generate code bindings, and review what is generated. The generated code bindings are the key to what makes wraps different from ordinary WebAssembly modules, and you'll need to know how to use them. We'll also take a look at the sample module entry file, which imports the generated bindings and uses them to implement the Wrap Schema in code."),(0,n.kt)(i.f,{to:"./schema-and-codegen",text:"Schema and Codegen",mdxType:"NavButton"}))}f.isMDXComponent=!0}}]);