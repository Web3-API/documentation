"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[3625],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>h});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var i=a.createContext({}),u=function(e){var t=a.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},c=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(r),m=n,h=p["".concat(i,".").concat(m)]||p[m]||d[m]||o;return r?a.createElement(h,l(l({ref:t},c),{},{components:r})):a.createElement(h,l({ref:t},c))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,l=new Array(o);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:n,l[1]=s;for(var u=2;u<o;u++)l[u]=r[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>l});var a=r(7294),n=r(6010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:r,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,n.Z)(o.tabItem,l),hidden:r},t)}},4866:(e,t,r)=>{r.d(t,{Z:()=>v});var a=r(7462),n=r(7294),o=r(6010),l=r(2466),s=r(6550),i=r(1980),u=r(7392),c=r(12);function p(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:a,default:n}}=e;return{value:t,label:r,attributes:a,default:n}}))}function d(e){const{values:t,children:r}=e;return(0,n.useMemo)((()=>{const e=t??p(r);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function m(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:r}=e;const a=(0,s.k6)(),o=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,i._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function g(e){const{defaultValue:t,queryString:r=!1,groupId:a}=e,o=d(e),[l,s]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=r.find((e=>e.default))??r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[i,u]=h({queryString:r,groupId:a}),[p,g]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,c.Nk)(r);return[a,(0,n.useCallback)((e=>{r&&o.set(e)}),[r,o])]}({groupId:a}),b=(()=>{const e=i??p;return m({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{b&&s(b)}),[b]);return{selectedValue:l,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),g(e)}),[u,g,o]),tabValues:o}}var b=r(2389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:r,selectedValue:s,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),d=e=>{const t=e.currentTarget,r=c.indexOf(t),a=u[r].value;a!==s&&(p(t),i(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=c.indexOf(e.currentTarget)+1;t=c[r]??c[0];break}case"ArrowLeft":{const r=c.indexOf(e.currentTarget)-1;t=c[r]??c[c.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":r},t)},u.map((e=>{let{value:t,label:r,attributes:l}=e;return n.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},l,{className:(0,o.Z)("tabs__item",f.tabItem,l?.className,{"tabs__item--active":s===t})}),r??t)})))}function w(e){let{lazy:t,children:r,selectedValue:a}=e;const o=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=g(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",f.tabList)},n.createElement(y,(0,a.Z)({},e,t)),n.createElement(w,(0,a.Z)({},e,t)))}function v(e){const t=(0,b.Z)();return n.createElement(k,(0,a.Z)({key:String(t)},e))}},8805:(e,t,r)=>{r.d(t,{f:()=>o});var a=r(9960),n=r(7294);const o=e=>n.createElement(a.Z,{to:e.to},n.createElement("button",{className:"tutorial-nav-button"},e.text," \u2794"))},7987:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>f,contentTitle:()=>g,default:()=>v,frontMatter:()=>h,metadata:()=>b,toc:()=>y});var a=r(7462),n=(r(7294),r(3905)),o=r(4866),l=r(5162);const s={toc:[]},i="wrapper";function u(e){let{components:t,...r}=e;return(0,n.kt)(i,(0,a.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)(o.Z,{groupId:"first-method-empty",mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/lib.rs",title:"src/lib.rs"},'pub mod wrap;\npub use wrap::prelude::*;\n\nimpl ModuleTrait for Module {\n    fn obscure(args: ArgsObscure) -> Result<String, String> {\n        Ok(String::from(""))\n    }\n}\n'))),(0,n.kt)(l.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=module/module.go",title:"module/module.go"},'package module\n\nimport (\n    "example.com/template-wasm-go/module/wrap/types"\n)\n\nfunc Obscure(args *types.ArgsObscure) string {\n    return ""\n}\n'))),(0,n.kt)(l.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},"import { ModuleBase, Args_obscure } from './wrap';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    return \"\";\n  }\n}\n"))),(0,n.kt)(l.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},"import { ModuleBase, Args_obscure } from './wrap';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    return \"\";\n  }\n}\n")))))}u.isMDXComponent=!0;const c={toc:[]},p="wrapper";function d(e){let{components:t,...r}=e;return(0,n.kt)(p,(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)(o.Z,{groupId:"first-method-simple",mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/lib.rs",title:"src/lib.rs"},"pub mod wrap;\npub use wrap::prelude::*;\n\nimpl ModuleTrait for Module {\n    fn obscure(args: ArgsObscure) -> Result<String, String> {\n        // handle default values\n        let chaos_level = args.chaos_level.unwrap_or(1).max(1);\n\n        let mut obscured = String::new();\n        for data in &args.data {\n            // shift each character by the chaos level\n            for c in data.chars() {\n                let char_code = c as u32 + chaos_level as u32;\n                if let Some(new_char) = std::char::from_u32(char_code) {\n                    obscured.push(new_char);\n                }\n            }\n        }\n        Ok(obscured)\n    }\n}\n"))),(0,n.kt)(l.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=module/module.go",title:"module/module.go"},'package module\n\nimport (\n    "example.com/template-wasm-go/module/wrap/types"\n)\n\nfunc Obscure(args *types.ArgsObscure) string {\n    // Handle default values\n    chaosLevel := int32(1)\n    if args.ChaosLevel != nil && *args.ChaosLevel >= 1 {\n        chaosLevel = *args.ChaosLevel\n    }\n\n    var obscured string\n    for _, data := range args.Data {\n        // Shift each character by the chaos level\n        for _, char := range data {\n            charCode := char + rune(chaosLevel)\n            obscured += string(charCode)\n        }\n    }\n    return obscured\n}\n'))),(0,n.kt)(l.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},'import { ModuleBase, Args_obscure } from \'./wrap\';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    // handle default values\n    const chaosLevel = args.chaosLevel || 1;\n\n    // obscure the data with chaos\n    let obscured: string = "";\n    for (let i = 0; i < args.data.length; ++i) {\n      const data = args.data[i];\n      // shift each character by the chaos level\n      obscured += data\n        .split("")\n        .map((char: string) => char.charCodeAt(0) + chaosLevel)\n        .map((charCode: number) => String.fromCharCode(charCode))\n        .join("")\n    }\n    return obscured;\n  }\n}\n'))),(0,n.kt)(l.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},"import { ModuleBase, Args_obscure } from './wrap';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    // handle default values\n    const chaosLevel: i32 = (args.chaosLevel == null || args.chaosLevel!!.unwrap() < 1)\n      ? 1\n      : args.chaosLevel!!.unwrap();\n\n    let obscured: string = \"\";\n    for (let i = 0; i < args.data.length; ++i) {\n      const data = args.data[i];\n      // shift each character by the chaos level\n      for (let j = 0; j < data.length; ++j) {\n        const charCode = data.charCodeAt(j) + chaosLevel;\n        obscured += String.fromCharCode(charCode);\n      }\n    }\n    return obscured;\n  }\n}\n")))))}d.isMDXComponent=!0;var m=r(8805);const h={id:"first-method",title:"First Method"},g=void 0,b={unversionedId:"tutorials/create-wraps/part-one/first-method",id:"tutorials/create-wraps/part-one/first-method",title:"First Method",description:"You're reading Part One of the Create Wraps tutorial, where we learn everything you need to know to productively develop Polywrap wraps.",source:"@site/docs/tutorials/create-wraps/part-one/first-method.mdx",sourceDirName:"tutorials/create-wraps/part-one",slug:"/tutorials/create-wraps/part-one/first-method",permalink:"/tutorials/create-wraps/part-one/first-method",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/create-wraps/part-one/first-method.mdx",tags:[],version:"current",frontMatter:{id:"first-method",title:"First Method"},sidebar:"docs",previous:{title:"Schema and Codegen",permalink:"/tutorials/create-wraps/part-one/schema-and-codegen"},next:{title:"Import and Subinvoke",permalink:"/tutorials/create-wraps/part-one/import-and-subinvoke"}},f={},y=[{value:"<strong>Update the Schema</strong>",id:"update-the-schema",level:2},{value:"<strong>Write the Method</strong>",id:"write-the-method",level:2},{value:"<strong>Build the Project</strong>",id:"build-the-project",level:2},{value:"<strong>Next Steps</strong>",id:"next-steps",level:2}],w={toc:y},k="wrapper";function v(e){let{components:t,...r}=e;return(0,n.kt)(k,(0,a.Z)({},w,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"You're reading Part One of the ",(0,n.kt)("a",{parentName:"p",href:"../introduction"},"Create Wraps")," tutorial, where we learn everything you need to know to productively develop Polywrap wraps.")),(0,n.kt)("p",null,"Let's use what we've learned to implement a method in our wrap. Recall that we are building \"Oracle Wrap\", the wrap that can obscure and illuminate information. We're going to implement the first of Oracle Wrap's two methods, which we'll call ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure"),"."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," method will be a bit contrived, but it will give us a chance to familiarize ourselves with some basics."),(0,n.kt)("p",null,"The goal of ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," is to ensure that data is harder to understand. In this section, we'll implement a simple version. In the next section, we'll improve it with a hashing function that we'll import from another wrap."),(0,n.kt)("h2",{id:"update-the-schema"},(0,n.kt)("strong",{parentName:"h2"},"Update the Schema")),(0,n.kt)("p",null,"We'll let the ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," method take an array of strings so that we can obscure a lot of data at once, and an optional ",(0,n.kt)("inlineCode",{parentName:"p"},"chaosLevel")," to indicate how strongly we want to obscure the data. We'll return the obscured data as a string."),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("pre",{parentName:"admonition"},(0,n.kt)("code",{parentName:"pre"},"UInt8       Int8       String       BigInt         Map<K,V>\nUInt16      Int16      Boolean      BigNumber\nUInt32      Int32      Bytes        JSON\n")),(0,n.kt)("p",{parentName:"admonition"},"The built-in schema types are detailed in the ",(0,n.kt)("a",{parentName:"p",href:"../../../concepts/wrap-schema"},"Wrap Schema")," reference.")),(0,n.kt)("p",null,"If we wanted to add more options, we could pass a custom type with more fields, but we'll keep it simple for now."),(0,n.kt)("p",null,"Go ahead and update the schema with the new method:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="polywrap.graphql"',title:'"polywrap.graphql"'},"type Module {\n    obscure(data: [String!]!, chaosLevel: Int): String!\n}\n")),(0,n.kt)("p",null,"Before we start writing code, we'll want to run ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap codegen")," in the terminal to update our bindings. If you installed the Polywrap CLI locally using the provided ",(0,n.kt)("inlineCode",{parentName:"p"},"package.json"),", you can run ",(0,n.kt)("inlineCode",{parentName:"p"},"yarn codegen")," to do this."),(0,n.kt)("p",null,"If you'd like, feel free to take a look at the ",(0,n.kt)("inlineCode",{parentName:"p"},"wrap")," directory and see how the bindings have changed."),(0,n.kt)("h2",{id:"write-the-method"},(0,n.kt)("strong",{parentName:"h2"},"Write the Method")),(0,n.kt)("p",null,"When you open the module entry file, you'll see that it still has the same ",(0,n.kt)("inlineCode",{parentName:"p"},"Module")," implementation with ",(0,n.kt)("inlineCode",{parentName:"p"},"sampleMethod"),", which no longer exists. Let's replace it with ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," and fix the imports:"),(0,n.kt)(u,{mdxType:"FirstMethodEmpty"}),(0,n.kt)("p",null,"Now let's add a simple implementation of ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," that doesn't use any dependencies. For each string in the data array, we are going to shift each character by ",(0,n.kt)("inlineCode",{parentName:"p"},"chaosLevel"),". Then we'll concatenate the strings (for extra chaos) and return the result."),(0,n.kt)("p",null,"Don't worry too much about the implementation details. We're going to rewrite the method in the next section."),(0,n.kt)(d,{mdxType:"FirstMethodSimple"}),(0,n.kt)("h2",{id:"build-the-project"},(0,n.kt)("strong",{parentName:"h2"},"Build the Project")),(0,n.kt)("p",null,"To make sure our code compiles, let's build the project with the ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap build")," command."),(0,n.kt)("p",null,"The Polywrap CLI typically uses Docker to build wraps. At first this may sound unnecessary, but it's actually very useful. Building Polywrap wraps involves several steps that require additional dependencies. Depending on the source language, the steps may include tasks such as configuring WebAssembly memory and ensuring the wrap will work outside a JavaScript environment. Native build tools, such as Rust's ",(0,n.kt)("inlineCode",{parentName:"p"},"cargo build"),", don't perform all the pre- and post-processing steps that Polywrap wraps require."),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"If you're writing your wrap in Rust, you can use ",(0,n.kt)("inlineCode",{parentName:"p"},"cargo check")," to check your code for errors without building the entire project.")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"polywrap build"),' command has three build "strategies" that you can use to build your wrap:'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},'"vm": Downloads and runs a pre-built Docker image. This is the default.'),(0,n.kt)("li",{parentName:"ul"},'"image": Builds and runs a Docker image.'),(0,n.kt)("li",{parentName:"ul"},'"local": Runs the build script locally, without Docker. The script will attempt to install and use global dependencies. Assumes the host machine is unix-like (i.e. not Windows).')),(0,n.kt)("p",null,"We'll discuss build customization in the ",(0,n.kt)("a",{parentName:"p",href:"tutorials/build-and-deploy-wraps/build-pipeline"},"Build Manifest")," section in Part Two of this guide."),(0,n.kt)("h2",{id:"next-steps"},(0,n.kt)("strong",{parentName:"h2"},"Next Steps")),(0,n.kt)("p",null,"In the next section, we'll improve the ",(0,n.kt)("inlineCode",{parentName:"p"},"obscure")," method by importing a hashing function from another wrap."),(0,n.kt)(m.f,{to:"./import-and-subinvoke",text:"Import and Subinvoke",mdxType:"NavButton"}))}v.isMDXComponent=!0}}]);