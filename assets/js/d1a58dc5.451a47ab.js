"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[1673],{3905:(e,r,t)=>{t.d(r,{Zo:()=>c,kt:()=>m});var n=t(7294);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),p=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},c=function(e){var r=p(e.components);return n.createElement(l.Provider,{value:r},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},v=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),v=a,m=u["".concat(l,".").concat(v)]||u[v]||d[v]||i;return t?n.createElement(m,o(o({ref:r},c),{},{components:t})):n.createElement(m,o({ref:r},c))}));function m(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=v;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}v.displayName="MDXCreateElement"},2072:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=t(7462),a=(t(7294),t(3905));const i={id:"uri-resolver-extensions-js",hide_title:!0},o="@polywrap/uri-resolver-extensions-js",s={unversionedId:"reference/clients/js/libraries/uri-resolver-extensions-js",id:"reference/clients/js/libraries/uri-resolver-extensions-js",title:"@polywrap/uri-resolver-extensions-js",description:"Polywrap URI resolver extensions to customize resolution in the Polywrap Client.",source:"@site/docs/reference/clients/js/libraries/uri-resolver-extensions-js.md",sourceDirName:"reference/clients/js/libraries",slug:"/reference/clients/js/libraries/uri-resolver-extensions-js",permalink:"/reference/clients/js/libraries/uri-resolver-extensions-js",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/reference/clients/js/libraries/uri-resolver-extensions-js.md",tags:[],version:"current",frontMatter:{id:"uri-resolver-extensions-js",hide_title:!0},sidebar:"docs",previous:{title:"@polywrap/tracing-js",permalink:"/reference/clients/js/libraries/tracing-js"},next:{title:"@polywrap/uri-resolvers",permalink:"/reference/clients/js/libraries/uri-resolvers-js"}},l={},p=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"ExtendableUriResolver",id:"extendableuriresolver",level:2},{value:"Properties",id:"properties",level:3},{value:"extInterfaceUri (static)",id:"extinterfaceuri-static",level:4},{value:"extInterfaceUri",id:"extinterfaceuri",level:4},{value:"constructor",id:"constructor",level:3},{value:"Methods",id:"methods",level:3},{value:"getUriResolvers",id:"geturiresolvers",level:4},{value:"tryResolverUri",id:"tryresolveruri",level:4},{value:"getStepDescription (protected)",id:"getstepdescription-protected",level:4},{value:"UriResolverExtensionFileReader",id:"uriresolverextensionfilereader",level:2},{value:"constructor",id:"constructor-1",level:3},{value:"Methods",id:"methods-1",level:3},{value:"readFile",id:"readfile",level:4},{value:"UriResolverWrapper",id:"uriresolverwrapper",level:2},{value:"constructor",id:"constructor-2",level:3},{value:"Methods",id:"methods-2",level:3},{value:"tryResolverUri",id:"tryresolveruri-1",level:4},{value:"Development",id:"development",level:2},{value:"Build",id:"build",level:3},{value:"Test",id:"test",level:3}],c={toc:p},u="wrapper";function d(e){let{components:r,...t}=e;return(0,a.kt)(u,(0,n.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"polywrapuri-resolver-extensions-js"},"@polywrap/uri-resolver-extensions-js"),(0,a.kt)("a",{href:"https://www.npmjs.com/package/@polywrap/uri-resolver-extensions-js",target:"_blank",rel:"noopener noreferrer"},(0,a.kt)("img",{src:"https://img.shields.io/npm/v/@polywrap/uri-resolver-extensions-js.svg",alt:"npm"})),(0,a.kt)("br",null),(0,a.kt)("br",null),"Polywrap URI resolver extensions to customize resolution in the Polywrap Client.",(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save @polywrap/uri-resolver-extensions-js\n")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"If you build a configuration for the Polywrap client using the ",(0,a.kt)("inlineCode",{parentName:"p"},"ClientConfigBuilder")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"@polywrap/client-config-builder-js")," package, the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExtendableUriResovler")," is included by default. In that case you only need to register implementations of the URI Resolver Extension interface."),(0,a.kt)("p",null,"Otherwise, you must also add the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExtendableUriResolver")," to your resolver."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'  const clientConfig: CoreClientConfig = {\n    interfaces: new UriMap<Uri[]>([\n      [\n        Uri.from("wrap://ens/uri-resolver.core.polywrap.eth"),\n        [\n          Uri.from("wrap://ens/fs-resolver.polywrap.eth"),\n          Uri.from("wrap://ens/ipfs-resolver.polywrap.eth"),\n          Uri.from("wrap://ens/ens-resolver.polywrap.eth"),\n        ],\n      ],\n    ]),\n    resolver: RecursiveResolver.from(\n      [\n        StaticResolver.from([\n          ...redirects,\n          ...wrappers,\n          ...packages,\n        ]),\n        new ExtendableUriResolver(),\n      ]\n    )\n  };\n')),(0,a.kt)("h1",{id:"reference"},"Reference"),(0,a.kt)("h2",{id:"extendableuriresolver"},"ExtendableUriResolver"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A Uri Resolver that delegates resolution to wrappers implementing the\n * URI Resolver Extension Interface.\n * */\nexport class ExtendableUriResolver extends UriResolverAggregatorBase<\n  Error,\n  Error\n> \n")),(0,a.kt)("h3",{id:"properties"},"Properties"),(0,a.kt)("h4",{id:"extinterfaceuri-static"},"extInterfaceUri (static)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'  /** The supported interface URIs to which resolver-ext implementations should be registered */\n  public static defaultExtInterfaceUris: Uri[] = [\n    Uri.from("wrap://ens/wraps.eth:uri-resolver-ext@1.1.0"),\n    Uri.from("wrap://ens/wraps.eth:uri-resolver-ext@1.0.0"),\n  ];\n')),(0,a.kt)("h4",{id:"extinterfaceuri"},"extInterfaceUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** The active interface URIs to which implementations should be registered */\n  public readonly extInterfaceUris: Uri[];\n")),(0,a.kt)("h3",{id:"constructor"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'  /**\n   * Create an ExtendableUriResolver\n   *\n   * @param extInterfaceUris - URI Resolver Interface URIs\n   * @param resolverName - Name to use in resolution history output\n   * */\n  constructor(\n    extInterfaceUris: Uri[] = ExtendableUriResolver.defaultExtInterfaceUris,\n    resolverName = "ExtendableUriResolver"\n  ) \n')),(0,a.kt)("h3",{id:"methods"},"Methods"),(0,a.kt)("h4",{id:"geturiresolvers"},"getUriResolvers"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Get a list of URI Resolvers\n   *\n   * @param uri - the URI to query for resolvers\n   * @param client - a CoreClient instance that can be used to make an invocation\n   * @param resolutionContext - the current URI resolution context\n   *\n   * @returns a list of IUriResolver or an error\n   * */\n  async getUriResolvers(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<IUriResolver<unknown>[], Error>> \n")),(0,a.kt)("h4",{id:"tryresolveruri"},"tryResolverUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Attempts resolution with each the URI Resolver Extension wrappers sequentially.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, Error>> \n")),(0,a.kt)("h4",{id:"getstepdescription-protected"},"getStepDescription (protected)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected getStepDescription = (): string \n")),(0,a.kt)("h2",{id:"uriresolverextensionfilereader"},"UriResolverExtensionFileReader"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** An IFileReader that reads files by invoking URI Resolver Extension wrappers */\nexport class UriResolverExtensionFileReader implements IFileReader \n")),(0,a.kt)("h3",{id:"constructor-1"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a UriResolverExtensionFileReader\n   *\n   * @param _resolverExtensionUri - URI of the URI Resolver Extension wrapper\n   * @param _wrapperUri - URI of the wrap package to read from\n   * @param _client - A CoreClient instance\n   * */\n  constructor(\n    private readonly _resolverExtensionUri: Uri,\n    private readonly _wrapperUri: Uri,\n    private readonly _client: CoreClient\n  ) \n")),(0,a.kt)("h3",{id:"methods-1"},"Methods"),(0,a.kt)("h4",{id:"readfile"},"readFile"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Read a file\n   *\n   * @param filePath - the file's path from the wrap package root\n   *\n   * @returns a Result containing a buffer if successful, or an error\n   * */\n  async readFile(filePath: string): Promise<Result<Uint8Array, Error>> \n")),(0,a.kt)("h2",{id:"uriresolverwrapper"},"UriResolverWrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * An IUriResolver that delegates resolution to a wrapper that implements\n * the URI Resolver Extension Interface\n * */\nexport class UriResolverWrapper implements IUriResolver<unknown> \n")),(0,a.kt)("h3",{id:"constructor-2"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * construct a UriResolverWrapper\n   *\n   * @param implementationUri - URI that resolves to a URI Resolver Extension implementation\n   * */\n  constructor(public readonly implementationUri: Uri) \n")),(0,a.kt)("h3",{id:"methods-2"},"Methods"),(0,a.kt)("h4",{id:"tryresolveruri-1"},"tryResolverUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Attempt to resolve a URI by invoking a URI Resolver Extension wrapper, then\n   * parse the result to a wrap package, a wrapper, or a URI\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, unknown>> \n")),(0,a.kt)("h2",{id:"development"},"Development"),(0,a.kt)("p",null,"This package is open-source. It lives within the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/polywrap/javascript-client"},"Polywrap JavaScript Client repository"),". Contributions from the community are welcomed!"),(0,a.kt)("h3",{id:"build"},"Build"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"nvm use && yarn install && yarn build\n")),(0,a.kt)("h3",{id:"test"},"Test"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"yarn test\n")))}d.isMDXComponent=!0}}]);