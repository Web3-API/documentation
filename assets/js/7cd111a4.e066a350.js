"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[4113],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>h});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function u(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var p=r.createContext({}),i=function(e){var t=r.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):u(u({},t),e)),a},s=function(e){var t=i(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,p=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),c=i(a),m=n,h=c["".concat(p,".").concat(m)]||c[m]||l[m]||o;return a?r.createElement(h,u(u({ref:t},s),{},{components:a})):r.createElement(h,u({ref:t},s))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,u=new Array(o);u[0]=m;var d={};for(var p in t)hasOwnProperty.call(t,p)&&(d[p]=t[p]);d.originalType=e,d[c]="string"==typeof e?e:n,u[1]=d;for(var i=2;i<o;i++)u[i]=a[i];return r.createElement.apply(null,u)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2269:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>l,frontMatter:()=>o,metadata:()=>d,toc:()=>i});var r=a(7462),n=(a(7294),a(3905));const o={id:"trade",title:"Trade"},u=void 0,d={unversionedId:"demos/uniswapv3/queries/trade",id:"demos/uniswapv3/queries/trade",title:"Trade",description:"createTradeExactIn",source:"@site/docs/demos/uniswapv3/queries/trade.md",sourceDirName:"demos/uniswapv3/queries",slug:"/demos/uniswapv3/queries/trade",permalink:"/demos/uniswapv3/queries/trade",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/demos/uniswapv3/queries/trade.md",tags:[],version:"current",frontMatter:{id:"trade",title:"Trade"}},p={},i=[{value:"createTradeExactIn",id:"createtradeexactin",level:3},{value:"createTradeExactOut",id:"createtradeexactout",level:3},{value:"createTradeFromRoute",id:"createtradefromroute",level:3},{value:"createTradeFromRoutes",id:"createtradefromroutes",level:3},{value:"createUncheckedTrade",id:"createuncheckedtrade",level:3},{value:"createUncheckedTradeWithMultipleRoutes",id:"createuncheckedtradewithmultipleroutes",level:3},{value:"tradeInputAmount",id:"tradeinputamount",level:3},{value:"tradeOutputAmount",id:"tradeoutputamount",level:3},{value:"tradeExecutionPrice",id:"tradeexecutionprice",level:3},{value:"tradePriceImpact",id:"tradepriceimpact",level:3},{value:"tradeMinimumAmountOut",id:"trademinimumamountout",level:3},{value:"tradeMaximumAmountIn",id:"trademaximumamountin",level:3},{value:"tradeWorstExecutionPrice",id:"tradeworstexecutionprice",level:3},{value:"bestTradeExactIn",id:"besttradeexactin",level:3},{value:"bestTradeExactOut",id:"besttradeexactout",level:3}],s={toc:i},c="wrapper";function l(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,r.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h3",{id:"createtradeexactin"},"createTradeExactIn"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Constructs an exact in trade with the given amount in and route")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createTradeExactIn(\n  tradeRoute: TradeRoute! # The route of the exact in trade and the amount being passed in\n): Trade!\n")),(0,n.kt)("h3",{id:"createtradeexactout"},"createTradeExactOut"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Constructs an exact out trade with the given amount out and route")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createTradeExactOut(\n  tradeRoute: TradeRoute! # The route of the exact out trade and the amount returned\n): Trade!\n")),(0,n.kt)("h3",{id:"createtradefromroute"},"createTradeFromRoute"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Constructs a trade by simulating swaps through the given route")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createTradeFromRoute(\n  tradeRoute: TradeRoute! # The route to swap through and the amount specified, either input or output, depending on the trade type\n  tradeType: TradeType! # Whether the trade is an exact input or exact output swap\n): Trade!\n")),(0,n.kt)("h3",{id:"createtradefromroutes"},"createTradeFromRoutes"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Constructs a trade by simulating swaps through the given routes")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createTradeFromRoutes(\n  tradeRoutes: TradeRoute[]! # The routes to swap through and how much of the amount should be routed through each\n  tradeType: TradeType! # Whether the trade is an exact input or exact output swap\n): Trade!\n")),(0,n.kt)("h3",{id:"createuncheckedtrade"},"createUncheckedTrade"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createUncheckedTrade(\n  swap: TradeSwap! # The route to swap through, the amount being passed in, and the amount returned when the trade is executed\n  tradeType: TradeType! # The type of the trade, either exact in or exact out\n): Trade!\n")),(0,n.kt)("h3",{id:"createuncheckedtradewithmultipleroutes"},"createUncheckedTradeWithMultipleRoutes"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"createUncheckedTradeWithMultipleRoutes(\n  swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed\n  tradeType: TradeType! # The type of the trade, either exact in or exact out\n): Trade!\n")),(0,n.kt)("h3",{id:"tradeinputamount"},"tradeInputAmount"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"The input amount for the trade assuming no slippage")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeInputAmount(\n  swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed\n): TokenAmount!\n")),(0,n.kt)("h3",{id:"tradeoutputamount"},"tradeOutputAmount"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"The output amount for the trade assuming no slippage")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeOutputAmount(\n  swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed\n): TokenAmount!\n")),(0,n.kt)("h3",{id:"tradeexecutionprice"},"tradeExecutionPrice"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"The price expressed in terms of output amount/input amount")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeExecutionPrice(\n  inputAmount: TokenAmount! # The trade input amount, e.g. from Trade object or tradeInputAmount(...)\n  outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...)\n): Price!\n")),(0,n.kt)("h3",{id:"tradepriceimpact"},"tradePriceImpact"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Returns the percent difference between the route's mid price and the price impact")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradePriceImpact(\n  swaps: TradeSwap[]! # The routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed\n  outputAmount: TokenAmount! # The trade output amount, e.g. from Trade object or tradeOutputAmount(...)\n): Fraction!\n")),(0,n.kt)("h3",{id:"trademinimumamountout"},"tradeMinimumAmountOut"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Get the minimum amount that must be received from the trade for the given slippage tolerance")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeMinimumAmountOut(\n  slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage\n  amountOut: TokenAmount! # The output amount of the trade, before slippage, e.g. from Trade object or tradeOutputAmount(...)\n  tradeType: TradeType! # The type of the trade, either exact in or exact out\n): TokenAmount!\n")),(0,n.kt)("h3",{id:"trademaximumamountin"},"tradeMaximumAmountIn"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Get the maximum amount in that can be spent via the trade for the given slippage tolerance")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeMaximumAmountIn(\n  slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. '0.03') that represents a percentage\n  amountIn: TokenAmount! # The input amount of the trade, before slippage, e.g. from Trade object or tradeInputAmount(...)\n  tradeType: TradeType! # The type of the trade, either exact in or exact out\n): TokenAmount!\n")),(0,n.kt)("h3",{id:"tradeworstexecutionprice"},"tradeWorstExecutionPrice"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Return the execution price after accounting for slippage tolerance")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"tradeWorstExecutionPrice(\n  trade: Trade! # Trade for which to calculate execution price\n  slippageTolerance: String! # The allowed tolerated slippage\n): Price!\n")),(0,n.kt)("h3",{id:"besttradeexactin"},"bestTradeExactIn"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Given a list of pools, and a fixed amount in, returns the top ",(0,n.kt)("inlineCode",{parentName:"em"},"maxNumResults")," trades that go from an input token\namount to an output token, making at most ",(0,n.kt)("inlineCode",{parentName:"em"},"maxHops")," hops.\nNote this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\nthe amount in among multiple routes.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"bestTradeExactIn(\n  pools: Pool[]! # The pools to consider in finding the best trade\n  amountIn: TokenAmount! # Exact amount of input currency to spend\n  tokenOut: Token! # The desired currency out\n  options: BestTradeOptions # Options used when determining the best trade\n): Trade[]!\n")),(0,n.kt)("h3",{id:"besttradeexactout"},"bestTradeExactOut"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"similar to bestTradeExactIn(...) but instead targets a fixed output amount\ngiven a list of pools, and a fixed amount out, returns the top ",(0,n.kt)("inlineCode",{parentName:"em"},"maxNumResults")," trades that go from an input token\nto an output token amount, making at most ",(0,n.kt)("inlineCode",{parentName:"em"},"maxHops")," hops\nnote this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\nthe amount in among multiple routes.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"bestTradeExactOut(\n  pools: Pool[]! # The pools to consider in finding the best trade\n  tokenIn: Token! # The currency to spend\n  amountOut: TokenAmount! # The desired currency amount out\n  options: BestTradeOptions # Options used when determining the best trade\n): Trade[]!\n")))}l.isMDXComponent=!0}}]);