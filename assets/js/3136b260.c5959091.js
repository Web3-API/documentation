"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[3245],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),d=a,m=c["".concat(l,".").concat(d)]||c[d]||g[d]||i;return t?r.createElement(m,o(o({ref:n},u),{},{components:t})):r.createElement(m,o({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7427:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=t(7462),a=(t(7294),t(3905));const i={id:"client-js",hide_title:!0},o="@polywrap/client-js",s={unversionedId:"reference/clients/js/client-js",id:"reference/clients/js/client-js",title:"@polywrap/client-js",description:"The Polywrap JavaScript client invokes functions of wrappers and plugins. It's designed to run in any environment that can execute JavaScript (think websites, node scripts, etc.). It has TypeScript support.",source:"@site/docs/reference/clients/js/client-js.md",sourceDirName:"reference/clients/js",slug:"/reference/clients/js/client-js",permalink:"/reference/clients/js/client-js",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/reference/clients/js/client-js.md",tags:[],version:"current",frontMatter:{id:"client-js",hide_title:!0},sidebar:"docs",previous:{title:"Infra",permalink:"/reference/cli/commands/infra"},next:{title:"PolywrapClient Config Builder",permalink:"/reference/clients/js/client-config-builder-js"}},l={},p=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Instantiate the client",id:"instantiate-the-client",level:3},{value:"Invoke a wrapper",id:"invoke-a-wrapper",level:3},{value:"Configure the client",id:"configure-the-client",level:3},{value:"Reference",id:"reference",level:2},{value:"Constructor",id:"constructor",level:3},{value:"getConfig",id:"getconfig",level:3},{value:"setTracingEnabled",id:"settracingenabled",level:3},{value:"getRedirects",id:"getredirects",level:3},{value:"getPlugins",id:"getplugins",level:3},{value:"getPluginByUri",id:"getpluginbyuri",level:3},{value:"getInterfaces",id:"getinterfaces",level:3},{value:"getEnvs",id:"getenvs",level:3},{value:"getUriResolver",id:"geturiresolver",level:3},{value:"getEnvByUri",id:"getenvbyuri",level:3},{value:"getManifest",id:"getmanifest",level:3},{value:"getFile",id:"getfile",level:3},{value:"getImplementations",id:"getimplementations",level:3},{value:"query",id:"query",level:3},{value:"invokeWrapper",id:"invokewrapper",level:3},{value:"invoke",id:"invoke",level:3},{value:"subscribe",id:"subscribe",level:3},{value:"tryResolveUri",id:"tryresolveuri",level:3},{value:"loadWrapper",id:"loadwrapper",level:3},{value:"Development",id:"development",level:2},{value:"Build",id:"build",level:3},{value:"Test",id:"test",level:3}],u={toc:p},c="wrapper";function g(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"polywrapclient-js"},"@polywrap/client-js"),(0,a.kt)("a",{href:"https://www.npmjs.com/package/@polywrap/client-js",target:"_blank",rel:"noopener noreferrer"},(0,a.kt)("img",{src:"https://img.shields.io/npm/v/@polywrap/client-js.svg",alt:"npm"})),(0,a.kt)("br",null),(0,a.kt)("br",null),"The Polywrap JavaScript client invokes functions of wrappers and plugins. It's designed to run in any environment that can execute JavaScript (think websites, node scripts, etc.). It has TypeScript support.",(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save @polywrap/client-js\n")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("h3",{id:"instantiate-the-client"},"Instantiate the client"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { PolywrapClient } from "@polywrap/client-js";\n\nconst client = new PolywrapClient();\n')),(0,a.kt)("h3",{id:"invoke-a-wrapper"},"Invoke a wrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'await client.invoke({\n  uri: "ens/rinkeby/helloworld.dev.polywrap.eth",\n  method: "logMessage",\n  args: {\n    message: "Hello World!"\n  }\n});\n')),(0,a.kt)("h3",{id:"configure-the-client"},"Configure the client"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const config = {\n  // redirect queries from one uri to another\n  redirects: [\n    {\n      from: "wrap://ens/from.eth",\n      to: "wrap://ens/to.eth",\n    }\n  ],\n  // declare and configure plugin wrappers\n  plugins: [\n    {\n      uri: "wrap://ens/ipfs.polywrap.eth",\n      plugin: ipfsPlugin({}),\n    },\n  ],\n  // declare interface implementations\n  interfaces: [\n    {\n      interface: "wrap://ens/uri-resolver.core.polywrap.eth",\n      implementations: [\n        "wrap://ens/ipfs-resolver.polywrap.eth",\n      ],\n    },\n  ],\n  // set environmental variables for a wrapper\n  envs: [\n    {\n      uri: "wrap://ens/ipfs.polywrap.eth",\n      env: {\n        provider: "https://ipfs.wrappers.io",\n      },\n    },\n  ],\n  \n  // ADVANCED USAGE:\n  \n  // customize URI resolution\n  resolver: new RecursiveResolver(\n    new PackageToWrapperCacheResolver(wrapperCache, [\n      new LegacyRedirectsResolver(),\n      new LegacyPluginsResolver(),\n      new ExtendableUriResolver(),\n    ])\n  ),\n\n  // custom wrapper cache\n  wrapperCache: new WrapperCache(),\n  \n  // tracer configuration - see @polywrap/tracing-js package\n  tracerConfig: { ... },\n};\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// create a client by modifying the default configuration bundle\nconst client = new PolywrapClient(config);\n\n// or remove and replace the default configuration\nconst altClient = new PolywrapClient(config, { noDefaults: true });\n")),(0,a.kt)("h2",{id:"reference"},"Reference"),(0,a.kt)("h3",{id:"constructor"},"Constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Instantiate a PolywrapClient\n *\n * @param config - a whole or partial client configuration\n * @param options - { noDefaults?: boolean }\n */\nconstructor(config?: Partial<PolywrapClientConfig<string | Uri>>, options?: {\n  noDefaults?: boolean;\n});\n")),(0,a.kt)("h3",{id:"getconfig"},"getConfig"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Returns the configuration used to instantiate the client\n *\n * @returns an immutable Polywrap client config\n */\ngetConfig(): PolywrapClientConfig<Uri>;\n")),(0,a.kt)("h3",{id:"settracingenabled"},"setTracingEnabled"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Enable tracing for intricate debugging\n *\n * @remarks\n * Tracing uses the @polywrap/tracing-js package\n *\n * @param tracerConfig - configure options such as the tracing level\n * @returns void\n */\nsetTracingEnabled(tracerConfig?: Partial<TracerConfig>): void;\n")),(0,a.kt)("h3",{id:"getredirects"},"getRedirects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all uri redirects from the configuration used to instantiate the client\n *\n * @returns an array of uri redirects\n */\ngetRedirects(): readonly UriRedirect<Uri>[];\n")),(0,a.kt)("h3",{id:"getplugins"},"getPlugins"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all plugin registrations from the configuration used to instantiate the client\n *\n * @returns an array of plugin registrations\n */\ngetPlugins(): readonly PluginRegistration<Uri>[];\n")),(0,a.kt)("h3",{id:"getpluginbyuri"},"getPluginByUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns a plugin package from the configuration used to instantiate the client\n *\n * @param uri - the uri used to register the plugin\n * @returns a plugin package, or undefined if a plugin is not found at the given uri\n */\ngetPluginByUri<TUri extends Uri | string>(uri: TUri): PluginPackage<unknown> | undefined;\n")),(0,a.kt)("h3",{id:"getinterfaces"},"getInterfaces"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all interfaces from the configuration used to instantiate the client\n *\n * @returns an array of interfaces and their registered implementations\n */\ngetInterfaces(): readonly InterfaceImplementations<Uri>[];\n")),(0,a.kt)("h3",{id:"getenvs"},"getEnvs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all env registrations from the configuration used to instantiate the client\n *\n * @returns an array of env objects containing wrapper environmental variables\n */\ngetEnvs(): readonly Env<Uri>[];\n")),(0,a.kt)("h3",{id:"geturiresolver"},"getUriResolver"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns the URI resolver from the configuration used to instantiate the client\n *\n * @returns an object that implements the IUriResolver interface\n */\ngetUriResolver(): IUriResolver<unknown>;\n")),(0,a.kt)("h3",{id:"getenvbyuri"},"getEnvByUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns an env (a set of environmental variables) from the configuration used to instantiate the client\n *\n * @param uri - the URI used to register the env\n * @returns an env, or undefined if an env is not found at the given URI\n */\ngetEnvByUri<TUri extends Uri | string>(uri: TUri): Env<Uri> | undefined;\n")),(0,a.kt)("h3",{id:"getmanifest"},"getManifest"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns a package's wrap manifest\n *\n * @param uri - a wrap URI\n * @param options - { noValidate?: boolean }\n * @returns a Result containing the WrapManifest if the request was successful\n */\ngetManifest<TUri extends Uri | string>(uri: TUri, options?: GetManifestOptions): Promise<Result<WrapManifest, Error>>;\n")),(0,a.kt)("h3",{id:"getfile"},"getFile"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'/**\n * returns a file contained in a wrap package\n *\n * @param uri - a wrap URI\n * @param options - { path: string; encoding?: "utf-8" | string }\n * @returns a Promise of a Result containing a file if the request was successful\n */\ngetFile<TUri extends Uri | string>(uri: TUri, options: GetFileOptions): Promise<Result<string | Uint8Array, Error>>;\n')),(0,a.kt)("h3",{id:"getimplementations"},"getImplementations"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns the interface implementations associated with an interface URI\n *  from the configuration used to instantiate the client\n *\n * @param uri - a wrap URI\n * @param options - { applyRedirects?: boolean }\n * @returns a Result containing URI array if the request was successful\n */\ngetImplementations<TUri extends Uri | string>(uri: TUri, options?: GetImplementationsOptions): Result<TUri[], Error>;\n")),(0,a.kt)("h3",{id:"query"},"query"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using GraphQL query syntax\n *\n * @remarks\n * This method behaves similar to the invoke method and allows parallel requests,\n * but the syntax is more verbose. If the query is successful, data will be returned\n * and the `error` value of the returned object will be undefined. If the query fails,\n * the data property will be undefined and the error property will be populated.\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // The GraphQL query to parse and execute, leading to one or more Wrapper invocations.\n *   query: string | QueryDocument;\n *\n *   // Variables referenced within the query string via GraphQL's '$variable' syntax.\n *   variables?: TVariables;\n * }\n *\n * @returns A Promise containing an object with either the data or an error\n */\nquery<TData extends Record<string, unknown> = Record<string, unknown>, TVariables extends Record<string, unknown> = Record<string, unknown>, TUri extends Uri | string = string>(options: QueryOptions<TVariables, TUri>): Promise<QueryResult<TData>>;\n")),(0,a.kt)("h3",{id:"invokewrapper"},"invokeWrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using standard syntax and an instance of the wrapper\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\ninvokeWrapper<TData = unknown, TUri extends Uri | string = string>(options: InvokerOptions<TUri> & {\n    wrapper: Wrapper;\n}): Promise<InvokeResult<TData>>;\n")),(0,a.kt)("h3",{id:"invoke"},"invoke"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using standard syntax.\n * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper.\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\ninvoke<TData = unknown, TUri extends Uri | string = string>(options: InvokerOptions<TUri>): Promise<InvokeResult<TData>>;\n")),(0,a.kt)("h3",{id:"subscribe"},"subscribe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper at a regular frequency (within ~16ms)\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n *\n *   // the frequency at which to perform the invocation\n *   frequency?: {\n *     ms?: number;\n *     sec?: number;\n *     min?: number;\n *     hours?: number;\n *   }\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\nsubscribe<TData = unknown, TUri extends Uri | string = string>(options: SubscribeOptions<TUri>): Subscription<TData>;\n")),(0,a.kt)("h3",{id:"tryresolveuri"},"tryResolveUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Resolve a URI to a wrap package, a wrapper, or a uri\n *\n * @param options - { uri: TUri; resolutionContext?: IUriResolutionContext }\n * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n */\ntryResolveUri<TUri extends Uri | string>(options: TryResolveUriOptions<TUri>): Promise<Result<UriPackageOrWrapper, unknown>>;\n")),(0,a.kt)("h3",{id:"loadwrapper"},"loadWrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'/**\n * Resolve a URI to a wrap package or wrapper.\n * If the URI resolves to wrap package, load the wrapper.\n *\n * @remarks\n * Unlike other methods, `loadWrapper` does not accept a string URI.\n * You can create a Uri (from the `@polywrap/core-js` package) using `Uri.from("wrap://...")`\n *\n * @param uri: the Uri to resolve\n * @param resolutionContext? a resolution context\n * @param options - { noValidate?: boolean }\n * @returns A Promise with a Result containing either a wrapper if successful\n */\nloadWrapper(uri: Uri, resolutionContext?: IUriResolutionContext, options?: DeserializeManifestOptions): Promise<Result<Wrapper, Error>>;\n')),(0,a.kt)("h2",{id:"development"},"Development"),(0,a.kt)("p",null,"The Polywrap JavaScript client is open-source. It lives within the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/polywrap/toolchain/tree/origin/packages/js/client"},"Polywrap toolchain monorepo"),". Contributions from the community are welcomed!"),(0,a.kt)("h3",{id:"build"},"Build"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"nvm use && yarn install && yarn build\n")),(0,a.kt)("h3",{id:"test"},"Test"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"yarn test\n")))}g.isMDXComponent=!0}}]);