"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[4825],{3905:(e,n,r)=>{r.d(n,{Zo:()=>u,kt:()=>f});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=t.createContext({}),p=function(e){var n=t.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},u=function(e){var n=p(e.components);return t.createElement(l.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},v=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(r),v=a,f=c["".concat(l,".").concat(v)]||c[v]||d[v]||i;return r?t.createElement(f,o(o({ref:n},u),{},{components:r})):t.createElement(f,o({ref:n},u))}));function f(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=v;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=r[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}v.displayName="MDXCreateElement"},2065:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var t=r(7462),a=(r(7294),r(3905));const i={id:"core-js",hide_title:!0},o="@polywrap/core-js",s={unversionedId:"reference/clients/js/libraries/core-js",id:"reference/clients/js/libraries/core-js",title:"@polywrap/core-js",description:"A TypeScript / JavaScript implementation of the WRAP standard, including all fundamental types & algorithms.",source:"@site/docs/reference/clients/js/libraries/core-js.md",sourceDirName:"reference/clients/js/libraries",slug:"/reference/clients/js/libraries/core-js",permalink:"/reference/clients/js/libraries/core-js",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/reference/clients/js/libraries/core-js.md",tags:[],version:"current",frontMatter:{id:"core-js",hide_title:!0},sidebar:"docs",previous:{title:"@polywrap/asyncify-js",permalink:"/reference/clients/js/libraries/asyncify-js"},next:{title:"@polywrap/msgpack-js",permalink:"/reference/clients/js/libraries/msgpack-js"}},l={},p=[{value:"Types",id:"types",level:2},{value:"CoreClient",id:"coreclient",level:3},{value:"Env",id:"env",level:3},{value:"Invoke",id:"invoke",level:3},{value:"IUriPackage",id:"iuripackage",level:3},{value:"IUriRedirect",id:"iuriredirect",level:3},{value:"IUriWrapper",id:"iuriwrapper",level:3},{value:"IWrapPackage",id:"iwrappackage",level:3},{value:"MaybeAsync",id:"maybeasync",level:3},{value:"Uri",id:"uri",level:3},{value:"UriConfig",id:"uriconfig",level:4},{value:"Uri",id:"uri-1",level:4},{value:"constructor",id:"constructor",level:5},{value:"authority",id:"authority",level:5},{value:"path",id:"path",level:5},{value:"uri",id:"uri-2",level:5},{value:"equals",id:"equals",level:5},{value:"isUri",id:"isuri",level:5},{value:"isValidUri",id:"isvaliduri",level:5},{value:"toString",id:"tostring",level:5},{value:"toJSON",id:"tojson",level:5},{value:"parseUri",id:"parseuri",level:5},{value:"from",id:"from",level:5},{value:"UriResolver",id:"uriresolver",level:3},{value:"Wrapper",id:"wrapper",level:3},{value:"UriResolverInterface",id:"uriresolverinterface",level:2},{value:"MaybeUriOrManifest",id:"maybeuriormanifest",level:3},{value:"Module",id:"module",level:3},{value:"tryResolveUri",id:"tryresolveuri",level:4},{value:"getFile",id:"getfile",level:4},{value:"Uri Resolution",id:"uri-resolution",level:2},{value:"IUriResolutionContext",id:"iuriresolutioncontext",level:3},{value:"IUriResolutionStep",id:"iuriresolutionstep",level:3},{value:"IUriResolver",id:"iuriresolver",level:3},{value:"UriPackageOrWrapper",id:"uripackageorwrapper",level:3},{value:"UriResolutionContext",id:"uriresolutioncontext",level:3},{value:"constructor",id:"constructor-1",level:4}],u={toc:p},c="wrapper";function d(e){let{components:n,...r}=e;return(0,a.kt)(c,(0,t.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"polywrapcore-js"},"@polywrap/core-js"),(0,a.kt)("p",null,"A TypeScript / JavaScript implementation of the WRAP standard, including all fundamental types & algorithms."),(0,a.kt)("h1",{id:"reference"},"Reference"),(0,a.kt)("h2",{id:"types"},"Types"),(0,a.kt)("h3",{id:"coreclient"},"CoreClient"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Core Client configuration that can be passed to the PolywrapClient or PolywrapCoreClient constructors */\nexport interface CoreClientConfig {\n  /** register interface implementations */\n  readonly interfaces?: ReadonlyUriMap<readonly Uri[]>;\n\n  /** set environmental variables for a wrapper */\n  readonly envs?: ReadonlyUriMap<WrapperEnv>;\n\n  /** configure URI resolution for redirects, packages, and wrappers */\n  readonly resolver: Readonly<IUriResolver<unknown>>;\n}\n\n/** Options for CoreClient's getFile method */\nexport interface GetFileOptions {\n  /** file path from wrapper root */\n  path: string;\n\n  /** file encoding */\n  encoding?: \"utf-8\" | string;\n}\n\n/** Options for CoreClient's getImplementations method */\nexport interface GetImplementationsOptions {\n  /** If true, follow redirects to resolve URIs */\n  applyResolution?: boolean;\n\n  /** Use and update an existing resolution context */\n  resolutionContext?: IUriResolutionContext;\n}\n\n/** Options for CoreClient's validate method */\nexport interface ValidateOptions {\n  /** Validate full ABI */\n  abi?: boolean;\n\n  /** Recursively validate import URIs */\n  recursive?: boolean;\n}\n\n/** CoreClient invokes wrappers and interacts with wrap packages. */\nexport interface CoreClient extends Invoker, UriResolverHandler<unknown> {\n  /**\n   * Returns the configuration used to instantiate the client\n   *\n   * @returns an immutable core client config\n   */\n  getConfig(): CoreClientConfig;\n\n  /**\n   * returns all interfaces from the configuration used to instantiate the client\n   *\n   * @returns a Set of interfaces and their registered implementations\n   */\n  getInterfaces(): ReadonlyUriMap<readonly Uri[]> | undefined;\n\n  /**\n   * returns all env registrations from the configuration used to instantiate the client\n   *\n   * @returns an array of env objects containing wrapper environmental variables\n   */\n  getEnvs(): ReadonlyUriMap<WrapperEnv> | undefined;\n\n  /**\n   * returns an env (a set of environmental variables) from the configuration used to instantiate the client\n   *\n   * @param uri - the URI used to register the env\n   * @returns an env, or undefined if an env is not found at the given URI\n   */\n  getEnvByUri(uri: Uri): WrapperEnv | undefined;\n\n  /**\n   * returns the URI resolver from the configuration used to instantiate the client\n   *\n   * @returns an object that implements the IUriResolver interface\n   */\n  getResolver(): IUriResolver<unknown>;\n\n  /**\n   * returns a package's wrap manifest\n   *\n   * @param uri - a wrap URI\n   * @returns a Result containing the WrapManifest if the request was successful\n   */\n  getManifest(uri: Uri): Promise<Result<WrapManifest, WrapError>>;\n\n  /**\n   * returns a file contained in a wrap package\n   *\n   * @param uri - a wrap URI\n   * @param options - { path: string; encoding?: \"utf-8\" | string }\n   * @returns a Promise of a Result containing a file if the request was successful\n   */\n  getFile(\n    uri: Uri,\n    options: GetFileOptions\n  ): Promise<Result<string | Uint8Array, WrapError>>;\n\n  /**\n   * returns the interface implementations associated with an interface URI\n   *  from the configuration used to instantiate the client\n   *\n   * @param uri - a wrap URI\n   * @param options - { applyResolution?: boolean; resolutionContext?: IUriResolutionContext }\n   * @returns a Result containing URI array if the request was successful\n   */\n  getImplementations(\n    uri: Uri,\n    options: GetImplementationsOptions\n  ): Promise<Result<Uri[], WrapError>>;\n}\n\n")),(0,a.kt)("h3",{id:"env"},"Env"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** A map of string-indexed, Msgpack-serializable environmental variables associated with a wrapper */\nexport interface WrapperEnv {\n  readonly [k: string]: unknown;\n}\n")),(0,a.kt)("h3",{id:"invoke"},"Invoke"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Options required for an Wrapper invocation. */\nexport interface InvokeOptions {\n  /** The Wrapper's URI */\n  uri: Uri;\n\n  /** Method to be executed. */\n  method: string;\n\n  /** Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments. */\n  args?: Record<string, unknown> | Uint8Array;\n\n  /** Env variables for the wrapper invocation. */\n  env?: Record<string, unknown>;\n\n  /** A Uri resolution context */\n  resolutionContext?: IUriResolutionContext;\n}\n\n/**\n * Result of an Wrapper invocation.\n *\n * @template TData Type of the invoke result data.\n */\nexport type InvokeResult<TData = unknown> = Result<TData, WrapError>;\n\n/**\n * Provides options for the invoker to set based on the state of the invocation.\n * Extends InvokeOptions.\n */\nexport interface InvokerOptions extends InvokeOptions {\n  /** If true, the InvokeResult will (if successful) contain a Msgpack-encoded byte array */\n  encodeResult?: boolean;\n}\n\n/**\n * An entity capable of invoking wrappers.\n *\n * @template TData Type of the invoke result data.\n */\nexport interface Invoker {\n  /**\n   * Invoke a wrapper using an instance of the wrapper.\n   *\n   * @param options - invoker options and a wrapper instance to invoke\n   * @returns A Promise with a Result containing the return value or an error\n   */\n  invokeWrapper<TData = unknown>(\n    options: InvokerOptions & { wrapper: Wrapper }\n  ): Promise<InvokeResult<TData>>;\n\n  /**\n   * Invoke a wrapper.\n   *\n   * @remarks\n   * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper.\n   *\n   * @param options - invoker options\n   * @returns A Promise with a Result containing the return value or an error\n   */\n  invoke<TData = unknown>(\n    options: InvokerOptions\n  ): Promise<InvokeResult<TData>>;\n}\n\n/**\n * Result of a Wrapper invocation, possibly Msgpack-encoded.\n *\n * @template TData Type of the invoke result data.\n */\nexport type InvocableResult<TData = unknown> = InvokeResult<TData> & {\n  /** If true, result (if successful) contains a Msgpack-encoded byte array */\n  encoded?: boolean;\n};\n\n/** An invocable entity, such as a wrapper. */\nexport interface Invocable {\n  /**\n   * Invoke this object.\n   *\n   * @param options - invoke options\n   * @param invoker - an Invoker, capable of invoking this object\n   * @returns A Promise with a Result containing the return value or an error\n   */\n  invoke(\n    options: InvokeOptions,\n    invoker: Invoker\n  ): Promise<InvocableResult<unknown>>;\n}\n\n")),(0,a.kt)("h3",{id:"iuripackage"},"IUriPackage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Associates a URI with an embedded wrap package */\nexport interface IUriPackage {\n  /** The package's URI */\n  uri: Uri;\n\n  /** The wrap package */\n  package: IWrapPackage;\n}\n\n")),(0,a.kt)("h3",{id:"iuriredirect"},"IUriRedirect"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Redirect invocations from one URI to another */\nexport interface IUriRedirect {\n  /** URI to redirect from */\n  from: Uri;\n\n  /** URI to redirect to */\n  to: Uri;\n}\n\n")),(0,a.kt)("h3",{id:"iuriwrapper"},"IUriWrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Associates a URI with an embedded wrapper */\nexport interface IUriWrapper {\n  /** The URI to resolve to the wrapper */\n  uri: Uri;\n\n  /** A wrapper instance */\n  wrapper: Wrapper;\n}\n\n")),(0,a.kt)("h3",{id:"iwrappackage"},"IWrapPackage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Options for IWrapPackage's getManifest method */\nexport interface GetManifestOptions {\n  /** If true, manifest validation step will be skipped */\n  noValidate?: boolean;\n}\n\n/** A wrap package, capable of producing instances of a wrapper and its manifest */\nexport interface IWrapPackage {\n  /**\n   * Produce an instance of the wrap manifest\n   *\n   * @param options - GetManifestOptions; customize manifest retrieval\n   * @returns A Promise with a Result containing the wrap manifest or an error\n   */\n  getManifest(\n    options?: GetManifestOptions\n  ): Promise<Result<WrapManifest, Error>>;\n\n  /**\n   * Produce an instance of the wrapper\n   *\n   * @param options - DeserializeManifestOptions; customize manifest deserialization\n   * @returns A Promise with a Result containing the wrapper or an error\n   */\n  createWrapper(\n    options?: DeserializeManifestOptions\n  ): Promise<Result<Wrapper, Error>>;\n}\n\n")),(0,a.kt)("h3",{id:"maybeasync"},"MaybeAsync"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Alias for a type that is either a value or a promise that resolves to the value */\nexport type MaybeAsync<T> = Promise<T> | T;\n\n")),(0,a.kt)("h3",{id:"uri"},"Uri"),(0,a.kt)("h4",{id:"uriconfig"},"UriConfig"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** URI configuration */\nexport interface UriConfig {\n  /** URI Authority: allows the Polywrap URI resolution algorithm to determine an authoritative URI resolver. */\n  authority: string;\n\n  /** URI Path: tells the Authority where the Wrapper resides. */\n  path: string;\n\n  /** Full string representation of URI */\n  uri: string;\n}\n")),(0,a.kt)("h4",{id:"uri-1"},"Uri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A Polywrap URI. Some examples of valid URIs are:\n * wrap://ipfs/QmHASH\n * wrap://ens/sub.dimain.eth\n * wrap://fs/directory/file.txt\n * wrap://uns/domain.crypto\n *\n * Breaking down the various parts of the URI, as it applies\n * to [the URI standard](https://tools.ietf.org/html/rfc3986#section-3):\n * **wrap://** - URI Scheme: differentiates Polywrap URIs.\n * **ipfs/** - URI Authority: allows the Polywrap URI resolution algorithm to determine an authoritative URI resolver.\n * **sub.domain.eth** - URI Path: tells the Authority where the Wrapper resides.\n */\nexport class Uri {\n")),(0,a.kt)("h5",{id:"constructor"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a Uri instance from a wrap URI string\n   *\n   * @remarks\n   * Throws if URI string is invalid\n   *\n   * @param uri - a string representation of a wrap URI\n   */\n  constructor(uri: string) \n")),(0,a.kt)("h5",{id:"authority"},"authority"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** @returns Uri authority */\n  public get authority(): string \n")),(0,a.kt)("h5",{id:"path"},"path"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** @returns Uri path */\n  public get path(): string \n")),(0,a.kt)("h5",{id:"uri-2"},"uri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** @returns Uri string representation */\n  public get uri(): string \n")),(0,a.kt)("h5",{id:"equals"},"equals"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** Test two Uri instances for equality */\n  public static equals(a: Uri, b: Uri): boolean \n")),(0,a.kt)("h5",{id:"isuri"},"isUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Check if a value is an instance of Uri\n   *\n   * @param value - value to check\n   * @returns true if value is a Uri instance */\n  public static isUri(value: unknown): value is Uri \n")),(0,a.kt)("h5",{id:"isvaliduri"},"isValidUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Test if a URI string is a valid wrap URI\n   *\n   * @param uri - URI string\n   * @param parsed? - UriConfig to update (mutate) with content of URI string\n   * @returns true if input string is a valid wrap URI */\n  public static isValidUri(uri: string, parsed?: UriConfig): boolean \n")),(0,a.kt)("h5",{id:"tostring"},"toString"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** @returns Uri string representation */\n  public toString(): string \n")),(0,a.kt)("h5",{id:"tojson"},"toJSON"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** @returns Uri string representation */\n  public toJSON(): string \n")),(0,a.kt)("h5",{id:"parseuri"},"parseUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Parse a wrap URI string into its authority and path\n   *\n   * @param uri - a string representation of a wrap URI\n   * @returns A Result containing a UriConfig, if successful, or an error\n   */\n  public static parseUri(uri: string): Result<UriConfig, Error> \n")),(0,a.kt)("h5",{id:"from"},"from"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a Uri instance from a Uri or a wrap URI string\n   *\n   * @remarks\n   * Throws if URI string is invalid\n   *\n   * @param uri - a Uri instance or a string representation of a wrap URI\n   */\n  public static from(uri: Uri | string): Uri \n")),(0,a.kt)("h3",{id:"uriresolver"},"UriResolver"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/** Options required for URI resolution. */\nexport interface TryResolveUriOptions {\n  /** The Wrapper's URI */\n  uri: Uri;\n\n  /** A URI resolution context */\n  resolutionContext?: IUriResolutionContext;\n}\n\n/** An entity capable of resolving a wrap URI, typically by using an IUriResolver implementation */\nexport interface UriResolverHandler<TError = undefined> {\n  /**\n   * Resolve a URI to a wrap package, a wrapper, or a uri\n   *\n   * @param options - TryResolveUriOptions\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  tryResolveUri(\n    options?: TryResolveUriOptions\n  ): Promise<Result<UriPackageOrWrapper, TError>>;\n}\n\n")),(0,a.kt)("h3",{id:"wrapper"},"Wrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"\n/**\n * The Wrapper definition, which can be used to spawn\n * many invocations of this particular Wrapper. Internally\n * this class may do things like caching WASM bytecode, spawning\n * worker threads, or indexing into resolvers to find the requested method.\n */\nexport interface Wrapper extends Invocable {\n  /**\n   * Invoke the Wrapper based on the provided [[InvokeOptions]]\n   *\n   * @param options Options for this invocation.\n   * @param invoker The client instance requesting this invocation.\n   * This client will be used for any sub-invokes that occur.\n   */\n  invoke(\n    options: InvokeOptions,\n    invoker: Invoker\n  ): Promise<InvocableResult<unknown>>;\n\n  /**\n   * Get a file from the Wrapper package.\n   *\n   * @param options Configuration options for file retrieval\n   */\n  getFile(options: GetFileOptions): Promise<Result<Uint8Array | string, Error>>;\n\n  /**\n   * Get a manifest from the Wrapper package.\n   */\n  getManifest(): WrapManifest;\n}\n\n")),(0,a.kt)("h2",{id:"uriresolverinterface"},"UriResolverInterface"),(0,a.kt)("h3",{id:"maybeuriormanifest"},"MaybeUriOrManifest"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** Contains either a Uri, a manifest, or neither */\nexport interface MaybeUriOrManifest {\n  /** wrap URI */\n  uri?: string | null;\n\n  /** Serialized wrap manifest */\n  manifest?: Uint8Array | null;\n}\n")),(0,a.kt)("h3",{id:"module"},"Module"),(0,a.kt)("h4",{id:"tryresolveuri"},"tryResolveUri"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Use an invoker to try to resolve a URI using a wrapper that implements the UriResolver interface\n   *\n   * @param invoker - invokes the wrapper with the resolution URI as an argument\n   * @param wrapper - URI for wrapper that implements the UriResolver interface\n   * @param uri - the URI to resolve\n   */\n  tryResolveUri: async (\n    invoker: Invoker,\n    wrapper: Uri,\n    uri: Uri\n  ): Promise<Result<MaybeUriOrManifest, WrapError>> \n")),(0,a.kt)("h4",{id:"getfile"},"getFile"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Use an invoker to fetch a file using a wrapper that implements the UriResolver interface\n   *\n   * @param invoker - invokes the wrapper with the filepath as an argument\n   * @param wrapper - URI for wrapper that implements the UriResolver interface\n   * @param path - a filepath, the format of which depends on the UriResolver\n   */\n  getFile: async (\n    invoker: Invoker,\n    wrapper: Uri,\n    path: string\n  ): Promise<Result<Uint8Array | null, WrapError>> \n")),(0,a.kt)("h2",{id:"uri-resolution"},"Uri Resolution"),(0,a.kt)("h3",{id:"iuriresolutioncontext"},"IUriResolutionContext"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** Track and output URI resolution state, path, and history */\nexport interface IUriResolutionContext {\n  /**\n   * Check if a URI is in the process of being resolved\n   *\n   * @param uri - URI to check\n   * @return true if URI resolution is in process, false otherwise\n   */\n  isResolving(uri: Uri): boolean;\n\n  /**\n   * Start resolving a URI\n   *\n   * @param uri - Uri to resolve\n   */\n  startResolving(uri: Uri): void;\n\n  /**\n   * Stop resolving a URI\n   *\n   * @param uri - Uri being resolved\n   */\n  stopResolving(uri: Uri): void;\n\n  /**\n   * Push a step onto the resolution history stack\n   *\n   * @param step - A completed resolution step\n   */\n  trackStep<TError>(step: IUriResolutionStep<TError>): void;\n\n  /** @return history of all URI resolution steps completed */\n  getHistory(): IUriResolutionStep<unknown>[];\n\n  /** @return current URI resolution path */\n  getResolutionPath(): Uri[];\n\n  /**\n   * Create a new resolution context using the current URI resolution path\n   *\n   * @return a UriResolutionContext\n   */\n  createSubHistoryContext(): IUriResolutionContext;\n\n  /**\n   * Create a new resolution context using the current URI resolution history\n   *\n   * @return a UriResolutionContext\n   */\n  createSubContext(): IUriResolutionContext;\n}\n")),(0,a.kt)("h3",{id:"iuriresolutionstep"},"IUriResolutionStep"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** A step in the URI resolution algorithm */\nexport interface IUriResolutionStep<TError = undefined> {\n  /** The current URI being resolved */\n  sourceUri: Uri;\n\n  /** The resolution result for the current URI */\n  result: Result<UriPackageOrWrapper, TError>;\n\n  /** A text/visual description of this URI step */\n  description?: string;\n\n  /** History of sub-steps that exist within the context of this URI resolution step */\n  subHistory?: IUriResolutionStep<TError>[];\n}\n")),(0,a.kt)("h3",{id:"iuriresolver"},"IUriResolver"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** Defines entity capable of resolving a wrap URI */\nexport interface IUriResolver<TError = undefined> {\n  /**\n   * Resolve a URI to a wrap package, a wrapper, or a uri\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError>>;\n}\n")),(0,a.kt)("h3",{id:"uripackageorwrapper"},"UriPackageOrWrapper"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'\n/** Indicates that a URI resolved to a Uri */\nexport type UriValue = {\n  type: "uri";\n  uri: Uri;\n};\n\n/** Indicates that a URI resolved to a wrap package */\nexport type UriPackageValue = IUriPackage & {\n  type: "package";\n};\n\n/** Indicates that a URI resolved to a wrapper */\nexport type UriWrapperValue = IUriWrapper & {\n  type: "wrapper";\n};\n\n/** indicates that a URI resolved to either a wrap package, a wrapper, or a URI */\nexport type UriPackageOrWrapper = UriValue | UriPackageValue | UriWrapperValue;\n\n')),(0,a.kt)("h3",{id:"uriresolutioncontext"},"UriResolutionContext"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/** An implementation of the IUriResolutionContext interface */\nexport class UriResolutionContext implements IUriResolutionContext {\n")),(0,a.kt)("h4",{id:"constructor-1"},"constructor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"  /** Construct a UriResolutionContext */\n  constructor();\n  constructor(\n    resolvingUriMap: Map<string, boolean>,\n    resolutionPath: Set<string>\n  );\n  constructor(\n    resolvingUriMap: Map<string, boolean>,\n    history: IUriResolutionStep<unknown>[]\n  );\n  constructor(\n    resolvingUriMap?: Map<string, boolean>,\n    resolutionPathOrHistory?: Set<string> | IUriResolutionStep<unknown>[]\n  ) \n")))}d.isMDXComponent=!0}}]);