"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[9552],{3905:(e,r,t)=>{t.d(r,{Zo:()=>c,kt:()=>m});var n=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=n.createContext({}),p=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},c=function(e){var r=p(e.components);return n.createElement(l.Provider,{value:r},e.children)},u="mdxType",v={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},d=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(t),d=o,m=u["".concat(l,".").concat(d)]||u[d]||v[d]||a;return t?n.createElement(m,s(s({ref:r},c),{},{components:t})):n.createElement(m,s({ref:r},c))}));function m(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=d;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7062:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>v,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var n=t(7462),o=(t(7294),t(3905));const a={id:"uri-resolvers-js",hide_title:!0},s="@polywrap/uri-resolvers",i={unversionedId:"reference/clients/js/libraries/uri-resolvers-js",id:"reference/clients/js/libraries/uri-resolvers-js",title:"@polywrap/uri-resolvers",description:"URI resolvers to customize URI resolution in the Polywrap Client.",source:"@site/docs/reference/clients/js/libraries/uri-resolvers-js.md",sourceDirName:"reference/clients/js/libraries",slug:"/reference/clients/js/libraries/uri-resolvers-js",permalink:"/reference/clients/js/libraries/uri-resolvers-js",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/reference/clients/js/libraries/uri-resolvers-js.md",tags:[],version:"current",frontMatter:{id:"uri-resolvers-js",hide_title:!0},sidebar:"docs",previous:{title:"@polywrap/uri-resolver-extensions-js",permalink:"/reference/clients/js/libraries/uri-resolver-extensions-js"},next:{title:"@polywrap/wasm-js",permalink:"/reference/clients/js/libraries/wasm-js"}},l={},p=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"UriResolverAggregatorBase",id:"uriresolveraggregatorbase",level:2},{value:"Methods",id:"methods",level:3},{value:"getUriResolvers",id:"geturiresolvers",level:4},{value:"tryResolveUri",id:"tryresolveuri",level:4},{value:"getStepDescription (protected)",id:"getstepdescription-protected",level:4},{value:"tryResolveUriWithResolvers (protected)",id:"tryresolveuriwithresolvers-protected",level:4},{value:"UriResolverAggregator",id:"uriresolveraggregator",level:2},{value:"Types",id:"types",level:3},{value:"GetResolversFunc",id:"getresolversfunc",level:4},{value:"GetResolversWithErrorFunc",id:"getresolverswitherrorfunc",level:4},{value:"Methods",id:"methods-1",level:3},{value:"constructor",id:"constructor",level:4},{value:"getUriResolvers",id:"geturiresolvers-1",level:4},{value:"getStepDescription (protected)",id:"getstepdescription-protected-1",level:4},{value:"IWrapperCache",id:"iwrappercache",level:2},{value:"WrapperCache",id:"wrappercache",level:2},{value:"Methods",id:"methods-2",level:3},{value:"get",id:"get",level:4},{value:"set",id:"set",level:4},{value:"WrapperCacheResolver",id:"wrappercacheresolver",level:2},{value:"constructor",id:"constructor-1",level:3},{value:"Methods",id:"methods-3",level:3},{value:"from",id:"from",level:4},{value:"tryResolveUri",id:"tryresolveuri-1",level:4},{value:"getUriResolutionPath",id:"geturiresolutionpath",level:2},{value:"InfiniteLoopError",id:"infinitelooperror",level:2},{value:"constructor",id:"constructor-2",level:3},{value:"ResolverWithHistory",id:"resolverwithhistory",level:2},{value:"Methods",id:"methods-4",level:3},{value:"tryResolveUri",id:"tryresolveuri-2",level:4},{value:"getStepDescription (protected)",id:"getstepdescription-protected-2",level:4},{value:"_tryResolveUri (protected)",id:"_tryresolveuri-protected",level:4},{value:"ResolverWithLoopGuard",id:"resolverwithloopguard",level:2},{value:"constructor",id:"constructor-3",level:3},{value:"Methods",id:"methods-5",level:3},{value:"from",id:"from-1",level:4},{value:"tryResolveUri",id:"tryresolveuri-3",level:4},{value:"PackageToWrapperResolver",id:"packagetowrapperresolver",level:2},{value:"constructor",id:"constructor-4",level:3},{value:"Methods",id:"methods-6",level:3},{value:"from",id:"from-2",level:4},{value:"tryResolveUri",id:"tryresolveuri-4",level:4},{value:"UriResolutionResult",id:"uriresolutionresult",level:2},{value:"Methods",id:"methods-7",level:3},{value:"ok",id:"ok",level:4},{value:"err",id:"err",level:4},{value:"UriResolver",id:"uriresolver",level:2},{value:"Methods",id:"methods-8",level:3},{value:"from",id:"from-3",level:4},{value:"UriResolverLike",id:"uriresolverlike",level:2},{value:"PackageResolver",id:"packageresolver",level:2},{value:"constructor",id:"constructor-5",level:3},{value:"Methods",id:"methods-9",level:3},{value:"getStepDescription (protected)",id:"getstepdescription-protected-3",level:4},{value:"_tryResolveUri (protected)",id:"_tryresolveuri-protected-1",level:4},{value:"RedirectResolver",id:"redirectresolver",level:2},{value:"constructor",id:"constructor-6",level:3},{value:"Methods",id:"methods-10",level:3},{value:"getStepDescription (protected)",id:"getstepdescription-protected-4",level:4},{value:"_tryResolveUri (protected)",id:"_tryresolveuri-protected-2",level:4},{value:"WrapperResolver",id:"wrapperresolver",level:2},{value:"constructor",id:"constructor-7",level:3},{value:"Methods",id:"methods-11",level:3},{value:"getStepDescription (protected)",id:"getstepdescription-protected-5",level:4},{value:"_tryResolveUri",id:"_tryresolveuri",level:4},{value:"StaticResolver",id:"staticresolver",level:2},{value:"constructor",id:"constructor-8",level:3},{value:"Methods",id:"methods-12",level:3},{value:"from",id:"from-4",level:4},{value:"tryResolveUri",id:"tryresolveuri-5",level:4},{value:"StaticResolverLike",id:"staticresolverlike",level:2},{value:"RequestSynchronizerResolver",id:"requestsynchronizerresolver",level:2},{value:"constructor",id:"constructor-9",level:3},{value:"Methods",id:"methods-13",level:3},{value:"from",id:"from-5",level:4},{value:"tryResolveUri",id:"tryresolveuri-6",level:4},{value:"Development",id:"development",level:2},{value:"Build",id:"build",level:3},{value:"Test",id:"test",level:3}],c={toc:p},u="wrapper";function v(e){let{components:r,...t}=e;return(0,o.kt)(u,(0,n.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"polywrapuri-resolvers"},"@polywrap/uri-resolvers"),(0,o.kt)("a",{href:"https://www.npmjs.com/package/@polywrap/uri-resolvers-js",target:"_blank",rel:"noopener noreferrer"},(0,o.kt)("img",{src:"https://img.shields.io/npm/v/@polywrap/uri-resolvers-js.svg",alt:"npm"})),(0,o.kt)("br",null),(0,o.kt)("br",null),"URI resolvers to customize URI resolution in the Polywrap Client.",(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save @polywrap/uri-resolvers-js\n")),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"This example is similar to the default resolver used by the ClientConfigBuilder in the @polywrap/client-config-builder-js package."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  const resolver = RecursiveResolver.from(\n    WrapperCacheResolver.from(\n      [\n        StaticResolver.from([\n            ...redirects,\n            ...wrappers,\n            ...packages,\n          ]),\n      ],\n      new WrapperCache()\n    )\n  );\n")),(0,o.kt)("h1",{id:"reference"},"Reference"),(0,o.kt)("h2",{id:"uriresolveraggregatorbase"},"UriResolverAggregatorBase"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Abstract class for IUriResolver implementations that aggregate multiple resolvers.\n * The UriResolverAggregatorBase class attempts to resolve a URI by sequentially\n * attempting resolution with each of its composite resolvers.\n * */\nexport abstract class UriResolverAggregatorBase<\n  TResolutionError = undefined,\n  TGetResolversError = undefined\n> implements IUriResolver<TResolutionError | TGetResolversError> \n")),(0,o.kt)("h3",{id:"methods"},"Methods"),(0,o.kt)("h4",{id:"geturiresolvers"},"getUriResolvers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Get a list of URI Resolvers\n   *\n   * @param uri - the URI to query for resolvers\n   * @param client - a CoreClient instance that can be used to make an invocation\n   * @param resolutionContext - a resolution context to update when resolving URIs\n   *\n   * @returns a list of IUriResolver or an error\n   * */\n  abstract getUriResolvers(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<IUriResolver<unknown>[], TGetResolversError>>;\n")),(0,o.kt)("h4",{id:"tryresolveuri"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Attempts to resolve the URI using each of the aggregated resolvers sequentially.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<\n    Result<UriPackageOrWrapper, TResolutionError | TGetResolversError>\n  > \n")),(0,o.kt)("h4",{id:"getstepdescription-protected"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @param uri - the URI being resolved\n   * @param result - the result of a resolution attempt\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected abstract getStepDescription(\n    uri: Uri,\n    result: Result<UriPackageOrWrapper, TResolutionError>\n  ): string;\n")),(0,o.kt)("h4",{id:"tryresolveuriwithresolvers-protected"},"tryResolveUriWithResolvers (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Using each of the aggregated resolvers, attempt to resolve a URI\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that can be used to make an invocation\n   * @param resolvers - a list of IUriResolver implementations\n   * @param resolutionContext - a resolution context to update when resolving URIs\n   *\n   * @returns a URI, a Wrap Package, or a Wrapper (or an error)\n   * */\n  protected async tryResolveUriWithResolvers(\n    uri: Uri,\n    client: CoreClient,\n    resolvers: IUriResolver<unknown>[],\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TResolutionError>> \n")),(0,o.kt)("h2",{id:"uriresolveraggregator"},"UriResolverAggregator"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * An implementation of UriResolverAggregatorBase\n */\nexport class UriResolverAggregator<\n  TResolutionError = undefined,\n  TGetResolversError = undefined\n> extends UriResolverAggregatorBase<\n  TResolutionError,\n  TGetResolversError\n> \n")),(0,o.kt)("h3",{id:"types"},"Types"),(0,o.kt)("h4",{id:"getresolversfunc"},"GetResolversFunc"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A function that returns a list of resolvers\n *\n * @param uri - the URI to query\n * @param client - a CoreClient instance\n * */\nexport type GetResolversFunc = (\n  uri: Uri,\n  client: CoreClient\n) => Promise<IUriResolver<unknown>[]>;\n")),(0,o.kt)("h4",{id:"getresolverswitherrorfunc"},"GetResolversWithErrorFunc"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A function that returns a list of resolvers or an error\n *\n * @param uri - the URI to query\n * @param client - a CoreClient instance\n * */\nexport type GetResolversWithErrorFunc<TError> = (\n  uri: Uri,\n  client: CoreClient\n) => Promise<Result<IUriResolver<unknown>[], TError>>;\n")),(0,o.kt)("h3",{id:"methods-1"},"Methods"),(0,o.kt)("h4",{id:"constructor"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Creates a UriResolverAggregator from a list of resolvers, or from a function\n   * that returns a list of resolvers\n   * */\n  constructor(resolvers: UriResolverLike[], resolverName?: string);\n  constructor(\n    resolvers: (\n      uri: Uri,\n      client: CoreClient\n    ) => Promise<Result<IUriResolver<unknown>[], TGetResolversError>>,\n    resolverName?: string\n  );\n  constructor(resolvers: GetResolversFunc, resolverName?: string);\n  constructor(\n    resolvers:\n      | UriResolverLike[]\n      | GetResolversFunc\n      | GetResolversWithErrorFunc<TGetResolversError>,\n    private _resolverName?: string\n  ) \n")),(0,o.kt)("h4",{id:"geturiresolvers-1"},"getUriResolvers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Get a list of URI Resolvers\n   *\n   * @param uri - the URI to query for resolvers\n   * @param client - a CoreClient instance that can be used to make an invocation\n   *\n   * @returns a list of IUriResolver or an error\n   * */\n  async getUriResolvers(\n    uri: Uri,\n    client: CoreClient\n  ): Promise<Result<IUriResolver<unknown>[], TGetResolversError>> \n")),(0,o.kt)("h4",{id:"getstepdescription-protected-1"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected getStepDescription = (): string \n")),(0,o.kt)("h2",{id:"iwrappercache"},"IWrapperCache"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** A Wrapper cache */\nexport interface IWrapperCache {\n  /** get a Wrapper from the cache, given its URI index */\n  get(uri: Uri): MaybeAsync<Wrapper | undefined>;\n\n  /** add a Wrapper to the cache, indexed by a URI */\n  set(uri: Uri, wrapper: Wrapper): MaybeAsync<void>;\n}\n")),(0,o.kt)("h2",{id:"wrappercache"},"WrapperCache"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A minimal implementation of IWrapperCache\n * */\nexport class WrapperCache implements IWrapperCache \n")),(0,o.kt)("h3",{id:"methods-2"},"Methods"),(0,o.kt)("h4",{id:"get"},"get"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /** get a Wrapper from the cache, given its URI index */\n  get(uri: Uri): Wrapper | undefined \n")),(0,o.kt)("h4",{id:"set"},"set"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /** add a Wrapper to the cache, indexed by a URI */\n  set(uris: Uri, wrapper: Wrapper): void \n")),(0,o.kt)("h2",{id:"wrappercacheresolver"},"WrapperCacheResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * An IUriResolver implementation that caches wrappers once they are resolved.\n * As it is a wrapper cache resolver, URI and package caching is outside of the scope for this resolver\n * and can be achieved through other resolvers if necessary.\n * The WrapperCacheResolver wraps an IUriResolver implementation and delegates resolution to it.\n * */\nexport class WrapperCacheResolver<TError>\n  implements IUriResolver<TError | Error> \n")),(0,o.kt)("h3",{id:"constructor-1"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Creates a WrapperCacheResolver\n   *\n   * @param _innerResolver - a resolver to delegate resolution to\n   * @param _cache - a wrapper cache\n   * */\n  constructor(\n    private _innerResolver: IUriResolver<TError>,\n    private _cache: IWrapperCache\n  ) \n")),(0,o.kt)("h3",{id:"methods-3"},"Methods"),(0,o.kt)("h4",{id:"from"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Creates a WrapperCacheResolver from a resolver-like object\n   *\n   * @param innerResolver - a resolver-like item to delegate resolution to\n   * @param cache - a wrapper cache\n   * @param options - control wrapper manifest deserialization\n   *\n   * @returns a WrapperCacheResolver\n   * */\n  static from<TResolverError = unknown>(\n    innerResolver: UriResolverLike,\n    cache: IWrapperCache\n  ): WrapperCacheResolver<TResolverError> \n")),(0,o.kt)("h4",{id:"tryresolveuri-1"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * If successful, cache the result.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError | Error>> \n")),(0,o.kt)("h2",{id:"geturiresolutionpath"},"getUriResolutionPath"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Get a resolution path from the history of a URI resolution attempt\n *\n * @param history - the resolution context\n * @returns the URI's resolution path\n * */\nexport const getUriResolutionPath = (\n  history: IUriResolutionStep<unknown>[]\n): IUriResolutionStep<unknown>[] \n")),(0,o.kt)("h2",{id:"infinitelooperror"},"InfiniteLoopError"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Error used if the URI resolution path contains an infinite loop\n * */\nexport class InfiniteLoopError extends Error \n")),(0,o.kt)("h3",{id:"constructor-2"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Create an InfiniteLoopError\n   *\n   * @param _uri - URI being resolved\n   * @param _history - URI resolution history\n   * */\n  constructor(\n    private readonly _uri: Uri,\n    private readonly _history: IUriResolutionStep<unknown>[]\n  ) \n")),(0,o.kt)("h2",{id:"resolverwithhistory"},"ResolverWithHistory"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** An abstract IUriResolver implementation that updates the resolution context */\nexport abstract class ResolverWithHistory<TError = undefined>\n  implements IUriResolver<TError> \n")),(0,o.kt)("h3",{id:"methods-4"},"Methods"),(0,o.kt)("h4",{id:"tryresolveuri-2"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Updates the resolution context with the result.\n   *\n   * @remarks\n   * This method calls the internal abstract method _tryResolveUri before\n   * updating the resolution context. Implementations are expect to place\n   * resolution logic in _tryResolveUri.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError>> \n")),(0,o.kt)("h4",{id:"getstepdescription-protected-2"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @param uri - the URI being resolved\n   * @param result - the result of a resolution attempt\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected abstract getStepDescription(\n    uri: Uri,\n    result: Result<UriPackageOrWrapper, TError>\n  ): string;\n")),(0,o.kt)("h4",{id:"_tryresolveuri-protected"},"_tryResolveUri (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Updates the resolution context with the result.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  protected abstract _tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError>>;\n")),(0,o.kt)("h2",{id:"resolverwithloopguard"},"ResolverWithLoopGuard"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** An IUriResolver implementation that prevents infinite loops in the resolution path. */\nexport class ResolverWithLoopGuard<TError = undefined>\n  implements IUriResolver<TError | InfiniteLoopError> \n")),(0,o.kt)("h3",{id:"constructor-3"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a ResolverWithLoopGuard\n   *\n   * @param _resolver - a resolution to delegate resolution to\n   * */\n  constructor(private _resolver: IUriResolver<TError>) \n")),(0,o.kt)("h3",{id:"methods-5"},"Methods"),(0,o.kt)("h4",{id:"from-1"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Create a ResolverWithLoopGuard from a resolver-like object\n   *\n   * @param resolver - a resolver-like item to delegate resolution to\n   *\n   * @returns a ResolverWithLoopGuard\n   * */\n  static from<TResolverError = unknown>(\n    resolver: UriResolverLike\n  ): ResolverWithLoopGuard<TResolverError> \n")),(0,o.kt)("h4",{id:"tryresolveuri-3"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Ensures the URI is not caught in an infinite loop by checking if it is already resolving.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError | InfiniteLoopError>> \n")),(0,o.kt)("h2",{id:"packagetowrapperresolver"},"PackageToWrapperResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * An IUriResolver implementation that initalizes wrappers from resolved packages.\n * The PackageToWrapperResolver wraps an IUriResolver implementation and delegates resolution to it.\n * */\nexport class PackageToWrapperResolver<TError>\n  implements IUriResolver<TError | Error> \n")),(0,o.kt)("h3",{id:"constructor-4"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Creates a PackageToWrapperResolver\n   *\n   * @param _innerResolver - a resolver to delegate resolution to\n   * @param _options - control wrapper manifest deserialization\n   * */\n  constructor(\n    private _innerResolver: IUriResolver<TError>,\n    private _options?: {\n      deserializeManifestOptions?: DeserializeManifestOptions;\n    }\n  ) \n")),(0,o.kt)("h3",{id:"methods-6"},"Methods"),(0,o.kt)("h4",{id:"from-2"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Creates a PackageToWrapperResolver from a resolver-like object\n   *\n   * @param innerResolver - a resolver-like item to delegate resolution to\n   * @param options - control wrapper manifest deserialization\n   *\n   * @returns a PackageToWrapperResolver\n   * */\n  static from<TResolverError = unknown>(\n    innerResolver: UriResolverLike,\n    options?: { deserializeManifestOptions?: DeserializeManifestOptions }\n  ): PackageToWrapperResolver<TResolverError> \n")),(0,o.kt)("h4",{id:"tryresolveuri-4"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * If successful, cache the result.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError | Error>> \n")),(0,o.kt)("h2",{id:"uriresolutionresult"},"UriResolutionResult"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** Factory for creating Result from URI resolution output */\nexport class UriResolutionResult<TError = undefined> \n")),(0,o.kt)("h3",{id:"methods-7"},"Methods"),(0,o.kt)("h4",{id:"ok"},"ok"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /** Returns a Result with `ok` set to true */\n  static ok<TError = undefined>(uri: Uri): Result<UriPackageOrWrapper, TError>;\n  static ok<TError = undefined>(\n    uri: Uri,\n    wrapPackage: IWrapPackage\n  ): Result<UriPackageOrWrapper, TError>;\n  static ok<TError = undefined>(\n    uri: Uri,\n    wrapper: Wrapper\n  ): Result<UriPackageOrWrapper, TError>;\n  static ok<TError = undefined>(\n    uriPackageOrWrapper: UriPackageOrWrapper\n  ): Result<UriPackageOrWrapper, TError>;\n  static ok<TError = undefined>(\n    uriPackageOrWrapper: Uri | UriPackageOrWrapper,\n    packageOrWrapper?: IWrapPackage | Wrapper\n  ): Result<UriPackageOrWrapper, TError> \n")),(0,o.kt)("h4",{id:"err"},"err"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /** Returns a Result with `ok` set to false */\n  static err<TError = unknown>(\n    error: TError\n  ): Result<UriPackageOrWrapper, TError> \n")),(0,o.kt)("h2",{id:"uriresolver"},"UriResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** An IUriResolver factory */\nexport class UriResolver \n")),(0,o.kt)("h3",{id:"methods-8"},"Methods"),(0,o.kt)("h4",{id:"from-3"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Create an IUriResolver instance\n   *\n   * @param resolverLike - an object that can be transformed into a resolver\n   * @param resolverName - a name to assign to the resolver in resolution history output\n   * */\n  static from<TError = undefined>(\n    resolverLike: UriResolverLike,\n    resolverName?: string\n  ): IUriResolver<TError> \n")),(0,o.kt)("h2",{id:"uriresolverlike"},"UriResolverLike"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** An UriResolverLike can be one of three things:\n * - An IUriResolver\n * - An object that can be transformed into a static IUriResolver\n * - An array of UriResolverLike\n * */\nexport type UriResolverLike =\n  | IUriResolver<unknown>\n  | IUriRedirect\n  | IUriPackage\n  | IUriWrapper\n  | UriResolverLike[];\n")),(0,o.kt)("h2",{id:"packageresolver"},"PackageResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A Uri Resolver that resolves to an embedded wrap package and correctly updates\n * the resolution history.\n * */\nexport class PackageResolver extends ResolverWithHistory \n")),(0,o.kt)("h3",{id:"constructor-5"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a PackageResolver\n   *\n   * @param _uri - the URI to redirect to the wrap package\n   * @param wrapPackage - a wrap package\n   * */\n  constructor(private _uri: Uri, private wrapPackage: IWrapPackage) \n")),(0,o.kt)("h3",{id:"methods-9"},"Methods"),(0,o.kt)("h4",{id:"getstepdescription-protected-3"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected getStepDescription = (): string \n")),(0,o.kt)("h4",{id:"_tryresolveuri-protected-1"},"_tryResolveUri (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package\n   *\n   * @param uri - the URI to resolve\n   * @returns A Promise with a Result containing a wrap package if successful\n   */\n  protected async _tryResolveUri(\n    uri: Uri\n  ): Promise<Result<UriPackageOrWrapper>> \n")),(0,o.kt)("h2",{id:"redirectresolver"},"RedirectResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A Uri Resolver that resolves to a new URI and correctly updates the\n * resolution history.\n * */\nexport class RedirectResolver<\n  TUri extends string | Uri = string\n> extends ResolverWithHistory \n")),(0,o.kt)("h3",{id:"constructor-6"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a RedirectResolver\n   *\n   * @param from - the URI to redirect from\n   * @param to - the URI to redirect to\n   * */\n  constructor(from: TUri, to: TUri) \n")),(0,o.kt)("h3",{id:"methods-10"},"Methods"),(0,o.kt)("h4",{id:"getstepdescription-protected-4"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected getStepDescription = (): string \n")),(0,o.kt)("h4",{id:"_tryresolveuri-protected-2"},"_tryResolveUri (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a new URI\n   *\n   * @param uri - the URI to resolve\n   * @returns A Promise with a Result containing a URI if successful\n   */\n  protected async _tryResolveUri(\n    uri: Uri\n  ): Promise<Result<UriPackageOrWrapper>> \n")),(0,o.kt)("h2",{id:"wrapperresolver"},"WrapperResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * A Uri Resolver that resolves to an embedded wrapper and correctly updates\n * the resolution history.\n * */\nexport class WrapperResolver extends ResolverWithHistory \n")),(0,o.kt)("h3",{id:"constructor-7"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a WrapperResolver\n   *\n   * @param _uri - the URI to redirect to the wrapper instance\n   * @param _wrapper - a wrapper\n   * */\n  constructor(private _uri: Uri, private _wrapper: Wrapper) \n")),(0,o.kt)("h3",{id:"methods-11"},"Methods"),(0,o.kt)("h4",{id:"getstepdescription-protected-5"},"getStepDescription (protected)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * A utility function for generating step descriptions to facilitate resolution context updates\n   *\n   * @returns text describing the URI resolution step\n   * */\n  protected getStepDescription = (): string \n")),(0,o.kt)("h4",{id:"_tryresolveuri"},"_tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrapper\n   *\n   * @param uri - the URI to resolve\n   * @returns A Promise with a Result containing a wrapper if successful\n   */\n  protected async _tryResolveUri(\n    uri: Uri\n  ): Promise<Result<UriPackageOrWrapper>> \n")),(0,o.kt)("h2",{id:"staticresolver"},"StaticResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * An IUriResolver implementation that efficiently delegates URI resolution to\n * static resolvers--i.e. those that resolve to embedded URIs, Wrappers, and Packages\n * */\nexport class StaticResolver<TError = undefined>\n  implements IUriResolver<TError> \n")),(0,o.kt)("h3",{id:"constructor-8"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a Static Resolver\n   *\n   * @param uriMap - a mapping of URI to embedded URI, package, or wrapper\n   * */\n  constructor(public uriMap: Map<string, UriPackageOrWrapper>) \n")),(0,o.kt)("h3",{id:"methods-12"},"Methods"),(0,o.kt)("h4",{id:"from-4"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Create a StaticResolver from a static-resolver-like object\n   *\n   * @param staticResolverLikes - an array of resolver-like objects to delegate resolution to\n   *\n   * @returns a StaticResolver\n   * */\n  static from<TError = undefined>(\n    staticResolverLikes: UriResolverLike[]\n  ): StaticResolver<TError> \n")),(0,o.kt)("h4",{id:"tryresolveuri-5"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   *\n   * @param uri - the URI to resolve\n   * @param _ - not used\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    _: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError>> \n")),(0,o.kt)("h2",{id:"staticresolverlike"},"StaticResolverLike"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** A StaticResolverLike can be one of two things:\n * - An object that can be transformed into a static IUriResolver\n * - An array of StaticResolverLike\n * */\nexport type StaticResolverLike =\n  | IUriRedirect\n  | IUriPackage\n  | IUriWrapper\n  | StaticResolverLike[];\n")),(0,o.kt)("h2",{id:"requestsynchronizerresolver"},"RequestSynchronizerResolver"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/* Uri resolver that synchronizes requests to the same URI\n * Multiple requests to the same URI will be resolved only once\n * and the result will be cached for subsequent requests (only for the duration of that first request)\n * Can use the `shouldIgnoreCache` option to determine whether to ignore the cached request in case of an error\n * (default is to use the cache)\n */\nexport class RequestSynchronizerResolver<TError>\n  implements IUriResolver<TError> \n")),(0,o.kt)("h3",{id:"constructor-9"},"constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Construct a RequestSynchronizerResolver\n   *\n   * @param resolverToSynchronize - the inner resolve whose resolution will be synchronized\n   * @param options - the optional options containing the `shouldIgnoreCache` error handler\n   * */\n  constructor(\n    private resolverToSynchronize: IUriResolver<TError>,\n    private options?: {\n      shouldIgnoreCache?: (error: TError | undefined) => boolean;\n    }\n  ) \n")),(0,o.kt)("h3",{id:"methods-13"},"Methods"),(0,o.kt)("h4",{id:"from-5"},"from"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Create a RequestSynchronizerResolver from a static-resolver-like object\n   *\n   * @param resolver - a resolver-like object whose resolution will be synchronized\n   * @param options - the optional options containing the `shouldIgnoreCache` error handler\n   *\n   * @returns a RequestSynchronizerResolver\n   * */\n  static from<TResolverError = unknown>(\n    resolver: UriResolverLike,\n    options?: {\n      shouldIgnoreCache?: (error: TResolverError | undefined) => boolean;\n    }\n  ): RequestSynchronizerResolver<TResolverError> \n")),(0,o.kt)("h4",{id:"tryresolveuri-6"},"tryResolveUri"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  /**\n   * Resolve a URI to a wrap package, a wrapper, or a URI.\n   * Attempts to resolve the URI using each of the aggregated resolvers sequentially.\n   *\n   * @param uri - the URI to resolve\n   * @param client - a CoreClient instance that may be used to invoke a wrapper that implements the UriResolver interface\n   * @param resolutionContext - the current URI resolution context\n   * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n   */\n  async tryResolveUri(\n    uri: Uri,\n    client: CoreClient,\n    resolutionContext: IUriResolutionContext\n  ): Promise<Result<UriPackageOrWrapper, TError>> \n")),(0,o.kt)("h2",{id:"development"},"Development"),(0,o.kt)("p",null,"This package is open-source. It lives within the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/polywrap/toolchain/tree/origin/packages/js/uri-resolvers"},"Polywrap toolchain monorepo"),". Contributions from the community are welcomed!"),(0,o.kt)("h3",{id:"build"},"Build"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"nvm use && yarn install && yarn build\n")),(0,o.kt)("h3",{id:"test"},"Test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn test\n``\n")))}v.isMDXComponent=!0}}]);