"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[4176],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(t),g=a,m=c["".concat(p,".").concat(g)]||c[g]||d[g]||i;return t?r.createElement(m,l(l({ref:n},u),{},{components:t})):r.createElement(m,l({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=g;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[c]="string"==typeof e?e:a,l[1]=o;for(var s=2;s<i;s++)l[s]=t[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},5171:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var r=t(7462),a=(t(7294),t(3905));const i={id:"understanding-plugins",title:"Understanding plugins"},l=void 0,o={unversionedId:"tutorials/understanding-plugins",id:"tutorials/understanding-plugins",title:"Understanding plugins",description:'Polywrap plugins, or "plugin wrappers", enable existing SDKs implemented in the client\'s language (e.g. JavaScript) to be queried as if they were Wasm wrappers.',source:"@site/docs/tutorials/understanding-plugins.md",sourceDirName:"tutorials",slug:"/tutorials/understanding-plugins",permalink:"/tutorials/understanding-plugins",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/understanding-plugins.md",tags:[],version:"current",frontMatter:{id:"understanding-plugins",title:"Understanding plugins"},sidebar:"docs",previous:{title:"Wrapper Schema",permalink:"/tutorials/wrapper-schema"},next:{title:"URI redirects",permalink:"/tutorials/understanding-uri-redirects"}},p={},s=[{value:"<strong>Default Plugin wrappers</strong>",id:"default-plugin-wrappers",level:3},{value:"<strong>Plugin URI Redirects</strong>",id:"plugin-uri-redirects",level:3}],u={toc:s},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Polywrap plugins, or "plugin wrappers", enable existing SDKs implemented in the client\'s language (e.g. JavaScript) to be queried as if they were Wasm wrappers.'),(0,a.kt)("p",null,"For information on how to create your own Polywrap plugin, read the ",(0,a.kt)("a",{parentName:"p",href:"/tutorials/create-plugin-wrappers/create-js-plugin"},"guide here"),"."),(0,a.kt)("p",null,"Plugins can be used to enable any native client functionality that cannot be implemented in WebAssembly, such as sending HTTP requests, or signing blockchain transactions with a private key."),(0,a.kt)("h3",{id:"default-plugin-wrappers"},(0,a.kt)("strong",{parentName:"h3"},"Default Plugin wrappers")),(0,a.kt)("p",null,"The Polywrap client has a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/polywrap/monorepo/blob/origin/packages/js/client/src/default-client-config.ts"},"default configuration")," that enables developers to use the following plugins:  "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/js-logger.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/ipfs.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/ens-resolver.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/ethereum.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/http.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/fs.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/fs-resolver.polywrap.eth")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"wrap://ens/ipfs-resolver.polywrap.eth"))),(0,a.kt)("p",null,'NOTE: This default configuration will be removed in the near future, and replaced by a "config builder". This will make the client agnostic, and allow users to combine and customize different "config bundles", in addition to creating their your own.'),(0,a.kt)("h3",{id:"plugin-uri-redirects"},(0,a.kt)("strong",{parentName:"h3"},"Plugin URI Redirects")),(0,a.kt)("p",null,"Plugin wrappers are configured using URI Redirects. We would specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"uri")," property as the URI of the plugin we want to use, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin")," property as the actual plugin."),(0,a.kt)("p",null,"For example, we can add an Ethereum plugin that uses MetaMask (or any other Ethereum JS provider) for its provider & signer!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, Connections, Connection } from \'@polywrap/ethereum-plugin-js\';\n\n// Enable Metamask\nconst ethereum = (window as any).ethereum;\nawait ethereum.request({\n  method: \'eth_requestAccounts\',\n});\n\n// Configure the Ethereum plugin w/ MetaMask\nconst client = new PolywrapClient({\n  plugins: [{\n    uri: "ens/ethereum.polywrap.eth",\n    plugin: ethereumPlugin({\n      connections: new Connections({\n        networks: {\n          mainnet: new Connection({\n            provider: ethereum\n          }),\n        },\n        // If defaultNetwork is not specified, mainnet will be used.\n        defaultNetwork: "mainnet"\n      })\n    })\n  }]\n});\n')))}d.isMDXComponent=!0}}]);