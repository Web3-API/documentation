"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[7095],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>g});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),i=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=i(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=i(a),c=r,g=m["".concat(p,".").concat(c)]||m[c]||d[c]||l;return a?n.createElement(g,o(o({ref:t},u),{},{components:a})):n.createElement(g,o({ref:t},u))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var i=2;i<l;i++)o[i]=a[i];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(6010);const l={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,o),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>v});var n=a(7462),r=a(7294),l=a(6010),o=a(2466),s=a(6550),p=a(1980),i=a(7392),u=a(12);function m(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??m(a);return function(e){const t=(0,i.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function c(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:a}=e;const n=(0,s.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,p._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function h(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=d(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[p,i]=g({queryString:a,groupId:n}),[m,h]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,u.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),y=(()=>{const e=p??m;return c({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{y&&s(y)}),[y]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!c({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),i(e),h(e)}),[i,h,l]),tabValues:l}}var y=a(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){let{className:t,block:a,selectedValue:s,selectValue:p,tabValues:i}=e;const u=[],{blockElementScrollPositionUntilNextRender:m}=(0,o.o5)(),d=e=>{const t=e.currentTarget,a=u.indexOf(t),n=i[a].value;n!==s&&(m(t),p(n))},c=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":a},t)},i.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:c,onClick:d},o,{className:(0,l.Z)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":s===t})}),a??t)})))}function w(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function f(e){const t=h(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",b.tabList)},r.createElement(k,(0,n.Z)({},e,t)),r.createElement(w,(0,n.Z)({},e,t)))}function v(e){const t=(0,y.Z)();return r.createElement(f,(0,n.Z)({key:String(t)},e))}},8805:(e,t,a)=>{a.d(t,{f:()=>l});var n=a(9960),r=a(7294);const l=e=>r.createElement(n.Z,{to:e.to},r.createElement("button",{className:"tutorial-nav-button"},e.text," \u2794"))},604:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>_,contentTitle:()=>C,default:()=>E,frontMatter:()=>S,metadata:()=>I,toc:()=>A});var n=a(7462),r=(a(7294),a(3905)),l=a(4866),o=a(5162);const s={toc:[]},p="wrapper";function i(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"codegen-dir",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"src/\n\u251c\u2500\u2500 lib.rs                  # Entry point; exports module defined in schema\n\u2514\u2500\u2500 wrap                    # Generated types\n"))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"module/\n\u251c\u2500\u2500 module.go              # Entry point; exports module defined in schema\n\u251c\u2500\u2500 __tests__/             # Integration tests\n\u2514\u2500\u2500 wrap                   # Generated types\n"))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"src/\n\u251c\u2500\u2500 index.ts               # Entry point; exports module defined in schema\n\u251c\u2500\u2500 __tests__/             # Integration tests\n\u2514\u2500\u2500 wrap                   # Generated types\n"))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"src/\n\u251c\u2500\u2500 index.ts               # Entry point; exports module defined in schema\n\u251c\u2500\u2500 __tests__/             # Integration tests\n\u2514\u2500\u2500 wrap                   # Generated types\n")))))}i.isMDXComponent=!0;const u={toc:[]},m="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"wrap-dir",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wrap/\n\u251c\u2500\u2500 module/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u251c\u2500\u2500 module.rs       # Module Trait\n\u2502   \u2514\u2500\u2500 wrapped.rs      # Args types and method wrappers\n\u251c\u2500\u2500 sample_result/\n\u2502   \u2514\u2500\u2500 mod.rs          # Custom type implementations\n\u251c\u2500\u2500 mod.rs\n\u251c\u2500\u2500 entry.rs            # Wrap entry file\n\u2514\u2500\u2500 prelude.rs\n"))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wrap/\n\u251c\u2500\u2500 main/\n\u2502   \u2514\u2500\u2500 main.go                                 # Wrap entry file\n\u251c\u2500\u2500 module_wrapped/\n\u2502   \u251c\u2500\u2500 module_serialization.go                 # Module serialization logic\n\u2502   \u2514\u2500\u2500 module_wrapped.go                       # Method wrappers\n\u251c\u2500\u2500 types/\n\u2502   \u251c\u2500\u2500 module_args.go                          # Module interface and Args types\n\u2502   \u251c\u2500\u2500 object_sample_result.go                 # Custom type implementations\n\u2502   \u2514\u2500\u2500 object_sample_result_serialization.go   # Custom type serialization logic\n\u2514\u2500\u2500 wrap.go\n"))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wrap/\n\u251c\u2500\u2500 common.ts           # Core types available in every wrap\n\u251c\u2500\u2500 entry.ts            # Wrap entry file\n\u251c\u2500\u2500 globals.d.ts        # Wrap binding method declarations\n\u251c\u2500\u2500 index.ts\n\u251c\u2500\u2500 module.ts           # Module base class and Args types\n\u2514\u2500\u2500 types.ts            # Custom type implementations\n"))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wrap/\n\u251c\u2500\u2500 Module/\n\u2502   \u251c\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 module.ts            # Module base class\n\u2502   \u251c\u2500\u2500 serialization.ts     # Args types and Module serialization logic\n\u2502   \u2514\u2500\u2500 wrapped.ts           # Method wrappers\n\u251c\u2500\u2500 SampleResult/\n\u2502   \u251c\u2500\u2500 index.ts             # Custom type implementations\n\u2502   \u2514\u2500\u2500 serialization.ts     # Custom type serialization logic\n\u251c\u2500\u2500 entry.ts                 # Wrap entry file\n\u2514\u2500\u2500 index.ts\n")))))}d.isMDXComponent=!0;const c={toc:[]},g="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(g,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"wrap-module-base",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=wrap/module/module.rs",title:"wrap/module/module.rs"},"pub struct Module;\n\npub trait ModuleTrait {\n  fn sample_method(args: ArgsSampleMethod) -> Result<SampleResult, String>;\n}\n"))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=wrap/types/module_args.go",title:"wrap/types/module_args.go"},"type Module interface {\n  SampleMethod(args *ArgsSampleMethod) SampleResult\n}\n"))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/module.ts",title:"wrap/module.ts"},"export abstract class ModuleBase {\n  abstract sampleMethod(\n    args: Args_sampleMethod\n  ): Types.SampleResult;\n}\n"))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/Module/module.ts",title:"wrap/Module/module.ts"},"export abstract class ModuleBase {\n  abstract sampleMethod(\n    args: Types.Args_sampleMethod\n  ): Types.SampleResult;\n}\n")))))}h.isMDXComponent=!0;const y={toc:[]},b="wrapper";function k(e){let{components:t,...a}=e;return(0,r.kt)(b,(0,n.Z)({},y,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"wrap-args",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=wrap/module/wrapped.rs",title:"wrap/module/wrapped.rs"},"#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct ArgsSampleMethod {\n  pub arg: String,\n}\n"))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=wrap/types/module_args.go",title:"wrap/types/module_args.go"},'type ArgsSampleMethod struct {\n  Arg string `json:"arg"`\n}\n'))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/module.ts",title:"wrap/module.ts"},"export class Args_sampleMethod {\n  arg: string;\n}\n"))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/Module/serialization.ts",title:"wrap/Module/serialization.ts"},"export class Args_sampleMethod {\n  arg: string;\n}\n")))))}k.isMDXComponent=!0;const w={toc:[]},f="wrapper";function v(e){let{components:t,...a}=e;return(0,r.kt)(f,(0,n.Z)({},w,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"wrap-custom-types",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=wrap/sample_result/mod.rs",title:"wrap/sample_result/mod.rs"},"#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct SampleResult {\n  pub result: String,\n}\n\nimpl SampleResult {\n  pub fn new() -> SampleResult {\n    SampleResult {\n      result: String::new(),\n    }\n  }\n}\n"))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=wrap/types/object_sample_result.go",title:"wrap/types/object_sample_result.go"},'type SampleResult struct {\n  Result string `json:"result"`\n}\n'))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/types.ts",title:"wrap/types.ts"},"export class SampleResult {\n  result: string;\n}\n"))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=wrap/SampleResult/index.ts",title:"wrap/SampleResult/index.ts"},"export class SampleResult {\n  result: string;\n\n  // static methods for serialization\n  ...\n}\n")))))}v.isMDXComponent=!0;const T={toc:[]},N="wrapper";function x(e){let{components:t,...a}=e;return(0,r.kt)(N,(0,n.Z)({},T,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(l.Z,{groupId:"initial-module",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/lib.rs",title:"src/lib.rs"},'pub mod wrap;\npub use wrap::prelude::*;\n\nimpl ModuleTrait for Module {\n  fn sample_method(args: ArgsSampleMethod) -> Result<SampleResult, String> {\n    return Ok(SampleResult {\n      result: format!("{} from sample_method", args.arg),\n    });\n  }\n}\n'))),(0,r.kt)(o.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=module/module.go",title:"module/module.go"},'package module\n\nimport (\n  "example.com/template-wasm-go/module/wrap/types"\n)\n\nfunc SampleMethod(args *types.ArgsSampleMethod) types.SampleResult {\n  return types.SampleResult{\n    Result: args.Arg,\n  }\n}\n'))),(0,r.kt)(o.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=src/index.ts",title:"src/index.ts"},'import { Args_sampleMethod, SampleResult, ModuleBase } from "./wrap";\n\nexport class Module extends ModuleBase {\n  sampleMethod(args: Args_sampleMethod): SampleResult {\n    return {\n      result: args.arg,\n    };\n  }\n}\n'))),(0,r.kt)(o.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},'import { Args_sampleMethod, SampleResult, ModuleBase } from "./wrap";\n\nexport class Module extends ModuleBase {\n  sampleMethod(args: Args_sampleMethod): SampleResult {\n    return {\n      result: args.arg,\n    };\n  }\n}\n')))))}x.isMDXComponent=!0;var M=a(8805);const S={id:"schema-and-codegen",title:"Schema and Codegen"},C=void 0,I={unversionedId:"tutorials/create-wraps/part-one/schema-and-codegen",id:"tutorials/create-wraps/part-one/schema-and-codegen",title:"Schema and Codegen",description:"You're reading Part One of the Create Wraps tutorial, where we learn everything you need to know to productively develop Polywrap wraps.",source:"@site/docs/tutorials/create-wraps/part-one/schema-and-codegen.mdx",sourceDirName:"tutorials/create-wraps/part-one",slug:"/tutorials/create-wraps/part-one/schema-and-codegen",permalink:"/tutorials/create-wraps/part-one/schema-and-codegen",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/create-wraps/part-one/schema-and-codegen.mdx",tags:[],version:"current",frontMatter:{id:"schema-and-codegen",title:"Schema and Codegen"},sidebar:"docs",previous:{title:"Project Manifest",permalink:"/tutorials/create-wraps/part-one/project-manifest"},next:{title:"First Method",permalink:"/tutorials/create-wraps/part-one/first-method"}},_={},A=[{value:"<strong>Initial Schema</strong>",id:"initial-schema",level:2},{value:"<strong>Codegen</strong>",id:"codegen",level:2},{value:"<strong>Wrap Directory</strong>",id:"wrap-directory",level:2},{value:"<strong>Custom Type</strong>",id:"custom-type",level:3},{value:"<strong>Args</strong>",id:"args",level:3},{value:"<strong>Module Base</strong>",id:"module-base",level:3},{value:"<strong>Initial Module</strong>",id:"initial-module",level:2},{value:"<strong>Next Steps</strong>",id:"next-steps",level:2}],Z={toc:A},R="wrapper";function E(e){let{components:t,...a}=e;return(0,r.kt)(R,(0,n.Z)({},Z,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You're reading Part One of the ",(0,r.kt)("a",{parentName:"p",href:"../introduction"},"Create Wraps")," tutorial, where we learn everything you need to know to productively develop Polywrap wraps.")),(0,r.kt)("p",null,'Every wrap, plugin, and "interface wrap" has a ',(0,r.kt)("inlineCode",{parentName:"p"},"polywrap.graphql")," schema that defines its public interface. The schema is parsed and composed into a ",(0,r.kt)("inlineCode",{parentName:"p"},"wrap.info")," ABI file that is included in the wrap package along with the ",(0,r.kt)("inlineCode",{parentName:"p"},"wrap.wasm")," bytecode module."),(0,r.kt)("p",null,"Polywrap uses the schema to generate bindings for your wrap. The bindings handle serialization logic--so that data can pass between the Wasm module and the Polywrap Client--and provide a lightweight structure to validate the wrap's content."),(0,r.kt)("p",null,"Wrap schemas use a simplified version of GraphQL schema syntax. We provide detailed reference documentation in ",(0,r.kt)("a",{parentName:"p",href:"/concepts/wrap-schema"},"Wrap Schema"),", but you'll learn most of it just by following along in this guide."),(0,r.kt)("p",null,"Since the schema's primary purpose is to communicate which code bindings should be generated, we'll learn a bit about the generated bindings as well. The generated bindings are what makes wraps special, so it's important to understand how they work."),(0,r.kt)("p",null,"In the next section, we'll use what we've learned to write the first method of \"Oracle Wrap\"."),(0,r.kt)("h2",{id:"initial-schema"},(0,r.kt)("strong",{parentName:"h2"},"Initial Schema")),(0,r.kt)("p",null,"First, let's take a look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"polywrap.graphql")," schema we generated when we initialized our project with the Polywrap CLI. It's located in the project root."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="polywrap.graphql"',title:'"polywrap.graphql"'},"type Module {\n    sampleMethod(arg: String!): SampleResult!\n}\n\ntype SampleResult {\n    result: String!\n}\n")),(0,r.kt)("p",null,"We have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Module")," and a custom type named ",(0,r.kt)("inlineCode",{parentName:"p"},"SampleResult"),". "),(0,r.kt)("p",null,"Every wrap has exactly one declaration of ",(0,r.kt)("inlineCode",{parentName:"p"},"type Module"),' that defines the wrap\'s methods. Without a module, there would be nothing to invoke. If we want two or more modules, we can simply create more wraps and our wrap can invoke them. When one wrap invokes another, we call it a "subinvocation".'),(0,r.kt)("p",null,"The sample module has one method, ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleMethod(arg: String!): SampleResult!"),", that accepts a single argument named ",(0,r.kt)("inlineCode",{parentName:"p"},"arg")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"String!")," and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"SampleResult!"),"."),(0,r.kt)("p",null,"Following GraphQL syntax, a ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," means a type cannot be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),". The absence of a ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," would mean a property or argument is optional, and it's okay for users to pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),". Also, primitive types start with capital letters."),(0,r.kt)("p",null,"We'll use this schema to generate code bindings and see how they are used."),(0,r.kt)("h2",{id:"codegen"},(0,r.kt)("strong",{parentName:"h2"},"Codegen")),(0,r.kt)("p",null,"To generate the code bindings, change your current working directory to the project root and run ",(0,r.kt)("inlineCode",{parentName:"p"},"polywrap codegen")," using the Polywrap CLI. A new directory called ",(0,r.kt)("inlineCode",{parentName:"p"},"wrap")," will be generated next to your module entry file."),(0,r.kt)(i,{mdxType:"CodegenDir"}),(0,r.kt)("p",null,"By default, codegen is automatically run before you build your project with ",(0,r.kt)("inlineCode",{parentName:"p"},"polywrap build"),"."),(0,r.kt)("h2",{id:"wrap-directory"},(0,r.kt)("strong",{parentName:"h2"},"Wrap Directory")),(0,r.kt)("p",null,"The bindings contain generated types that we must use to implement the wrap module, as well as additional logic related to serialization and interaction with the Polywrap Client."),(0,r.kt)(d,{mdxType:"WrapDir"}),(0,r.kt)("p",null,"We're going to keep it simple and discuss only the code snippets you need to be aware of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Custom type implementations"),(0,r.kt)("li",{parentName:"ul"},"Argument types generated for each module method"),(0,r.kt)("li",{parentName:"ul"},"The Module Base (an abstract class, interface, or trait)")),(0,r.kt)("p",null,"Once we've seen the generated wrap bindings, we won't need to look at them again. The wrap schema tells you everything you need to know about the wrap directory's contents."),(0,r.kt)("h3",{id:"custom-type"},(0,r.kt)("strong",{parentName:"h3"},"Custom Type")),(0,r.kt)(v,{mdxType:"WrapCustomTypes"}),(0,r.kt)("p",null,"A class (or struct) has been generated for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SampleResult")," type, mirroring its schema definition."),(0,r.kt)("p",null,"Codegen generates custom types that mirror the custom types defined in the schema. Although we won't review it, the Polywrap CLI also generates serialization logic for each custom type."),(0,r.kt)("h3",{id:"args"},(0,r.kt)("strong",{parentName:"h3"},"Args")),(0,r.kt)(k,{mdxType:"WrapArgs"}),(0,r.kt)("p",null,"Likewise, a class (or struct) named ",(0,r.kt)("inlineCode",{parentName:"p"},"ArgsSampleMethod")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"Args_sampleMethod"),") has been generated to hold the arguments of the ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleMethod")," method defined in the schema."),(0,r.kt)("p",null,'Codegen generates argument types for each method defined in the schema. A method\'s "Args" type must be used to invoke the method. As with custom types, serialization logic is generated for each Args type.'),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"Why do we use an Args type instead of passing method arguments directly?")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"Recall that when a Polywrap Client user invokes your wrap, the user passes arguments from the Client's host language (e.g. JavaScript) to the Wasm module. The arguments are serialized before being passed into the Wasm module. The Args type simplifies deserialization within the Wasm module. And if the invoked method performs a subinvocation--i.e. invokes a different wrap--the Args type passed into the subinvocation is serialized and passed to the subinvoked wrap."))),(0,r.kt)("h3",{id:"module-base"},(0,r.kt)("strong",{parentName:"h3"},"Module Base")),(0,r.kt)(h,{mdxType:"WrapModuleBase"}),(0,r.kt)("p",null,"The Module Base is an abstract class or interface that must be implemented in your module entry file. For each method defined in the schema, the module base contains an abstract method with a matching signature."),(0,r.kt)("p",null,"The Module Base helps wrap developers ensure their module implementation is correct by validating the module implementation at compile time. It is used by the wrap bindings to call the module's methods when a Polywrap Client invokes the wrap."),(0,r.kt)("h2",{id:"initial-module"},(0,r.kt)("strong",{parentName:"h2"},"Initial Module")),(0,r.kt)("p",null,"From this point forward, we won't need to look at the generated code bindings again. We can instead focus on the schema and the module entry file, which is where we'll write our code."),(0,r.kt)("p",null,"The module entry file already contains an implementation of the Module Base, which mirrors the ",(0,r.kt)("inlineCode",{parentName:"p"},"Module")," defined in the schema. It imports the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"ArgsSampleMethod")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"Args_sampleMethod"),") and ",(0,r.kt)("inlineCode",{parentName:"p"},"SampleResult")," types, and uses them in to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"sampleMethod")," method."),(0,r.kt)(x,{mdxType:"TemplateModule"}),(0,r.kt)("h2",{id:"next-steps"},(0,r.kt)("strong",{parentName:"h2"},"Next Steps")),(0,r.kt)("p",null,"In the next section, we'll finally get to write some code. We'll implement the first method of \"Oracle Wrap\" and build our project with the Polywrap CLI."),(0,r.kt)(M.f,{to:"./first-method",text:"First Method",mdxType:"NavButton"}))}E.isMDXComponent=!0}}]);