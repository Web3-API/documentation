"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[1751],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),u=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(i.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(a),m=r,h=c["".concat(i,".").concat(m)]||c[m]||d[m]||o;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[c]="string"==typeof e?e:r,s[1]=l;for(var u=2;u<o;u++)s[u]=a[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(7294),r=a(6010);const o={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:a,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,s),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>y});var n=a(7462),r=a(7294),o=a(6010),s=a(2466),l=a(6550),i=a(1980),u=a(7392),p=a(12);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,l.k6)(),o=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,i._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(n.location.search);t.set(o,e),n.replace({...n.location,search:t.toString()})}),[o,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,o=d(e),[s,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[i,u]=h({queryString:a,groupId:n}),[c,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,o]=(0,p.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&o.set(e)}),[a,o])]}({groupId:n}),g=(()=>{const e=i??c;return m({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,o]),tabValues:o}}var g=a(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function w(e){let{className:t,block:a,selectedValue:l,selectValue:i,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),d=e=>{const t=e.currentTarget,a=p.indexOf(t),n=u[a].value;n!==l&&(c(t),i(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=p.indexOf(e.currentTarget)+1;t=p[a]??p[0];break}case"ArrowLeft":{const a=p.indexOf(e.currentTarget)-1;t=p[a]??p[p.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:s}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>p.push(e),onKeyDown:m,onClick:d},s,{className:(0,o.Z)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":l===t})}),a??t)})))}function k(e){let{lazy:t,children:a,selectedValue:n}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function v(e){const t=f(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},r.createElement(w,(0,n.Z)({},e,t)),r.createElement(k,(0,n.Z)({},e,t)))}function y(e){const t=(0,g.Z)();return r.createElement(v,(0,n.Z)({key:String(t)},e))}},8805:(e,t,a)=>{a.d(t,{f:()=>o});var n=a(9960),r=a(7294);const o=e=>r.createElement(n.Z,{to:e.to},r.createElement("button",{className:"tutorial-nav-button"},e.text," \u2794"))},4937:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>w,frontMatter:()=>c,metadata:()=>m,toc:()=>f});var n=a(7462),r=(a(7294),a(3905)),o=a(4866),s=a(5162);const l={toc:[]},i="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(i,(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(o.Z,{groupId:"first-method-sha3",mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/lib.rs",title:"src/lib.rs"},"pub mod wrap;\npub use wrap::prelude::*;\nuse crate::wrap::imported::ArgsKeccak256;\n\nimpl ModuleTrait for Module {\n    fn obscure(args: ArgsObscure) -> Result<String, String> {\n        // handle default values\n        let chaos_level = args.chaos_level.unwrap_or(1).max(1);\n\n        let mut obscured = String::new();\n        for data in &args.data {\n            let mut message = data.clone();\n            for _ in 0..chaos_level {\n                message = Sha3Module::keccak_256(&ArgsKeccak256 { message })?;\n            }\n            obscured += &message;\n        }\n        Ok(obscured)\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"golang",label:"Go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go",metastring:"title=module/module.go",title:"module/module.go"},'package module\n\nimport (\n    "example.com/template-wasm-go/module/wrap/types"\n    "example.com/template-wasm-go/module/wrap/imported/sha3"\n)\n\nfunc Obscure(args *types.ArgsObscure) string {\n    // Handle default values\n    chaosLevel := int32(1)\n    if args.ChaosLevel != nil && *args.ChaosLevel >= 1 {\n        chaosLevel = *args.ChaosLevel\n    }\n\n    var obscured string\n    for _, data := range args.Data {\n        tempData := data\n        for i := int32(0); i < chaosLevel; i++ {\n            hashArgs := &sha3.Sha3_ArgsKeccak_256 { Message: tempData }\n            hashed, err := sha3.Sha3_Keccak_256(hashArgs)\n            if err != nil {\n                return ""\n            }\n            tempData = hashed\n        }\n        obscured += tempData\n    }\n    return obscured\n}\n'))),(0,r.kt)(s.Z,{value:"typescript",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},'import { ModuleBase, Args_obscure, Sha3_Module } from \'./wrap\';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    // handle default values\n    const chaosLevel = args.chaosLevel || 1;\n\n    // obscure the data with chaos\n    let obscured: string = "";\n    for (let i = 0; i < args.data.length; ++i) {\n      let data = args.data[i];\n      for (let j = 0; j < chaosLevel; ++j) {\n        const result = Sha3_Module.keccak_256({ message: data })\n        if (!result.ok) throw Error("hash failed");\n        data = result.value!!;\n      }\n      obscured += data;\n    }\n    return obscured;\n  }\n}\n'))),(0,r.kt)(s.Z,{value:"assemblyscript",label:"AssemblyScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/index.ts",title:"src/index.ts"},'import { ModuleBase, Args_obscure, Sha3_Module } from \'./wrap\';\n\nexport class Module extends ModuleBase {\n  obscure(args: Args_obscure): string {\n    // handle default values\n    const chaosLevel: i32 = (args.chaosLevel == null || args.chaosLevel!!.unwrap() < 1)\n      ? 1\n      : args.chaosLevel!!.unwrap();\n\n    let obscured: string = "";\n    for (let i = 0; i < args.data.length; ++i) {\n      let data = args.data[i];\n      for (let j = 0; j < chaosLevel; ++j) {\n        data = Sha3_Module.keccak_256({ message: data }).expect("hash failed");\n      }\n      obscured += data;\n    }\n    return obscured;\n  }\n}\n')))))}u.isMDXComponent=!0;var p=a(8805);const c={id:"import-and-subinvoke",title:"Import and Subinvoke"},d=void 0,m={unversionedId:"tutorials/create-wraps/part-one/import-and-subinvoke",id:"tutorials/create-wraps/part-one/import-and-subinvoke",title:"Import and Subinvoke",description:"You're reading Part One of the Create Wraps tutorial, where we learn everything you need to know to productively develop Polywrap wraps.",source:"@site/docs/tutorials/create-wraps/part-one/import-and-subinvoke.mdx",sourceDirName:"tutorials/create-wraps/part-one",slug:"/tutorials/create-wraps/part-one/import-and-subinvoke",permalink:"/tutorials/create-wraps/part-one/import-and-subinvoke",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/create-wraps/part-one/import-and-subinvoke.mdx",tags:[],version:"current",frontMatter:{id:"import-and-subinvoke",title:"Import and Subinvoke"},sidebar:"docs",previous:{title:"First Method",permalink:"/tutorials/create-wraps/part-one/first-method"},next:{title:"Interfaces and Plugins",permalink:"/tutorials/create-wraps/part-one/interfaces-and-plugins"}},h={},f=[{value:"<strong>Wrap URIs</strong>",id:"wrap-uris",level:2},{value:"<strong>Import a Wrap</strong>",id:"import-a-wrap",level:2},{value:"<strong>Subinvocations</strong>",id:"subinvocations",level:2},{value:"<strong>Next Steps</strong>",id:"next-steps",level:2}],g={toc:f},b="wrapper";function w(e){let{components:t,...a}=e;return(0,r.kt)(b,(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You're reading Part One of the ",(0,r.kt)("a",{parentName:"p",href:"../introduction"},"Create Wraps")," tutorial, where we learn everything you need to know to productively develop Polywrap wraps.")),(0,r.kt)("p",null,"It's time to make the ",(0,r.kt)("inlineCode",{parentName:"p"},"obscure")," method a little more interesting. In the previous section, we made the data hard to decipher by shifting each character in each string by a fixed amount. We can make our method far more insidious by hashing the data instead."),(0,r.kt)("p",null,"To do this, we can import the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sha3")," wrap and subinvoke one of its hashing functions. First we'll learn how to import a wrap using a Wrap URI, and then we'll learn how to subinvoke the method using its generated Module bindings."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Your dependencies don't have to be other wraps. You can also use language-specific libraries, such as the Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"sha3")," package that was used to build the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sha3")," wrap.")),(0,r.kt)("h2",{id:"wrap-uris"},(0,r.kt)("strong",{parentName:"h2"},"Wrap URIs")),(0,r.kt)("p",null,"Wrap URIs are a simple, flexible URI format used by Polywrap to identify and import wraps. They allow wraps to be stored and retrieved from a variety of sources, including IPFS, HTTP, and the local filesystem."),(0,r.kt)("p",null,"Wrap URIs have the benefit of decentralization: developers are not required to use a centralized registry to publish their wraps. Instead, they can publish their wraps to any storage network and resolve them using a Polywrap Client."),(0,r.kt)("p",null,"A Wrap URI has three parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Scheme (optional): ",(0,r.kt)("inlineCode",{parentName:"li"},"wrap://")),(0,r.kt)("li",{parentName:"ul"},"Authority: e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ipfs"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"fs")),(0,r.kt)("li",{parentName:"ul"},"Path: e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"ipfs/Qm..."),", ",(0,r.kt)("inlineCode",{parentName:"li"},"http/https://..."),", ",(0,r.kt)("inlineCode",{parentName:"li"},"fs/path/to/wrap"))),(0,r.kt)("p",null,"You can learn more about the Wrap URI format in the ",(0,r.kt)("a",{parentName:"p",href:"/concepts/uris"},"Wrap URI specification"),"."),(0,r.kt)("p",null,"A wrap URI is valid so long as it follows the Wrap URI format and can be resolved by a Polywrap Client. The Polywrap Client resolves URIs using implementations of the ",(0,r.kt)("inlineCode",{parentName:"p"},"UriResolver")," interface. The Polywrap Client's default configuration includes several resolvers for common URI authorities, including IPFS, HTTP, ENS, and the local filesystem. Users can also configure the Polywrap Client with custom resolvers to resolve URIs from other sources."),(0,r.kt)("h2",{id:"import-a-wrap"},(0,r.kt)("strong",{parentName:"h2"},"Import a Wrap")),(0,r.kt)("p",null,"We'll import our first dependency using a Wrap URI with the ",(0,r.kt)("inlineCode",{parentName:"p"},"wrapscan.io")," authority. The URI points to Polywrap's own Wrapscan registry, which is still in construction as of the time of this writing."),(0,r.kt)("p",null,"The syntax of an import statement is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"#import { <type1, type2, ...> } into <Namespace> from <WrapUri>\n")),(0,r.kt)("p",null,"Import statements are placed in the Wrap Schema. Let's add an import statement for the Sha3 wrap."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="polywrap.graphql"',title:'"polywrap.graphql"'},'#import { Module } into Sha3 from "wrapscan.io/polywrap/sha3@1.0.0"\n\ntype Module {\n    obscure(data: [String!]!, chaosLevel: Int): String!\n}\n')),(0,r.kt)("p",null,"This import statement ensures a ",(0,r.kt)("inlineCode",{parentName:"p"},"Module")," type will be available in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sha3")," namespace. Make sure to run codegen once more to update the bindings."),(0,r.kt)("h2",{id:"subinvocations"},(0,r.kt)("strong",{parentName:"h2"},"Subinvocations")),(0,r.kt)("p",null,"Once we've successfully updated our generated bindings for the Sha3 dependency, we can use them to invoke a hash function."),(0,r.kt)("p",null,"But how do we know which hash functions are available in the Sha3 wrap? Once again, the Wrap Schema comes in clutch. Even without package documentation, we can always know a wrap's interface by looking at its schema. You can view the schema for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sha3")," wrap on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/polywrap/sha3/blob/main/polywrap.graphql"},"Github")," or ",(0,r.kt)("a",{parentName:"p",href:"https://www.wrapscan.io/wrap/wrapscan.io%2Fpolywrap%2Fsha3%401.0.0/schema"},"Wrapscan"),". The schemas of wraps pinned on IPFS to the ",(0,r.kt)("inlineCode",{parentName:"p"},"https://ipfs.wrappers.io")," gateway can also be viewed on ",(0,r.kt)("a",{parentName:"p",href:"https://wrappers.io/all"},"Wrappers.io"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Great places to find wraps"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/polywrap/awesome-polywrap"},"Awesome Polywrap")," Github Repo"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.wrapscan.io/"},"Wrapscan Registry")," (under construction)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://wrappers.io/all"},"Wrappers.io")," list of all wrappers pinned to ",(0,r.kt)("inlineCode",{parentName:"li"},"https://ipfs.wrappers.io")))),(0,r.kt)("p",null,"We'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"keccak256")," hash function for the tutorial. Import the Sha3 module and the Args type for the keccak256 method. The imported Sha3 module exposes its functions as static methods, so you can call them without creating an instance."),(0,r.kt)(u,{mdxType:"FirstMethodSha3"}),(0,r.kt)("p",null,"When one wrap invokes another, we call it a subinvocation. Subinvocations are a special feature of Polywrap that aren't available in ordinary WebAssembly modules. The wrap standard makes it possible to invoke the Sha3 wrap from any wrap or Polywrap Client without knowing its source language."),(0,r.kt)("p",null,"Subinvocations never throw errors. The return type of a subinvocation is always the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type, or a language-specific equivalent. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type wraps the return value and contains either the expected value or an error."),(0,r.kt)("h2",{id:"next-steps"},(0,r.kt)("strong",{parentName:"h2"},"Next Steps")),(0,r.kt)("p",null,"Next we'll talk about interfaces and plugins. Interfaces are a powerful feature that allows wraps to implement a standard API. Plugins are extensions of a Polywrap Client, written in the client's host language, that give wraps access to host capabilities like networking and the filesystem."),(0,r.kt)(p.f,{to:"./interfaces-and-plugins",text:"Interfaces and Plugins",mdxType:"NavButton"}))}w.isMDXComponent=!0}}]);