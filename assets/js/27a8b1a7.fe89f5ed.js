"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[5150],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},s="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),s=c(n),g=a,m=s["".concat(p,".").concat(g)]||s[g]||d[g]||i;return n?r.createElement(m,l(l({ref:t},u),{},{components:n})):r.createElement(m,l({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=g;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[s]="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},2341:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={id:"plugin-architecture",title:"Plugin Architecture"},l=void 0,o={unversionedId:"tutorials/advanced/create-plugins/plugin-architecture",id:"tutorials/advanced/create-plugins/plugin-architecture",title:"Plugin Architecture",description:"The architecture of a plugin's code is flexible.",source:"@site/docs/tutorials/advanced/create-plugins/plugin-architecture.md",sourceDirName:"tutorials/advanced/create-plugins",slug:"/tutorials/advanced/create-plugins/plugin-architecture",permalink:"/tutorials/advanced/create-plugins/plugin-architecture",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/advanced/create-plugins/plugin-architecture.md",tags:[],version:"current",frontMatter:{id:"plugin-architecture",title:"Plugin Architecture"},sidebar:"docs",previous:{title:"Configure a Plugin Manifest",permalink:"/tutorials/advanced/create-plugins/plugin-manifest"},next:{title:"Configure interfaces in the client",permalink:"/tutorials/advanced/interfaces/client-config-interfaces"}},p={},c=[{value:"Required Exports",id:"required-exports",level:2},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Example",id:"example",level:2}],u={toc:c},s="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The architecture of a plugin's code is flexible.\nStill, there are some simple requirements and best practices that may guide its code structure."),(0,a.kt)("h2",{id:"required-exports"},"Required Exports"),(0,a.kt)("p",null,"A plugin must export a ",(0,a.kt)("inlineCode",{parentName:"p"},"PluginFactory")," to be used by the Polywrap Client.\nA ",(0,a.kt)("inlineCode",{parentName:"p"},"PluginFactory")," is a function that returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"PluginPackageManifest")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"factory")," method that generates an instance of the plugin."),(0,a.kt)("h2",{id:"typescript-support"},"TypeScript Support"),(0,a.kt)("p",null,"The Polywrap CLI's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/polywrap/cli/tree/origin-dev/packages/cli#codegen--g"},(0,a.kt)("inlineCode",{parentName:"a"},"codegen"))," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/polywrap/cli/tree/origin-dev/packages/cli#build--b"},(0,a.kt)("inlineCode",{parentName:"a"},"build"))," commands will generate a ",(0,a.kt)("inlineCode",{parentName:"p"},"wrap")," folder containing useful types.\nThe generated types will save you time and energy.\nYou won't have to manually create or update your types every time you change your schema, and your code will have fewer bugs.\nYou can forget about boilerplate code and focus on your plugin's logic.\nWhile the types are not strictly required, we recommend them as a best practice."),(0,a.kt)("p",null,"The generated types include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Module")," - An interface containing the methods declared in the plugin's schema"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Args_*")," - An interface for each method, containing the method arguments declared in the schema"),(0,a.kt)("li",{parentName:"ul"},"Custom Types - An interface for each custom type declared in the schema"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"manifest")," - A ",(0,a.kt)("inlineCode",{parentName:"li"},"PluginPackageManifest")," for the plugin (also useful for JavaScript developers!)")),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="Example: plugin template',title:'"Example:',plugin:!0,template:!0},'import { Module, Args_sampleMethod, manifest } from "./wrap"; // imports from generated "wrap" folder\n\nimport { PluginFactory, PluginPackage } from "@polywrap/plugin-js"; // plugin must export a PluginFactory\n\nexport interface SamplePluginConfig {\n  defaultValue: string;\n}\n\nexport class SamplePlugin extends Module<SamplePluginConfig> { // Plugin inherits from Module\n  constructor(config: SamplePluginConfig) {\n    super(config);\n  }\n  public sampleMethod(args: Args_sampleMethod): string { // Plugin method accepts Args_* as sole argument\n    return args.data + this.config.defaultValue;\n  }\n}\n\nexport const samplePlugin: PluginFactory<SamplePluginConfig> = ( // exported PluginFactory is used by Polywrap client\n  config: SamplePluginConfig\n) => {\n  return new PluginPackage(\n    new SamplePlugin(config), // factory method produces a Module\n    manifest // imported from ./wrap\n  );\n};\n\nexport const plugin = samplePlugin; // PluginFactory is exported with name "plugin"\n')))}d.isMDXComponent=!0}}]);