"use strict";(self.webpackChunk_polywrap_docs=self.webpackChunk_polywrap_docs||[]).push([[8772],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),d=l(n),c=a,m=d["".concat(s,".").concat(c)]||d[c]||h[c]||i;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p[d]="string"==typeof e?e:a,o[1]=p;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9039:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const i={id:"end-to-end-test",title:"Writing tests with TypeScript"},o=void 0,p={unversionedId:"tutorials/test-wasm-wrappers/end-to-end-test",id:"tutorials/test-wasm-wrappers/end-to-end-test",title:"Writing tests with TypeScript",description:"Introduction",source:"@site/docs/tutorials/test-wasm-wrappers/end-to-end-test.md",sourceDirName:"tutorials/test-wasm-wrappers",slug:"/tutorials/test-wasm-wrappers/end-to-end-test",permalink:"/tutorials/test-wasm-wrappers/end-to-end-test",draft:!1,editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/tutorials/test-wasm-wrappers/end-to-end-test.md",tags:[],version:"current",frontMatter:{id:"end-to-end-test",title:"Writing tests with TypeScript"},sidebar:"docs",previous:{title:"Add Metadata",permalink:"/tutorials/create-wasm-wrappers/add-metadata"},next:{title:"Configure Polywrap infrastructure pipeline",permalink:"/tutorials/test-wasm-wrappers/infra-pipeline"}},s={},l=[{value:"<strong>Introduction</strong>",id:"introduction",level:2},{value:"<strong>Prerequisites</strong>",id:"prerequisites",level:2},{value:"<strong>The Polywrap Test Environment</strong>",id:"the-polywrap-test-environment",level:2},{value:"<strong>Starting and stopping a Polywrap Test environment with @polywrap/test-env-js</strong>",id:"starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js",level:2},{value:"<strong>Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js</strong>",id:"building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js",level:2},{value:"<strong>Setting up a Polywrap Client</strong>",id:"setting-up-a-polywrap-client",level:2},{value:"<strong>Configure the IPFS Resolver Plugin</strong>",id:"configure-the-ipfs-resolver-plugin",level:3},{value:"<strong>Configure the Ethereum Plugin</strong>",id:"configure-the-ethereum-plugin",level:3},{value:"<strong>Create the Polywrap Client Instance</strong>",id:"create-the-polywrap-client-instance",level:3},{value:"<strong>Deploy the Smart Contract</strong>",id:"deploy-the-smart-contract",level:2},{value:"<strong>Generate TypeScript Types</strong>",id:"generate-typescript-types",level:2},{value:"<strong>Testing a Wrapper Method</strong>",id:"testing-a-wrapper-method",level:2}],u={toc:l},d="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},(0,a.kt)("strong",{parentName:"h2"},"Introduction")),(0,a.kt)("p",null,"Here we discuss the process of writing end to end (e2e) tests for your Wasm wrapper using TypeScript.\nBy end-to-end, we mean tests that make calls to the wrapper through a Polywrap Client.\nE2e testing is both necessary and useful.\nIt is necessary because calls between wrappers depend on the Polywrap Client, and therefore cannot always be made in a\nWasm wrapper's native language.\nIt is useful because such tests can more accurately represent the user experience of your wrapper when it is integrated\ninto an application."),(0,a.kt)("p",null,"We will focus on setting up a test environment and a Polywrap Client. Once these tasks are completed, testing\na Wasm wrapper is similar to testing a traditional SDK."),(0,a.kt)("h2",{id:"prerequisites"},(0,a.kt)("strong",{parentName:"h2"},"Prerequisites")),(0,a.kt)("p",null,"This guide uses ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," to implement the Polywrap test environment. We will also\nuse the ",(0,a.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"Jest")," testing framework, though you can use any framework and follow without difficulty."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"In the future, TypeScript will be one of many supported languages with a Polywrap client.\nAs more Polywrap Clients are released in various languages, implementing plugin wrappers in those languages will be supported as well.")),(0,a.kt)("p",null,"You'll need the following installed as developer dependencies before testing your wrapper:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../reference/cli/polywrap-cli"},(0,a.kt)("inlineCode",{parentName:"a"},"polywrap"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../reference/clients/js/libraries/test-env-js"},(0,a.kt)("inlineCode",{parentName:"a"},"@polywrap/test-env-js"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../reference/clients/js/client-js"},(0,a.kt)("inlineCode",{parentName:"a"},"@polywrap/client-js"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"jest")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"@types/jest"))),(0,a.kt)("p",null,"These can be added to your TypeScript project using the npm or yarn package managers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"npm install --save-dev polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"yarn add -D polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest\n")),(0,a.kt)("h2",{id:"the-polywrap-test-environment"},(0,a.kt)("strong",{parentName:"h2"},"The Polywrap Test Environment")),(0,a.kt)("p",null,"An ideal Polywrap test environment will integrate everything you need to test your wrapper.\nIn the case of this guide, we will need an IPFS node and an Ethereum test network."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Polywrap makes it easy to create a custom test environment that you can start and stop with the Polywrap CLI.\nSee ",(0,a.kt)("a",{parentName:"p",href:"./infra-pipeline"},"Configure Polywrap infrastructure pipeline")," for more information.")),(0,a.kt)("p",null,"This guide will use the ",(0,a.kt)("a",{parentName:"p",href:"../../reference/clients/js/libraries/test-env-js"},(0,a.kt)("inlineCode",{parentName:"a"},"@polywrap/test-env-js"))," package.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," package uses the default infrastructure module included with the ",(0,a.kt)("a",{parentName:"p",href:"../../reference/cli/polywrap-cli"},(0,a.kt)("inlineCode",{parentName:"a"},"polywrap"))," CLI.\nWe can use ",(0,a.kt)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," to start and stop the test environment programmatically.\nThe package also exports the ethereum provider, ipfs provider, and ens addresses used by the default infrastructure module."),(0,a.kt)("h2",{id:"starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js"},(0,a.kt)("strong",{parentName:"h2"},"Starting and stopping a Polywrap Test environment with @polywrap/test-env-js")),(0,a.kt)("p",null,"If you're unfamiliar with ",(0,a.kt)("a",{parentName:"p",href:"../../reference/clients/js/libraries/test-env-js"},(0,a.kt)("inlineCode",{parentName:"a"},"@polywrap/test-env-js")),", feel free to check\nout the reference documentation before we continue."),(0,a.kt)("p",null,"Let's start a new file where we will write our first test. "),(0,a.kt)("p",null,"Like many testing frameworks in JavaScript, the Jest framework includes hooks that run before and after all tests.\nI've added a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"initTestEnvironment")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"beforeAll")," hook, so we can start our test environment before running our tests.\nI added a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"stopTestEnvironment")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"afterAll")," hook to make sure the test environment does not continue running\non our system after we finish testing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { initTestEnvironment, stopTestEnvironment } from "@polywrap/test-env-js";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),(0,a.kt)("h2",{id:"building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js"},(0,a.kt)("strong",{parentName:"h2"},"Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js")),(0,a.kt)("p",null,"To invoke a Wasm wrapper in a test, we first need to build it. In this guide, we will do this with\n",(0,a.kt)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," using the ",(0,a.kt)("inlineCode",{parentName:"p"},"buildWrapper")," function."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Alternatively, we could have used the ",(0,a.kt)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," function ",(0,a.kt)("inlineCode",{parentName:"p"},"buildAndDeployWrapper"),".\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"buildAndDeployWrapper")," function will build a wrapper, deploy it to IPFS, point an ENS domain to it.\nIt returns both the IPFS content hash and the ENS domain, either of which could be used to invoke the wrapper.")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"buildWrapper")," function requires an absolute path to the directory containing the wrapper's polywrap manifest.\nWe will obtain the absolute path to our wrapper project in three steps. First we get the directory of the folder containing\nour test script, using the node.js ",(0,a.kt)("inlineCode",{parentName:"p"},"__dirname")," global variable. We then append the path from our test script file to the\nmanifest directory. Finally, we import the node.js feature ",(0,a.kt)("inlineCode",{parentName:"p"},"path"),", and use ",(0,a.kt)("inlineCode",{parentName:"p"},"path.resolve")," to get direct absolute path to\nour wrapper project."),(0,a.kt)("p",null,"We will invoke our wrapper using the path to our build folder.\nWe prefix the path with ",(0,a.kt)("inlineCode",{parentName:"p"},"wrap://fs/")," to conform to the WRAP URI standard, though prefixing the path with ",(0,a.kt)("inlineCode",{parentName:"p"},"fs/")," alone would\nwork just as well. See ",(0,a.kt)("a",{parentName:"p",href:"/concepts/uris"},"URIs")," to learn more."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// highlight-start\nimport { buildWrapper, initTestEnvironment, stopTestEnvironment } from "@polywrap/test-env-js";\nimport path from "path";\n// highlight-end\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // path to the wrapper\'s build folder\n  let wrapperPath: string;\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // highlight-start\n    // absolute path to directory with polywrap.yaml\n    const wrapperDirectory: string = path.resolve(__dirname + "/../../../");\n    // build the wrapper\n    await buildWrapper(wrapperDirectory);\n    wrapperPath = `wrap://fs/${wrapperDirectory}/build`\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),(0,a.kt)("h2",{id:"setting-up-a-polywrap-client"},(0,a.kt)("strong",{parentName:"h2"},"Setting up a Polywrap Client")),(0,a.kt)("p",null,"Now that we have deployed our Wasm wrapper to a local test environment, we need to set up a Polywrap Client that can\ninvoke it. We can make sure our client is ready to invoke the wrapper by configuring two of the default plugin wrappers."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"ipfsResolverPlugin")," can be configured using the test environment's local IPFS node."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"ethereumPlugin")," can be configured with an Ethereum provider for the Ganache Ethereum test network.")),(0,a.kt)("h3",{id:"configure-the-ipfs-resolver-plugin"},(0,a.kt)("strong",{parentName:"h3"},"Configure the IPFS Resolver Plugin")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ipfsResolverPlugin")," can be configured with a default IPFS provider and an array of fallback providers that will be tried if\nthe default provider fails."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\n\nconst ipfsConfig: IpfsPluginConfig = {\n  provider: providers.ipfs,\n  fallbackProviders: undefined,\n};\n')),(0,a.kt)("h3",{id:"configure-the-ethereum-plugin"},(0,a.kt)("strong",{parentName:"h3"},"Configure the Ethereum Plugin")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ethereumPlugin")," can be configured with Ethereum providers and signers. It accepts JSON RPC provider strings,\nProviders from the ethers.js package, and providers from the web3.js package."),(0,a.kt)("p",null,"To configure the plugin, we need to provide it with an object containing network names along with a provider. We can\noptionally provide a signer as well, but by default the plugin will attempt to obtain a signer from the provider if it\nis needed."),(0,a.kt)("p",null,'We can give networks any name we want in our configuration. We can later use these names to choose which network to\nquery. Here we will use the name "testnet" for our local Ethereum test network.'),(0,a.kt)("p",null,"We also need to tell the Ethereum plugin which network should be used when a network is not specified. We do this by\nsetting the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"defaultNetwork")," property to one of our network names."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\n\nconst ethereumConfig: EthereumPluginConfig = {\n  networks: {\n    testnet: {\n      provider: providers.ethereum // Ganache test network\n    },\n  },\n  defaultNetwork: "testnet",\n};\n')),(0,a.kt)("h3",{id:"create-the-polywrap-client-instance"},(0,a.kt)("strong",{parentName:"h3"},"Create the Polywrap Client Instance")),(0,a.kt)("p",null,"Now we are ready to add the plugins to our Polywrap Client configuration and create the client. The URI's we assign in\nour client configuration will redirect to the plugin instances when queried."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// highlight-start\nimport { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from "@polywrap/test-env-js";\n// highlight-end\nimport path from "path";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // path to the wrapper\'s build folder\n  let wrapperPath: string;\n\n  // highlight-start\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n  // highlight-end\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // absolute path to directory with polywrap.yaml\n    const wrapperDirectory: string = path.resolve(__dirname + "/../../../");\n    // build the wrapper\n    await buildWrapper(wrapperDirectory);\n    wrapperPath = `wrap://fs/${wrapperDirectory}/build`\n\n    // highlight-start\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),(0,a.kt)("h2",{id:"deploy-the-smart-contract"},(0,a.kt)("strong",{parentName:"h2"},"Deploy the Smart Contract")),(0,a.kt)("p",null,"The SimpleStorage wrapper is designed to interact with a SimpleStorage smart contract. We need to deploy an\ninstance of the contract to work with. While there are many tools developers can use to deploy a smart contract on a\nlocal network, the SimpleStorage API has a method ",(0,a.kt)("inlineCode",{parentName:"p"},"deployContract")," we can use to get the job done. We'll call it before\nrunning our test to make sure the contract is ready."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from "@polywrap/test-env-js";\nimport path from "path";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  // highlight-start\n  let simpleStorageAddress: string;\n  // highlight-end\n\n  // path to the wrapper\'s build folder\n  let wrapperPath: string;\n\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // absolute path to directory with polywrap.yaml\n    const wrapperDirectory: string = path.resolve(__dirname + "/../../../");\n    // build the wrapper\n    await buildWrapper(wrapperDirectory);\n    wrapperPath = `wrap://fs/${wrapperDirectory}/build`\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n\n    // deploy simple storage contract\n    // highlight-start\n    const { data, error } = await client.invoke<string>({\n      uri: wrapperPath,\n      method: "deployContract",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),(0,a.kt)("h2",{id:"generate-typescript-types"},(0,a.kt)("strong",{parentName:"h2"},"Generate TypeScript Types")),(0,a.kt)("p",null,"Since we are using TypeScript, we will want types to work with. It is possible to automatically generate TypeScript\ntypes from a GraphQL schema using the Polywrap CLI's ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," command. "),(0,a.kt)("p",null,"Let's set up a ",(0,a.kt)("inlineCode",{parentName:"p"},"polywrap.app.yaml")," manifest in a new folder called ",(0,a.kt)("inlineCode",{parentName:"p"},"types"),".\nWe will provide the manifest with the path to the composed schema in our build folder."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="polywrap.app.yaml"',title:'"polywrap.app.yaml"'},"format: 0.2.0\nproject:\n  name: generate-typescript-types\n  type: app/typescript\nsource:\n  schema: ../../../build/schema.graphql\n")),(0,a.kt)("p",null,"We can then call the ",(0,a.kt)("inlineCode",{parentName:"p"},"codegen")," command of the Polywrap CLI."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"yarn polywrap codegen -m ./src/__tests__/types/polywrap.yaml -g ./src/__tests__/types/wrap\n")),(0,a.kt)("p",null,"The generated output includes TypeScript types for the SimpleStorage wrapper and its imports."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="types.ts"',title:'"types.ts"'},'...\nexport type String = string;\nexport type Boolean = boolean;\n\nexport interface SetIpfsDataOptions {\n  address: Types.String;\n  data: Types.String;\n}\n\nexport interface SetIpfsDataResult {\n  ipfsHash: Types.String;\n  txReceipt: Types.String;\n}\n\n/// Imported Objects START ///\n\n/* URI: "wrap://ens/ethereum.polywrap.eth" */\nexport interface Ethereum_Connection {\n  node?: Types.String | null;\n  networkNameOrChainId?: Types.String | null;\n}\n...\n')),(0,a.kt)("h2",{id:"testing-a-wrapper-method"},(0,a.kt)("strong",{parentName:"h2"},"Testing a Wrapper Method")),(0,a.kt)("p",null,"From this point, testing a function in your wrapper is no different from testing a traditional SDK. Instead of calling\na method in a traditional SDK, you will invoke your wrapper."),(0,a.kt)("p",null,"We will test the ",(0,a.kt)("inlineCode",{parentName:"p"},"setIpfsData")," method we added to the SimpleStorage API in ",(0,a.kt)("a",{parentName:"p",href:"/tutorials/create-wasm-wrappers/tutorial/adding-new-methods"},"Adding new functions"),".\nFor arguments, the ",(0,a.kt)("inlineCode",{parentName:"p"},"setIpfsData")," method takes the Ethereum address of a deployed SimpleStorage contract and the data\nthe user wants to add to IPFS. It returns the IPFS hash of the data."),(0,a.kt)("p",null,"We will test the ",(0,a.kt)("inlineCode",{parentName:"p"},"setIpfsData")," method using the string ",(0,a.kt)("inlineCode",{parentName:"p"},'"Hello from IPFS!"')," as the data for our test case. To be sure\nour method returns the correct IPFS hash, we can compare the method's return value to the value we get from the free\n",(0,a.kt)("a",{parentName:"p",href:"https://app.pinata.cloud/cidchecker"},(0,a.kt)("em",{parentName:"a"},"File CID Checker"))," service provided by ",(0,a.kt)("a",{parentName:"p",href:"https://www.pinata.cloud/"},"Pinata"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="Final test file"',title:'"Final',test:!0,'file"':!0},'import { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { buildWrapper, initTestEnvironment, stopTestEnvironment, providers } from "@polywrap/test-env-js";\nimport path from "path";\n// highlight-next-line\nimport { SetIpfsDataResult } from \'../types/wrap\';\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  let simpleStorageAddress: string;\n\n  // path to the wrapper\'s build folder\n  let wrapperPath: string;\n\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // absolute path to directory with polywrap.yaml\n    const wrapperDirectory: string = path.resolve(__dirname + "/../../../");\n    // build the wrapper\n    await buildWrapper(wrapperDirectory);\n    wrapperPath = `wrap://fs/${wrapperDirectory}/build`\n    console.log(wrapperPath);\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n\n    // deploy simple storage contract\n    const { data, error } = await client.invoke<string>({\n      uri: wrapperPath,\n      method: "deployContract",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n    console.log(simpleStorageAddress);\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  // highlight-start\n  test("setIpfsData", async () => {\n    // invoke setIpfs method\n    const { data, error } = await client.invoke<SetIpfsDataResult>({\n      uri: wrapperPath,\n      method: "setIpfsData",\n      args: {\n        options: {\n          address: simpleStorageAddress,\n          data: "Hello from IPFS!",\n        },\n      }\n    });\n\n    // check for errors\n    expect(error).toBeFalsy(); // will be undefined if no exception is thrown in the wrapper\n    expect(data).toBeTruthy(); // will be undefined if an exception is thrown in the wrapper\n\n    // compare results\n    expect(data?.ipfsHash).toEqual("QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis");\n  });\n  // highlight-end\n});\n')))}h.isMDXComponent=!0}}]);