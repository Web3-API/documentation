(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{194:function(e,n,r){"use strict";r.d(n,"a",(function(){return p})),r.d(n,"b",(function(){return b}));var t=r(0),a=r.n(t);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=a.a.createContext({}),u=function(e){var n=a.a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},p=function(e){var n=u(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},g=a.a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(r),g=t,b=p["".concat(o,".").concat(g)]||p[g]||d[g]||i;return r?a.a.createElement(b,s(s({ref:n},c),{},{components:r})):a.a.createElement(b,s({ref:n},c))}));function b(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=r.length,o=new Array(i);o[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:t,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,r)}g.displayName="MDXCreateElement"},99:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return i})),r.d(n,"metadata",(function(){return o})),r.d(n,"toc",(function(){return s})),r.d(n,"default",(function(){return c}));var t=r(3),a=(r(0),r(194));const i={id:"client-js",hide_title:!0},o={unversionedId:"reference/clients/js/client-js",id:"reference/clients/js/client-js",isDocsHomePage:!1,title:"client-js",description:"@polywrap/client-js",source:"@site/docs/reference/clients/js/client-js.md",slug:"/reference/clients/js/client-js",permalink:"/reference/clients/js/client-js",editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/reference/clients/js/client-js.md",version:"current",sidebar:"docs",previous:{title:"Infra",permalink:"/reference/cli/commands/infra"},next:{title:"client-config-builder-js",permalink:"/reference/clients/js/client-config-builder-js"}},s=[{value:"Installation",id:"installation",children:[]},{value:"Usage",id:"usage",children:[{value:"Instantiate the client",id:"instantiate-the-client",children:[]},{value:"Invoke a wrapper",id:"invoke-a-wrapper",children:[]},{value:"Configure the client",id:"configure-the-client",children:[]}]},{value:"Reference",id:"reference",children:[{value:"Constructor",id:"constructor",children:[]},{value:"getConfig",id:"getconfig",children:[]},{value:"setTracingEnabled",id:"settracingenabled",children:[]},{value:"getRedirects",id:"getredirects",children:[]},{value:"getPlugins",id:"getplugins",children:[]},{value:"getPluginByUri",id:"getpluginbyuri",children:[]},{value:"getInterfaces",id:"getinterfaces",children:[]},{value:"getEnvs",id:"getenvs",children:[]},{value:"getUriResolver",id:"geturiresolver",children:[]},{value:"getEnvByUri",id:"getenvbyuri",children:[]},{value:"getManifest",id:"getmanifest",children:[]},{value:"getFile",id:"getfile",children:[]},{value:"getImplementations",id:"getimplementations",children:[]},{value:"query",id:"query",children:[]},{value:"invokeWrapper",id:"invokewrapper",children:[]},{value:"invoke",id:"invoke",children:[]},{value:"subscribe",id:"subscribe",children:[]},{value:"tryResolveUri",id:"tryresolveuri",children:[]},{value:"loadWrapper",id:"loadwrapper",children:[]}]},{value:"Development",id:"development",children:[{value:"Build",id:"build",children:[]},{value:"Test",id:"test",children:[]}]}],l={toc:s};function c(e){let{components:n,...r}=e;return Object(a.b)("wrapper",Object(t.a)({},l,r,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"polywrapclient-js"},"@polywrap/client-js"),Object(a.b)("a",{href:"https://www.npmjs.com/package/@polywrap/client-js",target:"_blank",rel:"noopener noreferrer"},Object(a.b)("img",{src:"https://img.shields.io/npm/v/@polywrap/client-js.svg",alt:"npm"})),Object(a.b)("br",null),Object(a.b)("br",null),"The Polywrap JavaScript client invokes functions of wrappers and plugins. It's designed to run in any environment that can execute JavaScript (think websites, node scripts, etc.). It has TypeScript support.",Object(a.b)("h2",{id:"installation"},"Installation"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-bash"},"npm install --save @polywrap/client-js\n")),Object(a.b)("h2",{id:"usage"},"Usage"),Object(a.b)("h3",{id:"instantiate-the-client"},"Instantiate the client"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},'import { PolywrapClient } from "@polywrap/client-js";\n\nconst client = new PolywrapClient();\n')),Object(a.b)("h3",{id:"invoke-a-wrapper"},"Invoke a wrapper"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},'await client.invoke({\n  uri: "ens/rinkeby/helloworld.dev.polywrap.eth",\n  method: "logMessage",\n  args: {\n    message: "Hello World!"\n  }\n});\n')),Object(a.b)("h3",{id:"configure-the-client"},"Configure the client"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},'const config = {\n  // redirect queries from one uri to another\n  redirects: [\n    {\n      from: "wrap://ens/from.eth",\n      to: "wrap://ens/to.eth",\n    }\n  ],\n  // declare and configure plugin wrappers\n  plugins: [\n    {\n      uri: "wrap://ens/ipfs.polywrap.eth",\n      plugin: ipfsPlugin({}),\n    },\n  ],\n  // declare interface implementations\n  interfaces: [\n    {\n      interface: "wrap://ens/uri-resolver.core.polywrap.eth",\n      implementations: [\n        "wrap://ens/ipfs-resolver.polywrap.eth",\n      ],\n    },\n  ],\n  // set environmental variables for a wrapper\n  envs: [\n    {\n      uri: "wrap://ens/ipfs.polywrap.eth",\n      env: {\n        provider: "https://ipfs.wrappers.io",\n      },\n    },\n  ],\n  \n  // ADVANCED USAGE:\n  \n  // customize URI resolution\n  resolver: new RecursiveResolver(\n    new PackageToWrapperCacheResolver(wrapperCache, [\n      new LegacyRedirectsResolver(),\n      new LegacyPluginsResolver(),\n      new ExtendableUriResolver(),\n    ])\n  ),\n\n  // custom wrapper cache\n  wrapperCache: new WrapperCache(),\n  \n  // tracer configuration - see @polywrap/tracing-js package\n  tracerConfig: { ... },\n};\n')),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"// create a client by modifying the default configuration bundle\nconst client = new PolywrapClient(config);\n\n// or remove and replace the default configuration\nconst altClient = new PolywrapClient(config, { noDefaults: true });\n")),Object(a.b)("h2",{id:"reference"},"Reference"),Object(a.b)("h3",{id:"constructor"},"Constructor"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Instantiate a PolywrapClient\n *\n * @param config - a whole or partial client configuration\n * @param options - { noDefaults?: boolean }\n */\nconstructor(config?: Partial<PolywrapClientConfig<string | Uri>>, options?: {\n  noDefaults?: boolean;\n});\n")),Object(a.b)("h3",{id:"getconfig"},"getConfig"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Returns the configuration used to instantiate the client\n *\n * @returns an immutable Polywrap client config\n */\ngetConfig(): PolywrapClientConfig<Uri>;\n")),Object(a.b)("h3",{id:"settracingenabled"},"setTracingEnabled"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Enable tracing for intricate debugging\n *\n * @remarks\n * Tracing uses the @polywrap/tracing-js package\n *\n * @param tracerConfig - configure options such as the tracing level\n * @returns void\n */\nsetTracingEnabled(tracerConfig?: Partial<TracerConfig>): void;\n")),Object(a.b)("h3",{id:"getredirects"},"getRedirects"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all uri redirects from the configuration used to instantiate the client\n *\n * @returns an array of uri redirects\n */\ngetRedirects(): readonly UriRedirect<Uri>[];\n")),Object(a.b)("h3",{id:"getplugins"},"getPlugins"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all plugin registrations from the configuration used to instantiate the client\n *\n * @returns an array of plugin registrations\n */\ngetPlugins(): readonly PluginRegistration<Uri>[];\n")),Object(a.b)("h3",{id:"getpluginbyuri"},"getPluginByUri"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns a plugin package from the configuration used to instantiate the client\n *\n * @param uri - the uri used to register the plugin\n * @returns a plugin package, or undefined if a plugin is not found at the given uri\n */\ngetPluginByUri<TUri extends Uri | string>(uri: TUri): PluginPackage<unknown> | undefined;\n")),Object(a.b)("h3",{id:"getinterfaces"},"getInterfaces"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all interfaces from the configuration used to instantiate the client\n *\n * @returns an array of interfaces and their registered implementations\n */\ngetInterfaces(): readonly InterfaceImplementations<Uri>[];\n")),Object(a.b)("h3",{id:"getenvs"},"getEnvs"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns all env registrations from the configuration used to instantiate the client\n *\n * @returns an array of env objects containing wrapper environmental variables\n */\ngetEnvs(): readonly Env<Uri>[];\n")),Object(a.b)("h3",{id:"geturiresolver"},"getUriResolver"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns the URI resolver from the configuration used to instantiate the client\n *\n * @returns an object that implements the IUriResolver interface\n */\ngetUriResolver(): IUriResolver<unknown>;\n")),Object(a.b)("h3",{id:"getenvbyuri"},"getEnvByUri"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns an env (a set of environmental variables) from the configuration used to instantiate the client\n *\n * @param uri - the URI used to register the env\n * @returns an env, or undefined if an env is not found at the given URI\n */\ngetEnvByUri<TUri extends Uri | string>(uri: TUri): Env<Uri> | undefined;\n")),Object(a.b)("h3",{id:"getmanifest"},"getManifest"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns a package's wrap manifest\n *\n * @param uri - a wrap URI\n * @param options - { noValidate?: boolean }\n * @returns a Result containing the WrapManifest if the request was successful\n */\ngetManifest<TUri extends Uri | string>(uri: TUri, options?: GetManifestOptions): Promise<Result<WrapManifest, Error>>;\n")),Object(a.b)("h3",{id:"getfile"},"getFile"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},'/**\n * returns a file contained in a wrap package\n *\n * @param uri - a wrap URI\n * @param options - { path: string; encoding?: "utf-8" | string }\n * @returns a Promise of a Result containing a file if the request was successful\n */\ngetFile<TUri extends Uri | string>(uri: TUri, options: GetFileOptions): Promise<Result<string | Uint8Array, Error>>;\n')),Object(a.b)("h3",{id:"getimplementations"},"getImplementations"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * returns the interface implementations associated with an interface URI\n *  from the configuration used to instantiate the client\n *\n * @param uri - a wrap URI\n * @param options - { applyRedirects?: boolean }\n * @returns a Result containing URI array if the request was successful\n */\ngetImplementations<TUri extends Uri | string>(uri: TUri, options?: GetImplementationsOptions): Result<TUri[], Error>;\n")),Object(a.b)("h3",{id:"query"},"query"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using GraphQL query syntax\n *\n * @remarks\n * This method behaves similar to the invoke method and allows parallel requests,\n * but the syntax is more verbose. If the query is successful, data will be returned\n * and the `error` value of the returned object will be undefined. If the query fails,\n * the data property will be undefined and the error property will be populated.\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // The GraphQL query to parse and execute, leading to one or more Wrapper invocations.\n *   query: string | QueryDocument;\n *\n *   // Variables referenced within the query string via GraphQL's '$variable' syntax.\n *   variables?: TVariables;\n * }\n *\n * @returns A Promise containing an object with either the data or an error\n */\nquery<TData extends Record<string, unknown> = Record<string, unknown>, TVariables extends Record<string, unknown> = Record<string, unknown>, TUri extends Uri | string = string>(options: QueryOptions<TVariables, TUri>): Promise<QueryResult<TData>>;\n")),Object(a.b)("h3",{id:"invokewrapper"},"invokeWrapper"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using standard syntax and an instance of the wrapper\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\ninvokeWrapper<TData = unknown, TUri extends Uri | string = string>(options: InvokerOptions<TUri> & {\n    wrapper: Wrapper;\n}): Promise<InvokeResult<TData>>;\n")),Object(a.b)("h3",{id:"invoke"},"invoke"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper using standard syntax.\n * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper.\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\ninvoke<TData = unknown, TUri extends Uri | string = string>(options: InvokerOptions<TUri>): Promise<InvokeResult<TData>>;\n")),Object(a.b)("h3",{id:"subscribe"},"subscribe"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Invoke a wrapper at a regular frequency (within ~16ms)\n *\n * @param options - {\n *   // The Wrapper's URI\n *   uri: TUri;\n *\n *   // Method to be executed.\n *   method: string;\n *\n *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordering arguments.\n *    args?: Record<string, unknown> | Uint8Array;\n *\n *   // Env variables for the wrapper invocation.\n *    env?: Record<string, unknown>;\n *\n *   resolutionContext?: IUriResolutionContext;\n *\n *   // if true, return value is a msgpack-encoded byte array\n *   encodeResult?: boolean;\n *\n *   // the frequency at which to perform the invocation\n *   frequency?: {\n *     ms?: number;\n *     sec?: number;\n *     min?: number;\n *     hours?: number;\n *   }\n * }\n *\n * @returns A Promise with a Result containing the return value or an error\n */\nsubscribe<TData = unknown, TUri extends Uri | string = string>(options: SubscribeOptions<TUri>): Subscription<TData>;\n")),Object(a.b)("h3",{id:"tryresolveuri"},"tryResolveUri"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"/**\n * Resolve a URI to a wrap package, a wrapper, or a uri\n *\n * @param options - { uri: TUri; resolutionContext?: IUriResolutionContext }\n * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful\n */\ntryResolveUri<TUri extends Uri | string>(options: TryResolveUriOptions<TUri>): Promise<Result<UriPackageOrWrapper, unknown>>;\n")),Object(a.b)("h3",{id:"loadwrapper"},"loadWrapper"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},'/**\n * Resolve a URI to a wrap package or wrapper.\n * If the URI resolves to wrap package, load the wrapper.\n *\n * @remarks\n * Unlike other methods, `loadWrapper` does not accept a string URI.\n * You can create a Uri (from the `@polywrap/core-js` package) using `Uri.from("wrap://...")`\n *\n * @param uri: the Uri to resolve\n * @param resolutionContext? a resolution context\n * @param options - { noValidate?: boolean }\n * @returns A Promise with a Result containing either a wrapper if successful\n */\nloadWrapper(uri: Uri, resolutionContext?: IUriResolutionContext, options?: DeserializeManifestOptions): Promise<Result<Wrapper, Error>>;\n')),Object(a.b)("h2",{id:"development"},"Development"),Object(a.b)("p",null,"The Polywrap JavaScript client is open-source. It lives within the ",Object(a.b)("a",{parentName:"p",href:"https://github.com/polywrap/toolchain/tree/origin/packages/js/client"},"Polywrap toolchain monorepo"),". Contributions from the community are welcomed!"),Object(a.b)("h3",{id:"build"},"Build"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-bash"},"nvm use && yarn install && yarn build\n")),Object(a.b)("h3",{id:"test"},"Test"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-bash"},"yarn test\n")))}c.isMDXComponent=!0}}]);