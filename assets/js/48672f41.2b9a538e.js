(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{105:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return p})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return u}));var r=t(3),i=t(8),a=(t(0),t(164)),o=["components"],s={id:"end-to-end-test",title:"Writing tests with TypeScript"},p={unversionedId:"quick-start/create-wasm-wrappers/end-to-end-test",id:"quick-start/create-wasm-wrappers/end-to-end-test",isDocsHomePage:!1,title:"Writing tests with TypeScript",description:"Introduction",source:"@site/docs/quick-start/create-wasm-wrappers/end-to-end-test.md",slug:"/quick-start/create-wasm-wrappers/end-to-end-test",permalink:"/quick-start/create-wasm-wrappers/end-to-end-test",editUrl:"https://github.com/polywrap/documentation/tree/main/src/docs/quick-start/create-wasm-wrappers/end-to-end-test.md",version:"current",sidebar:"docs",previous:{title:"Deploy locally & run tests",permalink:"/quick-start/create-wasm-wrappers/deploy-locally-and-test"},next:{title:"Default plugins",permalink:"/quick-start/create-wasm-wrappers/default-plugins"}},l=[{value:"<strong>Introduction</strong>",id:"introduction",children:[]},{value:"<strong>Prerequisites</strong>",id:"prerequisites",children:[]},{value:"<strong>The Polywrap Test Environment</strong>",id:"the-polywrap-test-environment",children:[]},{value:"<strong>Starting and stopping a Polywrap Test environment with @polywrap/test-env-js</strong>",id:"starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js",children:[]},{value:"<strong>Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js</strong>",id:"building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js",children:[]},{value:"<strong>Setting up a Polywrap Client</strong>",id:"setting-up-a-polywrap-client",children:[{value:"<strong>Configure the IPFS Resolver Plugin</strong>",id:"configure-the-ipfs-resolver-plugin",children:[]},{value:"<strong>Configure the Ethereum Plugin</strong>",id:"configure-the-ethereum-plugin",children:[]},{value:"<strong>Configure the ENS Resolver Plugin</strong>",id:"configure-the-ens-resolver-plugin",children:[]},{value:"<strong>Create the Polywrap Client Instance</strong>",id:"create-the-polywrap-client-instance",children:[]}]},{value:"<strong>Deploy the Smart Contract</strong>",id:"deploy-the-smart-contract",children:[]},{value:"<strong>Generate TypeScript Types</strong>",id:"generate-typescript-types",children:[]},{value:"<strong>Testing a Wrapper Method</strong>",id:"testing-a-wrapper-method",children:[]}],c={toc:l};function u(e){var n=e.components,t=Object(i.a)(e,o);return Object(a.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"introduction"},Object(a.b)("strong",{parentName:"h2"},"Introduction")),Object(a.b)("p",null,"Here we discuss the process of writing end to end (e2e) tests for your Wasm wrapper using TypeScript.\nBy end-to-end, we mean tests that make calls to the wrapper through a Polywrap Client.\nE2e testing is both necessary and useful.\nIt is necessary because calls between wrappers depend on the Polywrap Client, and therefore cannot always be made in a\nWasm wrapper's native language.\nIt is useful because such tests can more accurately represent the user experience of your wrapper when it is integrated\ninto an application."),Object(a.b)("p",null,"We will focus on setting up a test environment and a Polywrap Client. Once these tasks are completed, testing\na Wasm wrapper is similar to testing a traditional SDK."),Object(a.b)("h2",{id:"prerequisites"},Object(a.b)("strong",{parentName:"h2"},"Prerequisites")),Object(a.b)("p",null,"This guide uses ",Object(a.b)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," to implement the Polywrap test environment. We will also\nuse the ",Object(a.b)("a",{parentName:"p",href:"https://jestjs.io/"},"Jest")," testing framework, though you can use any framework and follow without difficulty."),Object(a.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(a.b)("div",{parentName:"div",className:"admonition-heading"},Object(a.b)("h5",{parentName:"div"},Object(a.b)("span",{parentName:"h5",className:"admonition-icon"},Object(a.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(a.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),Object(a.b)("div",{parentName:"div",className:"admonition-content"},Object(a.b)("p",{parentName:"div"},"In the future, TypeScript will be one of many supported languages with a Polywrap client.\nAs more Polywrap Clients are released in various languages, implementing plugin wrappers in those languages will be supported as well."))),Object(a.b)("p",null,"You'll need the following installed as developer dependencies before testing your wrapper:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"../../reference/cli/polywrap-cli"},"polywrap")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"@polywrap/test-env-js")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"../../reference/clients/js/client-js"},"@polywrap/client-js")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"jest")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"@types/jest"))),Object(a.b)("p",null,"These can be added to your TypeScript project using the npm or yarn package managers:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"npm install --save-dev polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"yarn add -D polywrap @polywrap/test-env-js @polywrap/client-js jest @types/jest\n")),Object(a.b)("h2",{id:"the-polywrap-test-environment"},Object(a.b)("strong",{parentName:"h2"},"The Polywrap Test Environment")),Object(a.b)("p",null,"A Polywrap test environment is most useful when it integrates an IPFS node and an Ethereum test network, so that incomplete\nwrappers can be deployed and queried on your local machine."),Object(a.b)("p",null,"The Polywrap CLI can be used to start a Polywrap-ready test environment:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-shell"},"npx polywrap infra up --modules=eth-ens-ipfs\n")),Object(a.b)("p",null,"The CLI can also be used to stop the test environment:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-shell"},"npx polywrap infra down --modules=eth-ens-ipfs\n")),Object(a.b)("p",null,"The test environment is a docker container with:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"A test server at ",Object(a.b)("strong",{parentName:"li"},"http://localhost:4040")),Object(a.b)("li",{parentName:"ul"},"A standard Ganache Ethereum test network at ",Object(a.b)("strong",{parentName:"li"},"http://localhost:8545")),Object(a.b)("li",{parentName:"ul"},"An IPFS node at ",Object(a.b)("strong",{parentName:"li"},"http://localhost:5001"))),Object(a.b)("p",null,"It also sets up an ENS contract at initialization, so you can build wrappers and deploy them to an ENS URI on your locally hosted testnet."),Object(a.b)("p",null,"However, this guide will use the ",Object(a.b)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," package instead. The ",Object(a.b)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," can be used to start\nand stop this same test environment programmatically.\n:::"),Object(a.b)("h2",{id:"starting-and-stopping-a-polywrap-test-environment-with-polywraptest-env-js"},Object(a.b)("strong",{parentName:"h2"},"Starting and stopping a Polywrap Test environment with @polywrap/test-env-js")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," package includes functions for starting and stopping a Polywrap test environment."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"initTestEnvironment")," function takes no arguments starts a local test environment."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"stopTestEnvironment")," function takes no arguments and tears down a test environment if one is running."),Object(a.b)("p",null,"The package also exports a ",Object(a.b)("inlineCode",{parentName:"p"},"providers")," object with URIs for our local ethereum network provider and IPFS provider,\nas well as an ",Object(a.b)("inlineCode",{parentName:"p"},"ensAddresses")," object containing the Ethereum address of our locally-deployed ENS registry smart contract."),Object(a.b)("p",null,"To see these in action, let's start a new file where we will write our first test. Like many testing frameworks in\nJavaScript, the Jest framework includes hooks that run before and after all tests. I've added a call to ",Object(a.b)("inlineCode",{parentName:"p"},"initTestEnvironment"),"\nin the ",Object(a.b)("inlineCode",{parentName:"p"},"beforeAll")," hook, so we can start our test environment before running our tests. I added a call to ",Object(a.b)("inlineCode",{parentName:"p"},"stopTestEnvironment"),"\nin the ",Object(a.b)("inlineCode",{parentName:"p"},"afterAll")," hook to make sure the test environment does not continue running on our system after we finish testing."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'import { initTestEnvironment, stopTestEnvironment } from "@polywrap/test-env-js";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),Object(a.b)("h2",{id:"building-and-deploying-a-wasm-wrapper-for-testing-with-polywraptest-env-js"},Object(a.b)("strong",{parentName:"h2"},"Building and deploying a Wasm wrapper for testing with @polywrap/test-env-js")),Object(a.b)("p",null,"To invoke a Wasm wrapper in a test, we first need to build and deploy it. We can do this with ",Object(a.b)("inlineCode",{parentName:"p"},"@polywrap/test-env-js")," using\nthe ",Object(a.b)("inlineCode",{parentName:"p"},"buildAndDeployWrapper")," function. The ",Object(a.b)("inlineCode",{parentName:"p"},"buildAndDeployWrapper")," function requires an absolute path to the directory of\nyour wrapper project that contains the ",Object(a.b)("inlineCode",{parentName:"p"},"polywrap.yaml")," manifest file, the values that were returned by ",Object(a.b)("inlineCode",{parentName:"p"},"initTestEnvironment"),",\nand optionally an ENS domain name."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"buildAndDeployWrapper")," function returns an ENS domain name and an IPFS CID. Either of these outputs can be used to call\nyour wrapper. If an ENS domain name was not provided when calling ",Object(a.b)("inlineCode",{parentName:"p"},"buildAndDeployWrapper"),", a name will be randomly selected for you."),Object(a.b)("p",null,"Here we obtain the absolute path to our wrapper project in three steps. First we get the directory of the folder containing\nour test script, using the node.js ",Object(a.b)("inlineCode",{parentName:"p"},"__dirname")," global variable. We then append the path from our test script file to the\nmanifest directory. Finally, we import the node.js feature ",Object(a.b)("inlineCode",{parentName:"p"},"path"),", and use ",Object(a.b)("inlineCode",{parentName:"p"},"path.resolve")," to get direct absolute path to\nour wrapper project."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'// highlight-start\nimport { buildAndDeployWrapper, initTestEnvironment, stopTestEnvironment, providers } from "@polywrap/test-env-js";\nimport path from "path";\n// highlight-end\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // highlight-start\n  // the ENS URI that will be used to invoke the wrapper\n  let ensUri: string;\n  // highlight-end\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // highlight-start\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + "/../../../"); // absolute path to directory with polywrap.yaml\n    const api = await buildAndDeployWrapper({\n      wrapperAbsPath: apiPath,\n      ipfsProvider: providers.ipfs,\n      ethereumProvider: providers.ethereum,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network "testnet"\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),Object(a.b)("h2",{id:"setting-up-a-polywrap-client"},Object(a.b)("strong",{parentName:"h2"},"Setting up a Polywrap Client")),Object(a.b)("p",null,"Now that we have deployed our Wasm wrapper to a local test environment, we need to set up a Polywrap Client that can\ninvoke it. We can make sure our client is ready to invoke the wrapper by configuring three of the default plugin wrappers."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"ipfsResolverPlugin")," can be configured using the test environment's local IPFS node."),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"ethereumPlugin")," can be configured with Ethereum providers on the Ganache Ethereum test network and the Ganache\nmainnet fork network from our test environment."),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"ensResolverPlugin")," can be configured using the Ethereum address of the test environment's ENS registry contract.")),Object(a.b)("h3",{id:"configure-the-ipfs-resolver-plugin"},Object(a.b)("strong",{parentName:"h3"},"Configure the IPFS Resolver Plugin")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"ipfsResolverPlugin")," can be configured with a default IPFS provider and an array of fallback providers that will be tried if\nthe default provider fails."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'import { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\n\nconst ipfsConfig: IpfsPluginConfig = {\n  provider: providers.ipfs,\n  fallbackProviders: undefined,\n};\n')),Object(a.b)("h3",{id:"configure-the-ethereum-plugin"},Object(a.b)("strong",{parentName:"h3"},"Configure the Ethereum Plugin")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"ethereumPlugin")," can be configured with Ethereum providers and signers. It accepts JSON RPC provider strings,\nProviders from the ethers.js package, and providers from the web3.js package."),Object(a.b)("p",null,"To configure the plugin, we need to provide it with an object containing network names along with a provider. We can\noptionally provide a signer as well, but by default the plugin will attempt to obtain a signer from the provider if it\nis needed."),Object(a.b)("p",null,'We can give networks any name we want in our configuration. We can later use these names to choose which network to\nquery. Here we will use the name "testnet" for our local Ethereum test network.'),Object(a.b)("p",null,"We also need to tell the Ethereum plugin which network should be used when a network is not specified. We do this by\nsetting the value of the ",Object(a.b)("inlineCode",{parentName:"p"},"defaultNetwork")," property to one of our network names."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'import { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\n\nconst ethereumConfig: EthereumPluginConfig = {\n  networks: {\n    testnet: {\n      provider: providers.ethereum, // Ganache test network\n    },\n  },\n  defaultNetwork: "testnet",\n};\n')),Object(a.b)("h3",{id:"configure-the-ens-resolver-plugin"},Object(a.b)("strong",{parentName:"h3"},"Configure the ENS Resolver Plugin")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"ensResolverPlugin")," accepts an Ethereum address for the ENS registry contract on each of the Ethereum networks declared\nin our Ethereum plugin configuration. We will only use the ENS registry deployed on our test environment's Ethereum\nnetwork."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'import { ensResolverPlugin, EnsResolverPluginConfig } from "@polywrap/ens-resolver-plugin-js";\n\nconst ensConfig: EnsResolverPluginConfig = {\n  addresses: {\n    testnet: ensAddresses.ensAddress,\n  },\n};\n')),Object(a.b)("h3",{id:"create-the-polywrap-client-instance"},Object(a.b)("strong",{parentName:"h3"},"Create the Polywrap Client Instance")),Object(a.b)("p",null,"Now we are ready to add the plugins to our Polywrap Client configuration and create the client. The URI's we assign in\nour client configuration will redirect to the plugin instances when queried."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'// highlight-start\nimport { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { ensResolverPlugin, EnsResolverPluginConfig } from "@polywrap/ens-resolver-plugin-js";\n// highlight-end\nimport { buildAndDeployWrapper, initTestEnvironment, stopTestEnvironment, providers, ensAddresses } from "@polywrap/test-env-js";\nimport path from "path";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // the ENS URI that will be used to invoke the wrapper\n  let ensUri: string;\n\n  // highlight-start\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n  // highlight-end\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + "/../../../"); // absolute path to directory with polywrap.yaml\n    const api = await buildAndDeployWrapper({\n      wrapperAbsPath: apiPath,\n      ipfsProvider: providers.ipfs,\n      ethereumProvider: providers.ethereum,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network "testnet"\n\n    // highlight-start\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum, // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsResolverPluginConfig = {\n      addresses: {\n        testnet: ensAddresses.ensAddress,\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ens-resolver.polywrap.eth",\n          plugin: ensResolverPlugin(ensConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),Object(a.b)("h2",{id:"deploy-the-smart-contract"},Object(a.b)("strong",{parentName:"h2"},"Deploy the Smart Contract")),Object(a.b)("p",null,"The SimpleStorage wrapper is designed to interact with a SimpleStorage smart contract. We need to deploy an\ninstance of the contract to work with. While there are many tools developers can use to deploy a smart contract on a\nlocal network, the SimpleStorage API has a method ",Object(a.b)("inlineCode",{parentName:"p"},"deployContract")," we can use to get the job done. We'll call it before\nrunning our test to make sure the contract is ready."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},'import { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { ensResolverPlugin, EnsResolverPluginConfig } from "@polywrap/ens-resolver-plugin-js";\nimport { buildAndDeployWrapper, initTestEnvironment, stopTestEnvironment, providers, ensAddresses } from "@polywrap/test-env-js";\nimport path from "path";\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  // highlight-start\n  let simpleStorageAddress: string;\n  // highlight-end\n\n  // the ENS URI that will be used to invoke the wrapper\n  let ensUri: string;\n\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + "/../../../"); // absolute path to directory with polywrap.yaml\n    const api = await buildAndDeployWrapper({\n      wrapperAbsPath: apiPath,\n      ipfsProvider: providers.ipfs,\n      ethereumProvider: providers.ethereum,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network "testnet"\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum, // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsResolverPluginConfig = {\n      addresses: {\n        testnet: ensAddresses.ensAddress,\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ens-resolver.polywrap.eth",\n          plugin: ensResolverPlugin(ensConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n\n    // deploy simple storage contract\n    // highlight-start\n    const { data, error } = await client.invoke<string>({\n      uri: ensUri,\n      method: "deployContract",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test("", async () => { });\n});\n')),Object(a.b)("h2",{id:"generate-typescript-types"},Object(a.b)("strong",{parentName:"h2"},"Generate TypeScript Types")),Object(a.b)("p",null,"Since we are using TypeScript, we will want types to work with. It is possible to automatically generate TypeScript\ntypes from a GraphQL schema using the Polywrap CLI's ",Object(a.b)("inlineCode",{parentName:"p"},"app")," command. "),Object(a.b)("p",null,"Let's set up a ",Object(a.b)("inlineCode",{parentName:"p"},"polywrap.app.yaml")," manifest in a new folder called ",Object(a.b)("inlineCode",{parentName:"p"},"types"),"."),Object(a.b)("p",null,"Before building our wrapper, we have a GraphQL schema for each of our modules. The ",Object(a.b)("inlineCode",{parentName:"p"},"app")," command is intended to be used\nwith built wrappers, which have only one schema. We will provide the manifest with the path to the composed schema in\nour build folder. This means we need to build our wrapper before running tests."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'title="polywrap.app.yaml"',title:'"polywrap.app.yaml"'},"$start: yaml-e2e-test-app-manifest\n")),Object(a.b)("p",null,"We can then call the ",Object(a.b)("inlineCode",{parentName:"p"},"app")," command of the Polywrap CLI."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-shell"},"yarn polywrap app codegen -m ./src/__tests__/types/polywrap.app.yaml -g ./src/__tests__/types/wrap\n")),Object(a.b)("p",null,"The generated output includes TypeScript types for the SimpleStorage wrapper and its imports."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript",metastring:'title="types.ts"',title:'"types.ts"'},'...\nexport type String = string;\nexport type Boolean = boolean;\n\nexport interface SetIpfsDataOptions {\n  address: Types.String;\n  data: Types.String;\n}\n\nexport interface SetIpfsDataResult {\n  ipfsHash: Types.String;\n  txReceipt: Types.String;\n}\n\n/// Imported Objects START ///\n\n/* URI: "wrap://ens/ethereum.polywrap.eth" */\nexport interface Ethereum_Connection {\n  node?: Types.String | null;\n  networkNameOrChainId?: Types.String | null;\n}\n...\n')),Object(a.b)("h2",{id:"testing-a-wrapper-method"},Object(a.b)("strong",{parentName:"h2"},"Testing a Wrapper Method")),Object(a.b)("p",null,"From this point, testing a function in your wrapper is no different from testing a traditional SDK. Instead of calling\na method in a traditional SDK, you will invoke your wrapper."),Object(a.b)("p",null,"We will test the ",Object(a.b)("inlineCode",{parentName:"p"},"setIpfsData")," method we added to the SimpleStorage API in ",Object(a.b)("a",{parentName:"p",href:"./adding-new-methods"},"Adding new functions"),".\nFor arguments, the ",Object(a.b)("inlineCode",{parentName:"p"},"setIpfsData")," method takes the Ethereum address of a deployed SimpleStorage contract and the data\nthe user wants to add to IPFS. It returns the IPFS hash of the data."),Object(a.b)("p",null,"We will test the ",Object(a.b)("inlineCode",{parentName:"p"},"setIpfsData")," method using the string ",Object(a.b)("inlineCode",{parentName:"p"},'"Hello from IPFS!"')," as the data for our test case. To be sure\nour method returns the correct IPFS hash, we can compare the method's return value to the value we get from the free\n",Object(a.b)("a",{parentName:"p",href:"https://app.pinata.cloud/cidchecker"},Object(a.b)("em",{parentName:"a"},"File CID Checker"))," service provided by ",Object(a.b)("a",{parentName:"p",href:"https://www.pinata.cloud/"},"Pinata"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript",metastring:'title="Final test file"',title:'"Final',test:!0,'file"':!0},'import { ClientConfig, PolywrapClient } from "@polywrap/client-js";\nimport { ethereumPlugin, EthereumPluginConfig } from "@polywrap/ethereum-plugin-js";\nimport { ipfsPlugin, IpfsPluginConfig } from "@polywrap/ipfs-plugin-js";\nimport { ensResolverPlugin, EnsResolverPluginConfig } from "@polywrap/ens-resolver-plugin-js";\nimport { buildAndDeployWrapper, initTestEnvironment, stopTestEnvironment, providers, ensAddresses } from "@polywrap/test-env-js";\nimport path from "path";\n// highlight-next-line\nimport { SetIpfsDataResult } from \'../types/wrap\';\n\njest.setTimeout(360000);\n\ndescribe(\'Wrapper Test\', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  let simpleStorageAddress: string;\n\n  // the ENS URI that will be used to invoke the wrapper\n  let ensUri: string;\n\n  // an instance of the Polywrap Client\n  let client: PolywrapClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + "/../../../"); // absolute path to directory with polywrap.yaml\n    const api = await buildAndDeployWrapper({\n      wrapperAbsPath: apiPath,\n      ipfsProvider: providers.ipfs,\n      ethereumProvider: providers.ethereum,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network "testnet"\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfig = {\n      provider: providers.ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfig = {\n      networks: {\n        testnet: {\n          provider: providers.ethereum, // Ganache test network\n        },\n      },\n      defaultNetwork: "testnet",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsResolverPluginConfig = {\n      addresses: {\n        testnet: ensAddresses.ensAddress,\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: "wrap://ens/ipfs.polywrap.eth",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: "wrap://ens/ens-resolver.polywrap.eth",\n          plugin: ensResolverPlugin(ensConfig),\n        },\n        {\n          uri: "wrap://ens/ethereum.polywrap.eth",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new PolywrapClient(clientConfig);\n\n    // deploy simple storage contract\n    const { data, error } = await client.invoke<string>({\n      uri: ensUri,\n      method: "deployContract",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  // highlight-start\n  test("setIpfsData", async () => {\n    // invoke setIpfs method\n    const { data, error } = await client.invoke<SetIpfsDataResult>({\n      uri: ensUri,\n      method: "setIpfsData",\n      args: {\n        options: {\n          address: simpleStorageAddress,\n          data: "Hello from IPFS!",\n        },\n      }\n    });\n\n    // check for errors\n    expect(error).toBeFalsy(); // will be undefined if no exception is thrown in the wrapper\n    expect(data).toBeTruthy(); // will be undefined if an exception is thrown in the wrapper\n\n    // compare results\n    expect(data?.ipfsHash).toEqual("QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis");\n  });\n  // highlight-end\n});\n')))}u.isMDXComponent=!0},164:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return m}));var r=t(0),i=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),c=function(e){var n=i.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return i.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},h=i.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),u=c(t),h=r,m=u["".concat(o,".").concat(h)]||u[h]||d[h]||a;return t?i.a.createElement(m,s(s({ref:n},l),{},{components:t})):i.a.createElement(m,s({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=h;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);